Attribute VB_Name = "CAPFLOW"
Option Explicit
DefSng A-Z
Global Burster As Boolean
Global hydroBP As Boolean

Global HighTempPressureGauge As Boolean

'6.71.99 edc 12-15-06 added for sound
Private Declare Function sndPlaySound Lib "winmm.dll" Alias "sndPlaySoundA" (ByVal lpszSoundName As String, ByVal uFlag As Long) As Long
Private Const SND_ASYNC = &H1
Private Const sndLoop = &H8
Private Declare Function sndStopSound Lib "winmm.dll" Alias "sndPlaySoundA" (ByVal lpszSoundName As Long, ByVal uFlags As Long) As Long

' 6.71.68
Dim MFP As Single       ' This is from the calcMFP routine - moved here so that the log file statistics could use it
Dim logFileResults(2) As Single     ' holds bp (1) and mfp(2)

' 7-23-2009 by JF
Dim UsingNonStandardOrificeSize As Boolean

' The reading override to use on a reading
Dim ActiveReadMath As ReadingMath

Rem variables that are only used in this module
Type pfdata2
    pr As Single
    fl As Single
    fl2 As Single ' for secondary storage of flow data.  added 6.71.20
    fluid As Single
    eqd As Integer
    time As Single
    temp1 As Single 'AJB 10-20-09
    temp2 As Single 'AJB 10-20-09
    humidity As Single
End Type

Type TPSR ' type of parallel stability routine
    LowF As Single
    HighF As Single
    LowP As Single
    HighP As Single
    n As Integer
    SumP As Double
    SumF As Double
    startTime As Single
End Type

Type dat_array
    s As Integer
    a() As pfdata2
End Type

Type SplitStringResult      ' For use with function splitString
    numberOfValues As Integer
    values() As String
End Type

Type pressureList
    values() As Single
    count As Integer
    dirty As Boolean
End Type

' A value holder type for math done to count readings - Mix
Type ReadingMath
    ' Whether or not the override is active and will change the readings values
    OverrideActive As Boolean
    
    ' Counts
    MinCounts As Long
    MaxCounts As Long
    
    ' Gauge rating stuff
    MinRead As Single
    MaxRead As Single
End Type
Dim ReadingMaths(42) As ReadingMath

Dim first_array As dat_array
Dim second_array As dat_array
Global frazier_array As dat_array
Dim man_bp_detect As Boolean
' need to be global for screen graph
Dim LastPr As Single
Dim LastFl As Single
Dim P As Single, f As Single, P0 As Single
Dim lock_p0 As Boolean
Dim GMaxF As Single, GMaxP As Single
Dim First_Curve As Boolean
Dim MaxP As Single ' used in elev liq perm
Dim DELTAP As Single ' "
Dim initp As Long
Dim inrange As Boolean
Dim maxPoints As Integer
Dim ptarg As Single
Dim maxWait As Single
Dim BadFlow(100) As Single ' used in run_c_pass
Dim color1 As Long, color2 As Long, color3 As Long ' curve to pass color
Dim EBPP As Single
Dim FPOINTS As Long 'AJB 12-16-09 was Integer, changed to Long
Dim FLAST As Single
Dim FillDone As Boolean
Dim hfmin%
Dim MaxLowFlow As Single
Dim NOWHERE%
Dim pass As Integer
Dim points As Long 'AJB 12-16-09 was Integer, changed to Long
Dim plast As Single
Dim PROGRAMCTRL As Integer
Dim SPOINTS As Long 'AJB 12-16-09 was Integer, changed to Long
Dim SBPP As Long
Dim SHFP As Long
Dim SBPP1 As Long
Dim SHFP1 As Long
Dim SBPP2 As Long
Dim SHFP2 As Long
Dim SV2P As Long
Dim V2FACTR As Single
Dim v2 As Long
Dim pen_bias As Long
Dim max_count_p As Long
Dim took_point_time As Single
Dim regulator_running As Boolean
Dim compression_regulator_running As Boolean
Dim PSR As TPSR
Dim ITP As Single
Dim BBPP As Single
Dim skipincrease As Boolean
Dim diffp As Single
Dim fluid_sensor_0 As Single
Dim TTarg As Single
Dim leak_max_p As Double
Dim leak_step_p As Double
Dim leak_wait As Single
Dim lperm_temperature As Single
Dim lperm_initializeRegulatorPressure As Single
Dim lperm_regulatorIncrementSteps As Integer
Dim lperm_autoFillVentTime As Single
Dim LastFlowTime As Single
Dim FlowN As Single
Dim fsum As Single
' 6.71.57, moved here for 6.71.68
Dim fifty_or_seven As Integer ' 50 when using first or only regulator, 7 when using second regulator
Dim stagnation_check_best_flow As Single
Dim stagnation_check_best_pressure As Single
Dim stagnation_check_iterations As Integer
' 6.71.77
Dim iso_valve_string$

'Dim counter
' For pressure step list use
Dim pressure_steps As pressureList
' 6.71.67
Dim valve_limit_offset As Integer  ' offset to climit and olimit to compensate for old valves with lots of slack
' 6.71.92
Dim microflow_extraChamber As Boolean

Dim spanAdjustCount As Integer

'6.71.123.07 Dim ts$(497)                         ' Text strings for this module
'6.74.95 Dim ts$(525)                         ' Text strings for this module '6.71.123.07
 Dim ts$(528)                         ' Text strings for this module '6.74.96

' END VARIABLE DECLARATIONS
Sub fill_cel(T As Single, n As Integer, b As Byte)
    cel1(cel_i) = T
    cel2(cel_i) = n
    cel3(cel_i) = b
    cel_i = cel_i + 1
    If cel_i > 100 Then cel_i = 1
End Sub

Public Sub geoPoreValveCal()
Dim lastGeoValvePosition&, geoValvePosition&, geoOpenLimit&
Load Status
Status.Show
Status.Label1.Caption = "Calibrating Geopore Valve"

'open valve for 5 seconds.
Status.Label2.Caption = "opening valve"
Call Send_RS232("OB")
Status.Label2.Caption = "waiting 5 seconds"
Call Waitms(5000, False)
'stop valve
Status.Label2.Caption = "stopping valve"
Call Send_RS232("SB")
'save current valve position

lastGeoValvePosition& = getMV2Position()
lastGeoValvePosition& = x4
Status.Label2.Caption = "recording valve position: " + str$(lastGeoValvePosition&)
'start shutting valve
Status.Label2.Caption = "closing valve..."
Call Send_RS232("CB")
'loop
Do: DoEvents
    'wait .5 seconds
    Status.Label2.Caption = "waiting .5 seconds for counts to change"
    Call Waitms(500, False)
    'get valve position
    geoValvePosition& = getMV2Position()
    geoValvePosition& = x4
    Status.Label2.Caption = "recording valve position: " + str$(geoValvePosition&)
    'if position has not changed for .5 seconds exit loop
    If geoValvePosition& = lastGeoValvePosition& Then
        Status.Label2.Caption = "valve didn't move any more, last position: " + str$(lastGeoValvePosition&)
        Status.Label2.Caption = "current valve position: " + str(geoValvePosition&)
        Exit Do
    End If
    'if it has changed, save last position and continue loop
    
    lastGeoValvePosition& = geoValvePosition&
    Status.Label2.Caption = "valve is moving still, last position: " + str$(lastGeoValvePosition&)
Loop
'stop the valve
Status.Label2.Caption = "stopping valve"
Call Send_RS232("SB")
Status.Label2.Caption = "waiting 1 second"
Waitms 1000, False
'pulse closed
Status.Label2.Caption = "pulsing closed"
Call Send_RS232("DB")
'wait a second
Status.Label2.Caption = "waiting 2 seconds"
Call Waitms(2000, False)
'pulse closed
Status.Label2.Caption = "pulsing closed"
Call Send_RS232("DB")

'at this point valve should be closed.
'read position one more time, this will be our close limit
geoValvePosition& = getMV2Position()
geoValvePosition& = x4
'read open limit
geoOpenLimit& = RSEcho("RR", 3)
'record values to capwin.ini file
WPPS "Capstuff", "OLIMIT", str$(geoOpenLimit&), CSFile$
oLimit = geoOpenLimit&
WPPS "Capstuff", "CLIMIT", str$(geoValvePosition&), CSFile$
cLimit = geoValvePosition&


Waitms 2000, False
Status.Label2.Caption = "Calibration Complete"
Unload Status
'Timer1.Enabled = True
End Sub

Public Function IS_ACPP() As Boolean
Dim xy$

xy$ = gpps2("Capstuff", "is_acpp", App.path & "/capwin.ini", "N")

If xy$ = "Y" Then
    IS_ACPP = True
Else
    IS_ACPP = False
End If
End Function

Public Function IS_MMN() As Boolean
Dim xy$

xy$ = gpps2("Capstuff", "is_mmn", App.path & "/capwin.ini", "N")

If xy$ = "Y" Then
    IS_MMN = True
Else
    IS_MMN = False
End If
End Function
Public Sub Move_GeoValves(direction$)
If Not geoPoreValve Then Exit Sub


Dim geoi%
For geoi% = 0 To UBound(GeoExtraValve)
    Move_Valve GeoExtraValve(geoi%), direction$
Next geoi%

End Sub

Public Sub PurgeRoutine()
Waitms 21, True

End Sub

'Purpose: it fills and rotates the cartride tester chamber.
'Input: chamber number, which starts from 1
Sub rotateAndFillCartridgeTesterChamber(Index As Integer)
    If (rotating_chamber_enable) Then
        turn_pump_on Index
    End If
    
    Dim indexOfFillValve As Integer
    
    If (Index = 1) Then
        indexOfFillValve = Fill_ValveA
    ElseIf (Index = 2) Then
        indexOfFillValve = Fill_ValveB
    Else
        'in case if you have more chambers
    End If
    
    If (m_bDeviceIsReadyForDrainAndFill) Then     ' device is not ready, lets fill it in the manual mode
        Move_Valve indexOfFillValve, "O" ' open the fill valve
        If (PumpValveNumber > 0) Then
            Move_Valve PumpValveNumber - 1, "O" ' turn on the pump
        End If
    
        Dim chamberLevel As Single
        If auto_soak_enable And Not hasMultipleMVs Then
            DoEvents
            Do
                chamberLevel = readChamberLiquidLevel(Index)
            Loop While chamberLevel < ChamberLiquidLevelMax(Index)
            Move_Valve indexOfFillValve, "C"
        End If
        Move_Valve PumpValveNumber - 1, "C"
    
    End If
    
End Sub

Public Sub Run_AirResistivityTest()

End Sub

'Purpose: it stops the rotation of the cartridge and drains the chamber
'Input: chamber number
Sub stopAndDrainCartridgeTesterChamber(Index As Integer)
    If (rotating_chamber_enable) Then
        turn_pump_off Index
    End If
    
    Dim indexOfDrainValve As Integer
    
    If (Index = 1) Then
        indexOfDrainValve = Drain_ValveA
    ElseIf (Index = 2) Then
        indexOfDrainValve = Drain_ValveB
    Else
        'in case if you have more chambers
    End If
    
   ' If (m_bDeviceIsReadyForDrainAndFill) Then     ' device is not ready, lets fill it in the manual mode

        Move_Valve indexOfDrainValve, "O" ' open the drain valve
        Dim chamberLevel As Single
        If auto_soak_enable And Not hasMultipleMVs Then
            DoEvents
            Do
                chamberLevel = readChamberLiquidLevel(Index)
            Loop While chamberLevel > ChamberLiquidLevelMin(Index)
            Move_Valve indexOfDrainValve, "C"
        End If
  '  End If
End Sub

Sub bubble_purge(autofill As Integer)
    Dim remember_it$, T As Single, s As Single

    Rem make sure that they really want to do this
    If MsgBox(ts$(1), vbYesNo + vbQuestion) = vbYes Then        ' "Is the fill valve open, the reservoir full, but the float not going up?"
        MsgBox ts$(2)               ' "Purge is only to be used when trapped air in the line stops the normal flow into the penetrometer"
        Exit Sub
    End If
    If Not autofill And MsgBox(ts$(3), vbOKCancel, ts$(4)) = vbCancel Then Exit Sub      ' "Leave fill valve open during the purge"/"Ready to purge"
    
    Msgform.ok.Caption = ts$(5)          ' "Abort"
    Msgform.ok.Visible = True
    Msgform.ok.SetFocus

    Rem open v1, set v4 to penetrometer, v9 to pressurize
    Move_Valve 0, "O"
    Dry_Chamber_Control "C"
    Move_Valve 8, "O"
    remember_it$ = Msgform.Label1.Caption
    ' 19000 counts in ver. 6 is 92.5% of full scale
    Msgform.Label1.Caption = ts$(6)     ' "Purging to 92.5% - Please Wait"
    T = Timer

    If low_flow_controller Then set_low_flow_rate 10 ' set target low flow rate at 10 cc/min

    While Msgform.ok.Visible = True
        Rem check low flow - make sure over 5 cc/min
        ReadXReturnX4 0
        ' 0.1 seconds added to midnight check to fix roundoff error that happens in some machines
        If T > Timer + 0.1 Then T = T - 86400
        If x5 < 10 And (Timer - T > 1) Then
            inc_reg 10 ' the 10 is ignored for all but I/P converters
            T = Timer
        End If
        Rem check penetrometer - stop when goes down to 92.5%
        ReadXReturnX4 4
        s = 100# * (x4 - DAC_zero) / DAC_span
        Msgform.Label.Caption = Format$(x5, "#0.00 \c\m   ") + Format$(s, "##0.## \%")  ' "\c\m"
        Msgform.Refresh
        DoEvents
        If x4 > 19000 Then Msgform.ok.Visible = False
    Wend
    
    Msgform.ok.Caption = ts$(7)     ' "Purge"
    Dry_Chamber_Control "O"
    Move_Valve 0, "C"
    Zero_Reg
    ' we don't close the fill valve because we are going to re-open it again
    ' when we exit this routine
    If Not autofill Then MsgBox ts$(8)      ' "Close the fill valve BEFORE clicking OK"
    If slurry_tube_exists Then Move_Valve Slurry_tube_vent_valve, "C" 'slurry tube vent valve V29 6.71.123.19
    Move_Valve 8, "C"
    Dry_Chamber_Control "C"
    If Not autofill Then MsgBox ts$(9)      ' "You can now resume filling the penetrometer"
    Msgform.Label1.Caption = remember_it$
End Sub

Public Sub Sync_Gauges()
Dim p1!, p2!
Dim tempPY1_0 As Single
Dim tempPY1_1 As Single
Dim tempPY2_0 As Single
Dim pDiff As Single

'//select first gauge and read it
Pres% = 0
ReadXReturnX4 2 '
p1 = x5
'//select second gauge and read it
Pres% = 2
ReadXReturnX4 2
p2 = x5
'//load already existing values
tempPY1_0 = PY1(0)
tempPY1_1 = PY1(1)
tempPY2_0 = PY2(0)
'//get difference between two gauge readings
pDiff = p1 - p2
'//subtract from these values the difference
If pDiff < 2 Then
    PY1(0) = tempPY1_0 - pDiff
    PY1(1) = tempPY1_1 - pDiff
    PY2(0) = tempPY2_0 - pDiff
    '//save it to the ini file
    WPPS "Capstuff", "PY1_0", str$(PY1(0)), CSFile$
    WPPS "Capstuff", "PY1_1", str$(PY1(1)), CSFile$
    WPPS "Capstuff", "PY2_0", str$(PY2(0)), CSFile$
End If
Pres% = 0

End Sub

Sub waitseconds(ByVal s As Single)
Rem waits s seconds, calling doevents
Dim L As Long
    L = CLng(s * 1000)
    If L <= 0 Then Exit Sub
    Waitms L, False
'    Dim T As Single
'    Dim lt As Single
'
'    T = Timer
'    Do
'        DoEvents
'        lt = Timer
'        ' 0.1 seconds added to midnight check to fix roundoff error that happens in some machines
'        If lt + 0.1 < T Then T = T - 86400
'    Loop Until (lt - T) >= s

End Sub

Sub waitSeconds2(ByVal s As Single)
    Dim T As Single
    Dim lt As Single
    
    T = Timer
    
End Sub

' This runs the lohm calibration for each flowmeter in the machine, creating a different lohm table for
' each meter.  The files are named as FM_#_lohmtable.cal where # is 1 (lowest range) through the highest range
' flow meter in the machine.

Sub Run_Lohm_Table_Calibration()
    Dim fn1 As Integer
    Dim fn2 As Integer
    Dim lohmCount As Integer
    Dim lohmEntries(4) As Integer
    Dim cvFlow As Single
    Dim cvValue1 As Single
    Dim cvValue2 As Single
    Dim default_lohm_filename As String
    Dim users_lohm_filename As String
    Dim j, i As Integer
    Dim lohmMaxAirflow As Single
    Dim Ret$
    
    lohmCount = 0
    lohmMaxAirflow = 0
    On Error GoTo SAFEDONE
    'Now run lohm calibration separately for each flowmeter
    runningLohmCalibration = True
    
    'Should open temp file to be used for all lohm calibrations
    'Might need to print 0,0 after each one
    fn1 = FreeFile
    Open EXE_Path$ + "capwin.tmp" For Output As #fn1  ' File for Cv calibration
    
    If hasMultipleMVs Then
        ' High flow meter 4 (currently only used on the Corning machine)
        If FY2(2, 2) <> 0 Then
            lohmCount = lohmCount + 1
            HFLOW% = 2
            motorValveIndex = 1
            Msgform.Caption = "Lohm Calibration for High Flow Meter 4"
            Msgform.Refresh
            lohmEntries(lohmCount) = Run_Lohm_Table_Calibration_For_FlowMeter(fn1, 4, FY2(2, 2) * gasflowconversionfactor * 0.0015, FY2(2, 2) * gasflowconversionfactor, lohmMaxAirflow)
        End If
        
        If Aborted Then Exit Sub
        
        ' High flow meter 3 (currently only used on the Corning machine)
        If FY2(2, 0) <> 0 Then
            lohmCount = lohmCount + 1
            HFLOW% = 0
            motorValveIndex = 1
            Msgform.Caption = "Lohm Calibration for High Flow Meter 3"
            Msgform.Refresh
            lohmEntries(lohmCount) = Run_Lohm_Table_Calibration_For_FlowMeter(fn1, 3, FY2(2, 0) * gasflowconversionfactor * 0.0015, FY2(2, 0) * gasflowconversionfactor, lohmMaxAirflow)
        End If
    End If
    
    If Aborted Then Exit Sub
    
    ' High flow meter 2 (extra high flow meter)
    If xhflow Or hasMultipleMVs Then
        If xhflow_meters = 2 Then
            If FY2(1, 4) <> 0 Then
                lohmCount = lohmCount + 1
                HFLOW% = 4
                motorValveIndex = 0
                Msgform.Caption = "Lohm Calibration for High Flow Meter 3"
                Msgform.Refresh
                lohmEntries(lohmCount) = Run_Lohm_Table_Calibration_For_FlowMeter(fn1, 3, FY2(1, 4) * gasflowconversionfactor * 0.0015, FY2(1, 4) * gasflowconversionfactor, lohmMaxAirflow)
            End If
        End If
        
        If Aborted Then Exit Sub
        
        If FY2(1, 2) <> 0 Then
            lohmCount = lohmCount + 1
            HFLOW% = 2
            motorValveIndex = 0
            Msgform.Caption = "Lohm Calibration for High Flow Meter 2"
            Msgform.Refresh
            lohmEntries(lohmCount) = Run_Lohm_Table_Calibration_For_FlowMeter(fn1, 2, FY2(1, 2) * gasflowconversionfactor * 0.0015, FY2(1, 2) * gasflowconversionfactor, lohmMaxAirflow)
        End If
    End If
        
    If Aborted Then Exit Sub
    
    ' High flow meter 1
    If FY2(1, 0) <> 0 Then
        lohmCount = lohmCount + 1
        HFLOW% = 0
        motorValveIndex = 0
        Msgform.Caption = "Lohm Calibration for High Flow Meter 1"
        Msgform.Refresh
        lohmEntries(lohmCount) = Run_Lohm_Table_Calibration_For_FlowMeter(fn1, 1, FY2(1, 0) * gasflowconversionfactor * 0.0015, FY2(1, 0) * gasflowconversionfactor, lohmMaxAirflow)
    End If
    
    Close #fn1
    
    runningLohmCalibration = False
    
    fn1 = FreeFile
    Open EXE_Path$ + "capwin.tmp" For Input As #fn1  ' File for Cv calibration
    
    fn2 = FreeFile
    
    If current_unit% = 1 Then
        default_lohm_filename = EXE_Path$ + "lohmtable.cal"
        Open default_lohm_filename For Output As #fn2
    Else
        default_lohm_filename = EXE_Path$ + "lohmtable" + Trim$(str$(current_unit%)) + ".cal"
        Open default_lohm_filename For Output As #fn2
    End If
    
    For j = 1 To lohmCount
        Print #fn2, lohmEntries(j)
        For i = 1 To Abs(lohmEntries(j))
            DoEvents
            
            Input #fn1, cvFlow, cvValue1
            
            If ExtraPG Then
                Input #fn1, cvValue2
                Print #fn2, str$(cvFlow); ","; str$(cvValue1); ","; str$(cvValue2)
            Else
                Print #fn2, str$(cvFlow); ","; str$(cvValue1)
            End If
            
        Next i
    Next j
SAFEDONE:
    Close #fn1
    Close #fn2
    
    'If the user entered a valid filename to save the lohm tables, copy the default table
    users_lohm_filename = gpps2(Curr_U$, "lohmpath", IFile$, "")
    If users_lohm_filename <> "" Then
        On Error Resume Next
        If current_unit% = 1 Then
            FileCopy default_lohm_filename, users_lohm_filename
        Else
            If InStr(users_lohm_filename, ".cal") > 0 Then
                users_lohm_filename = Left(users_lohm_filename, Len(users_lohm_filename) - 4) + Trim$(str$(current_unit%)) + ".cal"
            Else
                users_lohm_filename = users_lohm_filename + Trim$(str$(current_unit%)) + ".cal"
            End If
            FileCopy default_lohm_filename, users_lohm_filename
        End If
        On Error GoTo 0
    End If
    
    Kill EXE_Path$ + "capwin.tmp"
        
    MaxAirFlow = lohmMaxAirflow
    
    Ret$ = str$(MaxAirFlow)
    WPPS "Capstuff", "MAXAIRFLOW", Ret$, CSFile$

    process_CVtable
End Sub


Function Run_Lohm_Table_Calibration_For_FlowMeter(ByRef fn1 As Integer, ByVal flowMeterIndex As Integer, _
        ByVal min_flow_rate As Single, ByVal top_flow_rate As Single, ByRef lohmMaxAirflow As Single) As Integer

' this used to be called "Calc_CV", which was confusing

    Dim CV_init_preg_incs As Long
    Dim OldMaxAirFlow As Single
    Dim T As Single
    Dim i As Long
    Dim previous_flow As Single
    Dim tempvolflow As Single
    Dim pre_temp_Cv_Value As Single
    Dim pre_temp_Cv_Value2 As Single
    Dim CV_Value As Single
    Dim CV_Value2 As Single
    Dim last_good_flow As Single
    Dim last_good_pres As Single
    Dim temp$, temp1$, Ret$
    Dim n%
    Dim CURPRES As Single
    Dim CURPRES2 As Single
    Dim curFlow As Single
    Dim curflowcount As Long
    Dim FLOWMSG%
    Dim initpres As Single
    Dim MAXCVPRES As Single
    'Dim fn1 As Integer, fn2 As Integer, fn3 As Integer, fn4 As Integer
    Dim fn2 As Integer
    Dim doing_hflow1 As Boolean
    Dim Last_Flow(10) As Single
    Dim current_max_pres As Single
    Dim current_max_flow As Single
    Dim current_min_flow As Single
    Dim current_min_pres As Single
    Dim x_temp As Long
    Dim pressure_in_order As Boolean
    Rem put in by jsd for cv work
    'Dim points As Single
    Dim v2setting As Single
    Dim tempval As Single
    'Dim v2now_open As Boolean rem now has to be global
    Dim v2_open As Boolean
    Dim valve2_position As Single
    Dim no_flow As Boolean
    Dim pulsed As Integer
    Dim Going_nowhere As Integer
    Dim no_pressure As Boolean
    Dim bad_bernouli As Integer
    Dim bernouli_problems  As Boolean
    Dim reset_counter As Integer
    Dim num_reads As Single
    Dim reads_per_second As Single
    Dim high_pres%          ' keep track of which range of high pressure gauge we are using
    Dim low_pres%           ' keep track of which range of the low pressure gauge we are using
    Dim temp_regpos As Long
    Dim abort_confirmed As Boolean  ' Avoid multiple user requests for confirmation
    Rem added by jeff for testing of cv versus v2pos
    Dim lohmTimeout As Integer  ' Number of cycles before timing out if flow cannot be increased
                                ' (used with "going_nowhere", formerly hardcoded as 50)
    Dim lohm_allowable_flow_increase As Single
    Dim lohm_regulator_increase_factor As Single
    Dim lohm_tolerance As Single
    
    Dim tmp_CLimit As Long
    Dim tmp_OLimit As Long
    
    If status_lights_enable Then setStatusLights 2

'JF Lohm Calibration
    On Error Resume Next
    
    Select Case motorValveIndex
    Case 0: tmp_CLimit = cLimit
            tmp_OLimit = oLimit
    Case 1:
    Case 2:
    End Select
    
    If Len(Dir$(EXE_Path$ + "cvlog.txt")) <> 0 Then     ' if no log file, don't do anything
        If Len(Dir$(EXE_Path$ + "cvlog.bak")) <> 0 Then
            Kill EXE_Path$ + "cvlog.bak"
            Name EXE_Path$ + "cvlog.txt" As EXE_Path$ + "cvlog.bak"
        ElseIf Len(Dir$(EXE_Path$ + "cvlog.bak")) = 0 Then     ' if there is no bak file, but there is a log, rename log as bak
            Name EXE_Path$ + "cvlog.txt" As EXE_Path$ + "cvlog.bak"
        End If
    End If

    Kill EXE_Path$ + "bernouli.txt"
    
    If xhflow And Not MedFM_CV_Disable Then
        doing_hflow1 = True
    Else
        doing_hflow1 = False
    End If
        
    ' Load up the timeout value
    lohmTimeout = myVal(gpps2(Curr_U$, "lohm_timeout", IFile$, "50"))
    lohm_allowable_flow_increase = myVal(gpps2(Curr_U$, "lohm_allowable_flow_increase", IFile$, "1000"))
    lohm_regulator_increase_factor = myVal(gpps2(Curr_U$, "lohm_regulator_increase_factor", IFile$, "1"))
    lohm_tolerance = myVal(gpps2(Curr_U$, "lohm_tolerance", IFile$, "50"))
    
    On Error GoTo 0

    cvpoints = 0
    v2_open = False
    v2now_open = False
    RUNNING = True
    pulsed = 0
    no_pressure = False
    pressure_in_order = False
    bad_bernouli = 0
    bernouli_problems = False
    Aborted = False
    If v2solenoid Then cv_withmulti_v2 = False

    
'    If top_flow_rate < 50000 Or newreg Then
'        CV_init_preg_incs = SHFP
'    Else
        CV_init_preg_incs = 1
'    End If
    
    If H2OPERM Then Dry_Chamber_Control "O"
    
    OldMaxAirFlow = 0
    
    ' new small hflow test part
    Do
        If Aborted Then Exit Do
        Msgform.Label1.AutoSize = True
        Msgform.Label1.Caption = ts$(10)        ' "Zeroing Regulator to start Lohm calibration"
        Msgform.Label1.Visible = True
        Msgform.Refresh
        DoEvents
        Zero_Reg
        Exit Do
    Loop
    
    abort_confirmed = False
    
    Rem added by jsd to make sure v2 closed
    Rem get position of valve
    If cv_withmulti_v2 Then
        x4 = tempval
        ReadXReturnX4 3
        ' 200 counts is 1% of span
        If x4 >= (cLimit + DAC_span / 100) Then v2_open = True
        x4 = tempval
    End If
    
    If cv_withmulti_v2 And v2_open Or hasMultipleMVs And Not Aborted Then
        Rem close valve 2 all the way
        Msgform.Label1.AutoSize = True
        Msgform.Label1.Caption = ts$(11)        ' "Closing valve 2"
        Msgform.Refresh
        Send_RS232 ("C" + mv1_index_char)
        While RSEcho("V" + mv1_index_char, 1) <> Asc("S")
            DoEvents
        Wend
        If hasMultipleMVs Then 'AJB 12-20-09
            Send_RS232 ("C" + mv2_index_char)
            While RSEcho("V" + mv2_index_char, 1) <> Asc("S")
                'tryhold 'Added by JF 8-31-10
            Wend
            
            If numberOfMotorValves > 2 Then
                Send_RS232 ("C" & mv3_index_char)
                While RSEcho("V" + mv3_index_char, 1) <> Asc("S")
                    'tryhold 'Added by JF 8-31-10
                Wend
            End If
        End If
    End If
    
    Rem now make sure no pressure in system by opening drain
    Do
        If Aborted Then Exit Do
        Msgform.Label1.AutoSize = True
        Msgform.Label1.Caption = ts$(12)        ' "Venting System for Stable Atmospheric Pressure"
        Msgform.Refresh
        Move_Valve 2, "O"   ' open drain
        Msgform.Label1.AutoSize = True
        Msgform.Label1.Caption = ts$(13)        ' "Waiting 5 Seconds for Stability"
        Msgform.Refresh
        waitseconds (5)
        Move_Valve 2, "C"   ' close drain
        Exit Do
    Loop
    
    Pres% = 1       ' rem low range high pressure gauge
    'End If
    
    stagnation_check 0, 0 ' initialize the stagnation check routine
    
    T = Timer
    i = 0
    
    ' Get initial pressure
    Do
        i = i + 1                   ' increment # of readings
        
        ReadXReturnX4 2             ' read pressure
            
        CURPRES = CURPRES + x5      ' running sum
        Msgform.Label1.Caption = ts$(16) + "=" + Format$(x5)    ' "Initial Pressure"
        Msgform.Refresh
        'DoEvents
    Loop While i < 50 And Not Aborted
    
    initpres = CURPRES / i          ' average pressure readings
    'If initpres < 0 Then initpres = 0
    real_atm = initpres
    atm_x4(1) = x4
    Pres% = 0
    
    ReadXReturnX4 2
            
    atm_x4(0) = x4
    Pres% = 1 ' set to low range
    Rem use this p0 value to zero the extra pressure gauge

    If ExtraPG And Not Aborted Then
        If PY1(2) > 0 Then
            Rem since py1(2)>0 then this must be a differential gauge,
            Rem so read the current reading, which should be at atmospheric
            Rem pressure and therefore around 500 counts, and use the pressure
            Rem reading of the main pressure gauge to set the current atmospheric
            Rem pressure value
            tempval = 0
            T = Timer
            i = 0
            Pres% = 2
        
            Do
                i = i + 1
                
                ReadXReturnX4 2
                
                tempval = tempval + x4
                Msgform.Label1.AutoSize = True
                Msgform.Label1.Caption = ts$(17) + " = " + Format$((x5), "00.000#")     ' "Initial Pressure (Low PG HR)"
                Msgform.Refresh
                'DoEvents
            Loop While i < 50 And (T <= Timer)
        
            x4 = tempval / i
            'Pres% = 2
            'ReadXReturnX4 2
        
            If x4 < 3 Then MsgBox ts$(18) + vbCrLf + ts$(19)  ' "Warning: The Low Pressure (High Range)"/"is not calibrated correctly"
            PX1(2) = x4     ' Count value HR LPG
            PX2(2) = x4 + DAC_span
            PY2(2) = PY2(2) - PY1(2) + initpres
            PY1(2) = initpres   ' PY1(2) is low range low PG
            atm_x4(2) = x4
            'MsgBox "Initial atm(2)=" + Str$(X4)
            i = 0
            T = Timer
            tempval = 0
            Pres% = 3
        
            Do
                i = i + 1
                ReadXReturnX4 2
                
                tempval = tempval + x4
                Msgform.Label1.AutoSize = True
                Msgform.Label1.Caption = ts$(20) + " = " + Format$((x5), "00.000#")     ' "Initial Pressure (Low PG LR)"
                Msgform.Refresh
                'DoEvents
            Loop While i < 50 And (T <= Timer)
        
            x4 = tempval / i
            Rem below replaced by above averaging loop
            'Pres% = 3
            'ReadXReturnX4 2
            If x4 < 3 Then MsgBox ts$(21) + vbCrLf + ts$(19) ' "Warning: The Low Pressure (Low Range)"/"is not calibrated correctly"
            PX1(3) = x4  ' LR LPG
            PX2(3) = x4 + DAC_span
            PY2(3) = PY2(3) - PY1(3) + initpres
            PY1(3) = initpres
            atm_x4(3) = x4
            'MsgBox "Initial atm(3)=" + Str$(X4)
            Rem leave Pres% at the lowest range of the extra pressure gauge
        
        Else
            Rem the second pressure gauge is an absolute pressure gauge, and
            Rem it must be more accurate than the main pressure gauge, so read
            Rem the second pressure gauge and use it's value to re-calibrate
            Rem the main pressure gauge.
            Rem jsd thinks this is a mistake - uses high range ????
            Pres% = 2
            'Pres% = 1
            ReadXReturnX4 2
            
            initpres = x5 ' actual atmospheric pressure
            'If initpres < 0 Then initpres = 0
            'P02 = P0 * P0
            'real_atm = P0
            'MsgBox "Atmospheric pressure reset to " + Str$(real_atm)
            'atm_x4(2) = X4
            'MsgBox "Initial atm(2)=" + Str$(X4)
            
            If PY1(0) = 0 Then
                x_temp = atm_x4(0) - (P0 / PY2(0) * (PX2(0) - PX1(0)) + PX1(0))
                PX1(0) = PX1(0) + x_temp
                PX2(0) = PX2(0) + x_temp
            End If
        
            If PY1(1) = 0 Then
                x_temp = atm_x4(1) - (P0 / PY2(1) * (PX2(1) - PX1(1)) + PX1(1))
                PX1(1) = PX1(1) + x_temp
                PX2(1) = PX2(1) + x_temp
            End If
        
            atm_x4(3) = 0  ' mark this range as being unusable
            Rem leave Pres% at the highest range of the extra pressure gauge
            Rem since the lowest range of an absolute gauge will always be off
            Rem scale
            Pres% = 2
        End If
        If ExtraPG Then Move_Valve 10, "O"
    End If              ' (ExtraPG And Not Aborted)

    If doing_hflow1 And Not Aborted And Not v2solenoid Then
        ' set to hflow 1, high range
        HFLOW% = 0
        DoEvents
        ReadXReturnX4 1                         ' read hflow1 just to make sure it is selected
        Msgform.Label1.Caption = ts$(22)        ' "Opening valve 2 to initiate regulator"
        Msgform.Refresh
        openv2completely
        Msgform.Label1.Caption = ts$(23)        ' "Incrementing Regulator to achieve full flow on hflow1"
        Msgform.Refresh
        
        Do
            inc_reg 10
            waitseconds 2
            ReadXReturnX4 1
            Msgform.Label1.Caption = ts$(24) + "=" + Format$(x5)    ' "Incrementing Regulator: Flow"
            Msgform.Refresh
        Loop Until x5 > FY2(1, 0) * gasflowconversionfactor
        
        Rem leave regulator set here since we now know that
        Rem this regulator position is enough to take
        Rem high flow meter 1 to full scale just by
        Rem opening valve 2
        Rem close valve 2 all the way
        Msgform.Label1.Caption = ts$(11)            ' "Closing valve 2"
        Msgform.Refresh
        Send_RS232 ("C" + mv1_index_char)
        While RSEcho("V" + mv1_index_char, 1) <> Asc("S")
        Wend
    End If          ' (doing_hflow1 And Not Aborted And Not v2solenoid)
        
    n% = 0
    
    If doing_hflow1 And Not Aborted Then
        Msgform.Label1.AutoSize = True
        Msgform.Label1.Caption = ts$(25)        ' "Opening Valve 2 to first flow position"
        Msgform.Refresh
        V2POS = SV2P ' initial position
        OpenV2Pos
    Else
'        If xhflow And cv_withmulti_v2 Then
'            HFLOW% = 3 ' low range highest FM
'            Move_Valve 9, "O"
'        ElseIf xhflow Then
'            HFLOW% = 2 ' high range highest FM
'        ElseIf Not xhflow And cv_withmulti_v2 Then
'            HFLOW% = 1 ' low range higest FM
'        Else
'            HFLOW% = 0 ' this is the high range of the highest FM (only 1)
'        End If

        DoEvents
 
        If cv_withmulti_v2 = True And Not Aborted Then
            Rem start special File
            Rem diagnostic feature added by jsd to help construct lookup table for CV
            fn2 = FreeFile
            Open EXE_Path$ + "cvlog.txt" For Append As #fn2
            Print #fn2, "dP"; ","; "Lohm"; ","; "V2 Pos"; ","; "Flow SLPM"
            Print #fn2, initpres
            Close #fn2
            Msgform.Label1.AutoSize = True
            Msgform.Label1.Caption = ts$(26)        ' "Special Valve 2 Lohm Calibration"
            Msgform.Refresh
            'OPENV2MOSTLY
            Msgform.Label1.AutoSize = True
            Msgform.Label1.Caption = ts$(25)        ' "Opening Valve 2 to first flow position"
            Msgform.Refresh
            V2POS = SV2P '   + 50# ' initial position ' changed Jan 22 - to get more points at low flow
            V2POS = DAC_span
            If lohmStartMultiplier > 0 And lohmStartMultiplier <= 1 Then  ' Added to start lohm calculation at user-selectable percentage.
                V2POS = V2POS * lohmStartMultiplier
            End If
            OpenV2Pos
            v2setting = 1

            For i = 1 To Cv_reg_inc \ 2
                inc_reg 10
            Next i

        ElseIf Not Aborted Then
            Msgform.Label1.AutoSize = True
            Msgform.Label1.Caption = ts$(27)        ' "Opening Valve 2 all the way"
            Msgform.Refresh
            openv2completely
        End If
        
        Msgform.Label1.AutoSize = True
        Msgform.Label1.Caption = ts$(28)        ' "Incrementing Regulator to initial position"
        Msgform.Refresh
        
        If newreg Then
            reg_goto (CV_init_preg_incs)
        ElseIf ip_reg_enable Then
            ' since the ip regulator may have a large zero offset, we need to
            ' start it close to the point where it will have some pressure increase
            If reg_table_size%(regnum) > 1 Then
                If regnum = 0 Then
                    If reg_table_pos(1) > 0 And REGPOS < reg_table_pos(1) - 50 Then
                        ' since the first entry in the regulator table is not 0, this
                        ' means that at 0 counts the regulator isn't giving any real
                        ' pressure.  Since the regulator table goes up in 100 count
                        ' increments, we will set the regulator to 50 less than the first
                        ' entry
                        inc_reg reg_table_pos(1) - 50 - REGPOS
                    End If
                Else
                    If reg_table_pos2(1) > 0 And REGPOS < reg_table_pos2(1) - 50 Then
                        inc_reg reg_table_pos2(1) - 50 - REGPOS
                    End If
                End If
            End If
        End If
    End If              ' (doing_hflow1 And Not Aborted)
    
    'increase regulator to nearly 2x atm. pressure or max flow
    'stop incrementing if:  a:  2.5x atm is reached
    '                       b:  top of pressure gauge reached
    '                       c:  max flow reached
    '                       d:  flow does not change after 3 reg clicks
    
    curFlow = 0
    CURPRES = initpres
    MAXCVPRES = 3 * initpres ' rem changed jsd Feb 21 2001 for case of Evonyx machine with very low lohms
    
    Open "initial_pressure.txt" For Output As #10
    Print #10, initpres
    Close #10
    
    DoEvents
    
    If MAXCVPRES >= PY2(0) Then MAXCVPRES = PY2(0)
    
    For i = 0 To 9: Last_Flow(i) = -9999: Next i
    
    curFlow = 0
    curflowcount = 0
    previous_flow = 0
'    fn1 = FreeFile
'    Open EXE_Path$ + "capwin.tmp" For Output As #fn1  ' File for Cv calibration
    
    Pres% = shortHandIfelse(ExtraPG, 3, 1)
    low_pres% = Pres%
    high_pres% = 1
    
'    If xhflow And cv_withmulti_v2 Then ' exp jsd
'        HFLOW% = 3 'i.e low range to start Running will allow for crossover this is LR, HFM2
'    ElseIf xhflow Then
'        HFLOW% = 2
'    ElseIf Not xhflow And cv_withmulti_v2 Then
'        HFLOW% = 1
'    Else
'        HFLOW% = 0
'    End If
        
    Do      ' Beginning of main "do" loop
        tempval = x4
        ReadXReturnX4 3
        Rem gives v2 pos as a percentage
        valve2_position = ((x4 - cLimit) / (oLimit - cLimit)) * 100
        x4 = tempval
    
        If doing_hflow1 Then
            'increment valve 2
            Send_RS232 ("I" + mv1_index_char)
            Send_RS232 ("I" + mv1_index_char)
            Send_RS232 ("I" + mv1_index_char)
            Send_RS232 ("I" + mv1_index_char)
            Send_RS232 ("I" + mv1_index_char)
            Send_RS232 ("I" + mv1_index_char)
            Send_RS232 ("I" + mv1_index_char)
            Send_RS232 ("I" + mv1_index_char)
        ElseIf top_flow_rate < 50000 Then
            'inc_reg (Cv_reg_inc)
            'inc_reg (10 * lohm_regulator_increase_factor)
            inc_reg (7 * lohm_regulator_increase_factor)
        ElseIf reg5 Then
            inc_reg (10 * lohm_regulator_increase_factor) 'AJB 10-06-09 Added brackets to make this work as intended.
            inc_reg (10 * lohm_regulator_increase_factor)
            inc_reg (10 * lohm_regulator_increase_factor)
            inc_reg 10 * (lohm_regulator_increase_factor)
        ElseIf newreg Then
            inc_reg (10 * lohm_regulator_increase_factor)
            inc_reg (10 * lohm_regulator_increase_factor)
        ElseIf MedFM_CV_Disable And Not cv_withmulti_v2 Then
            Rem then want to be able to go slow to emulate cv versus v2 pos
            Rem i.e. only one increment
            inc_reg (10 * lohm_regulator_increase_factor) 'AJB 10-06-09 Added brackets to make this work as intended.
        ElseIf cv_withmulti_v2 And cvpoints < 2 And v2setting <= 1 And valve2_position < 50 And Not no_flow And Not no_pressure Then
            Rem at low v2 settings, inc less so take half of the desired number
            For i = 1 To Cv_reg_inc \ 2
                inc_reg (10 * lohm_regulator_increase_factor) 'AJB 10-06-09 Added brackets to make this work as intended.
            Next i
        ElseIf cv_withmulti_v2 And cvpoints < 2 And v2setting <= 1 And Not v2now_open And valve2_position > 50 And Not no_flow Then
            For i = 1 To Cv_reg_inc 'first pass
                inc_reg (10 * lohm_regulator_increase_factor) 'AJB 10-06-09 Added brackets to make this work as intended.
            Next i
        ElseIf cv_withmulti_v2 And cvpoints >= 2 And Not v2now_open And Not no_flow Then
            Move_v2_for_cvcal
            Rem added jsd Apr 2001 to allow fm and P to stabilize for new equilibrium routines
            waitseconds 4
        ElseIf cv_withmulti_v2 And no_flow Or no_pressure And Not v2now_open Then
            Pulse_V2 (0) 'second pass
            pulsed = pulsed + 1
            no_flow = False
            Rem assume if max pres is less than 150, shop air likely connected so
            Rem we have to increment the reg more than pulse the valve
            Rem basically we now have the problem that we either have too little flow or too little pressure
            Rem different routines should be used for each case - for no pressure, I want to inc the reg more than pluse the valve
            Rem therefore this routine has been changed based upon many measurements

            If no_pressure Then
                If pulsed = 2 And PY2(0) < 150 Then
                    For i = 1 To Cv_reg_inc
                        inc_reg (10 * lohm_regulator_increase_factor) 'AJB 10-06-09 Added brackets to make this work as intended.
                    Next i
                    pulsed = 0
                    'no_flow = False
                    no_pressure = False
                    pressure_in_order = True
                ElseIf pulsed = 2 And PY2(0) > 150 Then
                    For i = 1 To Cv_reg_inc \ 2
                        inc_reg (10 * lohm_regulator_increase_factor) 'AJB 10-06-09 Added brackets to make this work as intended.
                    Next i
                    pulsed = 0
                    'no_flow = False
                    no_pressure = False
                    pressure_in_order = True
                Else
                    no_pressure = False
                    pressure_in_order = True
                End If
            Else
                If pulsed > 2 And PY2(0) < 150 Then
                    For i = 1 To Cv_reg_inc
                        inc_reg (10 * lohm_regulator_increase_factor) 'AJB 10-06-09 Added brackets to make this work as intended.
                    Next i
                    pulsed = 0
                    no_flow = False
                ElseIf pulsed > 2 And PY2(0) > 150 Then
                    For i = 1 To Cv_reg_inc \ 2
                        inc_reg (10 * lohm_regulator_increase_factor) 'AJB 10-06-09 Added brackets to make this work as intended.
                    Next i
                    pulsed = 0
                    no_flow = False
                End If
            End If
            
        ElseIf v2now_open And cv_withmulti_v2 And curFlow > 100# Then
            For i = 1 To 2# * (Cv_reg_inc)
                inc_reg (10 * lohm_regulator_increase_factor) 'AJB 10-06-09 Added brackets to make this work as intended.
            Next i
        Else
            If dualregulator = False Or using_low_regulator Then
                inc_reg (10 * lohm_regulator_increase_factor) 'AJB 10-06-09 Added brackets to make this work as intended.
                inc_reg (10 * lohm_regulator_increase_factor)
                inc_reg (10 * lohm_regulator_increase_factor)
            Else
                ' once we switch to the second regulator, it usually goes up quite fast
                ' so we don't need to go any faster
                inc_reg 4
            End If
            'inc_reg
        End If

        If doing_hflow1 = False Then
            ' hflow1 lohm doesn't use the regulator, so there is no need to check for stagnation
            
            ReadXReturnX4 2
            
            current_max_pres = x5
            ReadXReturnX4 1
            stagnation_check (current_max_pres - real_atm), x5
        End If
        
        'switch to second regulator
        If dualregulator And using_low_regulator And REGPOS >= 4000 Then
            'lower_reg 4000 - second_regulator_starting_point
            'waitseconds 3
            'Move_Valve 16, "O"
            'waitseconds 10
            'regnum = 1
            'fifty_or_seven = 7
            'SBPP = SBPP2
            'SHFP = SHFP2
            'using_low_regulator = False

            SwitchRegulators
        End If

redo_flow_reading:
        Rem added by jeff - was using different ranges !!
        Rem now trying to use 2nd PG
        Rem moved to top of loop
      
        ReadXReturnX4 2
       
        current_max_pres = x5
        current_min_pres = x5
      
        If doing_hflow1 Then HFLOW% = 0
      
        ReadXReturnX4 1
        current_max_flow = x5 + lohm_allowable_flow_increase
        current_min_flow = x5
      
        T = Timer
        i = 0
        Rem once again - add stability times here
        Rem top of loop for stability
        Msgform.ok.Caption = ts$(80) + "(" + Format$(stagnation_check_iterations) + ")"      ' "Force"
        Msgform.ok.Visible = True
        
        Do
            i = i + 1
            Rem use low range of hpg for now
            'Pres% = 1
            Rem leave Pres% alone - since running it will auto-switch
            ReadXReturnX4 2
                        
            CURPRES = x5    ' read in pressure and set variable
            Rem note Pres% is a global variable, and thus we'll know which one was used for the below calculations
            Rem - here we have to ingnore the very low delta p values.  we'll use the 4 decade rule /2
          
            Rem - this might be causing trouble !!!
            Rem at low flow rates, the P0 may actually decrease due to Bernouli effects !!!  We should not be shifting the P0 !!
            Rem this will let us see how big the effects are
          
            Rem this is a major easter egg to look at Bernouli effects
'            If V2Percent = 22 Then
'                If CURPRES <= initpres Then
'                    fn4 = FreeFile
'                    Open EXE_Path$ + "bernouli changes to P0.txt" For Append As #fn4
'                    Print #fn4, (CURPRES); ","; (initpres); ","; (initpres - CURPRES)
'                    Close #fn4
'                    initpres = CURPRES
'                End If
'            End If
'            If CURPRES <= initpres And V2Percent <> 22 Then
'                If bad_bernouli < 100 Then
'                    fn3 = FreeFile
'                    Open EXE_Path$ + "bernouli.txt" For Append As #fn3
'                    Print #fn3, (CURPRES); ","; (initpres); ","; (initpres - CURPRES)
'                    bad_bernouli = bad_bernouli + 1
'                    Close #fn3
'                Else
'                    bernouli_problems = True
'                End If
'            End If
            
            Rem this was added for the case where we are doing the special lohm cal with v2 settings
            Rem the idea is to ingnore pressures lower than the suggested lowest readings of MKS gauges
            Rem MKS suggests that 0.05% of FS is the lowest suggested reading.
            Rem Since we get the high accuracy version, we'll assume 0.0025% of FS is OK
            Rem this has to be updated to use 2nd PG if available
'            If (Timer - T) > 2 And T <= Timer And cv_withmulti_v2 Then
'                Select Case Pres%
'                Case 1 Or 0       ' rem low range high PG
'                    If (CURPRES - initpres) <= ((PY2(0)) * (0.0025 / 100)) Then
'                        no_pressure = True
'                        Going_nowhere = Going_nowhere + 1
'                        pressure_in_order = False
'                        T = Timer
'                        Debug.Print "skip_this_cv_calculation"
'                        GoTo skip_this_cv_calculation
'                    Else
'                        pressure_in_order = True
'                        Debug.Print "pressure_in_order"
'                    End If
'                Case 2 Or 3 ' this is the extra PG
'                    If (CURPRES - initpres) <= ((PY2(2)) * (0.0025 / 100)) Then
'                        no_pressure = True
'                        Going_nowhere = Going_nowhere + 1
'                        pressure_in_order = False
'                        T = Timer
'                        GoTo skip_this_cv_calculation
'                    Else
'                        pressure_in_order = True
'                    End If
'                End Select
'            End If
            
            If current_max_pres < x5 Then
                current_max_pres = x5
                reset_counter = reset_counter + 1
                T = Timer
                i = 0
            End If
          
            If current_min_pres > x5 Then
                current_min_pres = x5
                reset_counter = reset_counter + 1
                T = Timer
                i = 0
            End If
          
            ReadXReturnX4 1
            curflowcount = x4
            
            If curflowcount >= DAC_over Then GoTo skip_this_cv_calculation
            
            curFlow = x5
            
            If curFlow < 0 Then
                no_flow = True
                Going_nowhere = Going_nowhere + 1
                GoTo skip_this_cv_calculation
            End If
            
            If OldMaxAirFlow < x5 Then OldMaxAirFlow = x5
          
            ' flow should always be going up, so the stability criteria doesn't have to be
            ' symmetrical
            If x5 > current_max_flow Then
                current_max_flow = x5 + lohm_allowable_flow_increase
                current_min_flow = x5
                reset_counter = reset_counter + 1
                T = Timer
                i = 0
            End If
          
            ' speed things up since flow may be going down
            If x5 < current_min_flow - lohm_allowable_flow_increase Then T = T - 0.1
            
            'Turn text black
            Msgform.Label.ForeColor = &H0
            Msgform.Label1.AutoSize = True
            Msgform.Label1.Caption = ts$(29) + "= " + Format$(CURPRES, "00.000#") + " " + ts$(30) + "= " + Format$(x5, "###000.##") ' "Waiting for stable: Pressure"/"Flow"
            Msgform.Label2.Caption = "PR: " + Format(Pres%)
            
            Msgform.Refresh
            DoEvents
          
            If curFlow < min_flow_rate And (Timer - T) > 2 And T <= Timer And Not pressure_in_order Then
                no_flow = True
                T = Timer
                Going_nowhere = Going_nowhere + 1
                GoTo skip_this_cv_calculation
            End If
                
            Rem added jsd April 2001 to help speed calibration through
            Rem turbulent regions
            Rem BUT - note that the version 6 machines, with 2 PG's read MUCH
            Rem faster when Pres% < 2 i.e. when only High PG used !!
        
            Rem added jsd april 2001
            GoSub check_abort_for_pause
            If Aborted = True Then
                Debug.Print "Lohm exit: Aborted"
                FLOWMSG% = 2
                Exit Do
            End If
          
            If Msgform.ok.Visible = False Then
                Debug.Print "Lohm exit: Msgform.ok.Visible = False"
                Exit Do
            End If
        
        Loop While ((Timer - T < 5) And (T <= Timer) And (i < 32000)) Or ((i < 5) And version >= 6#)
    
        Msgform.ok.Visible = False
        
        If Not doing_hflow1 And curFlow > 100 Then
            For i = 9 To 1 Step -1: Last_Flow(i) = Last_Flow(i - 1): Next i
            Rem have to change this as we now are using low and high range
            Rem so deal with flow, not counts
            Last_Flow(0) = curFlow
        End If
      
        Rem added by jsd - no need to average if less than 50 on high flow meter
        Rem no need to average if flow is this low
        
        i = 0      'this was set to 1, don't know why - changed back to 0 jsd
        CURPRES = 0
        CURPRES2 = 0
        curFlow = 0
        T = Timer
      
        Rem jsd to change to add more stability to readings
        Rem done Jan 2001
        Rem note change to loop while statement
        
        Do
            i = i + 1
            Rem added by jsd - now Running is true so this is not necessary
            Rem Pres% should be the same as from obove loop if switchover was necessary
            ReadXReturnX4 2
            
            CURPRES = CURPRES + x5  ' read in pressure and set variable
            
            ' we are using the high range
            If Pres% < high_pres% Then high_pres% = Pres%
            
            If Pres% > high_pres% Then
                ' we are using the low pressure gauge - read the high one as well
                low_pres% = Pres%   ' remember current low gauge range
                Pres% = high_pres%  ' set to high pressure gauge range
                ReadXReturnX4 2     ' read high pressure gauge
                
                CURPRES2 = CURPRES2 + x5
                Pres% = low_pres%   ' restore pres% to low gauge range
            Else
                ' we are using the same range for high and low
                CURPRES2 = CURPRES2 + x5
            End If
            
            ReadXReturnX4 1
            
            If OldMaxAirFlow < x5 Then OldMaxAirFlow = x5
            
            curflowcount = x4
            
            If curflowcount >= DAC_over Then GoTo skip_this_cv_calculation
            
            curFlow = curFlow + x5
            
            'change text to red
            Msgform.Label1.ForeColor = &HFF
            Msgform.Label1.AutoSize = True
            Msgform.Label1.Caption = ts$(31) + "= " + Format$((CURPRES / (i)), "00.000#") + " " + ts$(30) + "= " + Format$((curFlow / (i)), "###000.##") + "PR= " + Format(Pres%) ' "Averaging: Pressure"/"Flow"
            Msgform.Refresh
            
            Rem added jsd april 2001
            GoSub check_abort_for_pause
            
            If Aborted = True Then
                FLOWMSG% = 2
                Debug.Print "Lohm exit: Aborted"
                Exit Do
            End If
            
        Loop While ((Timer - T < 5) And (T <= Timer) And (i < 32000)) Or ((i < 10) And version >= 6#)
      
        ' change text from red to blue
        Msgform.Label1.ForeColor = &HFF0000
       
        curFlow = curFlow / i
        CURPRES = CURPRES / i
        CURPRES2 = CURPRES2 / i
        
        If doing_hflow1 And OldMaxAirFlow > FY2(1, 0) * gasflowconversionfactor Then
            doing_hflow1 = False
            Msgform.Label1.AutoSize = True
            Msgform.Label1.Caption = ts$(32)   ' "HFlow1 calibration finished - switching to HFlow2 - opening valve 2"
            Msgform.Refresh
            openv2completely
            HFLOW% = 2
            Move_Valve 9, "O"
            GoTo redo_flow_reading
        End If
      
        If PA = 0 Then tempvolflow = 1000
      
        Rem added by jsd to keep flow at mass flow
        tempvolflow = curFlow

        Rem new equation called Lohm equation for sub-sonic flow correction
        If PA = 0 Then
            pre_temp_Cv_Value = 1000
            pre_temp_Cv_Value2 = 1000
        Else
            If CURPRES < initpres Then CURPRES = initpres
            pre_temp_Cv_Value = 552# * Sqr((CURPRES - initpres) * (initpres))
            If CURPRES2 < initpres Then CURPRES2 = initpres
            pre_temp_Cv_Value2 = 552# * Sqr((CURPRES2 - initpres) * (initpres))
        End If
      
        Rem avoid divide by zero error !
        If pre_temp_Cv_Value = 0 Then
            no_flow = True
            GoTo skip_this_cv_calculation
        ElseIf PA = 0 Then
            CV_Value = 10
            CV_Value2 = 10
            tempvolflow = 100000
        Else
            Rem for new equation, flow is in SLPM - we have sccm
            tempvolflow = tempvolflow / 1000#
            If tempvolflow <= 0 Then
                no_flow = True
                GoTo skip_this_cv_calculation
            Else
                CV_Value = pre_temp_Cv_Value / tempvolflow
                CV_Value2 = shortHandIfelse((pre_temp_Cv_Value2 = 0), CV_Value, pre_temp_Cv_Value2 / tempvolflow)
            End If
        End If
      
        If CV_Value2 <= 0 Then CV_Value2 = CV_Value
      
        If curFlow > previous_flow Or PA = 0 Then
            If CV_Value > 0 Then
                Msgform.Label1.ForeColor = &H0 'change text back to black
                Msgform.Label1.AutoSize = True
                Msgform.Label1.Caption = "Lohm =" + Format$((CV_Value), "#00.00#")
                Rem also changed jsd from print to write to avoid comma period problems !
                
                If ExtraPG Then
                    If CV_Value2 <= lohm_tolerance And CV_Value <= lohm_tolerance Then
                        n% = n% + 1
                        Print #fn1, str$(curFlow); ","; str$(CV_Value2); ","; str$(CV_Value)
                    End If
                Else
                    If CV_Value <= lohm_tolerance Then
                        n% = n% + 1
                        Print #fn1, str$(curFlow); ","; str$(CV_Value)
                    End If
                End If
                
                Open "initial_pressure.txt" For Append As #10
                Print #10, CURPRES; ", "; CURPRES2
                Close #10
                
                previous_flow = curFlow
                i = 0
                
                If Not v2now_open Then cvpoints = cvpoints + 1
                
                no_flow = False
                no_pressure = False
            End If
        Else
            no_flow = True
            no_pressure = False
            Going_nowhere = Going_nowhere + 1
            GoTo skip_this_cv_calculation
        End If

        Rem diagnostic feature added by jsd to help construct lookup table for CV
        fn2 = FreeFile
        Open EXE_Path$ + "cvlog.txt" For Append As #fn2
        Print #fn2, (CURPRES - initpres); ","; CV_Value; ","; valve2_position; ","; tempvolflow
        Close #fn2

        Rem end CV calculations if any of the following test true
        GoSub check_abort_for_pause
        
        If PA = 0 Then
            FLOWMSG% = 0
            Debug.Print "Lohm exit: PA = 0"
            Exit Do
        ElseIf OldMaxAirFlow >= top_flow_rate Then
            FLOWMSG% = 0
            Debug.Print "Lohm exit: OldMaxAirFlow >= top_flow_rate"
            Exit Do
        ElseIf CURPRES > MAXCVPRES Then
            FLOWMSG% = 0
            Debug.Print "Lohm Exit: CURPRES > MAXCVPRES"
            Exit Do
        ElseIf Aborted Then
            FLOWMSG% = 2
            Debug.Print "Lohm Exit: Aborted"
            Exit Do
        ElseIf curFlow - Last_Flow(9) <= 500 And Not doing_hflow1 Then
            FLOWMSG% = 1
            Debug.Print "CURFLOW - Last_Flow(9) <= 500 And Not doing_hflow1"
            Exit Do
        End If
        
        last_good_flow = x5
        last_good_pres = CURPRES
        
skip_this_cv_calculation:
        If curflowcount >= DAC_over Then
            FLOWMSG% = 0
            Debug.Print "curflowcount >= DAC_over"
            Exit Do
        End If
        
        DoEvents
        
        If Going_nowhere > lohmTimeout Then
            If dualregulator And using_low_regulator And stagnation_check_iterations > 0 Then
                Going_nowhere = lohmTimeout * 0.9
            Else
                Debug.Print "Not Going_nowhere > lohmTimeout"
                Exit Do
            End If
        End If
        
        If Aborted Then
            Debug.Print "Aborted"
            Exit Do
        End If
    Loop        ' main do loop


'    Close #fn1
    
    If newreg Then
        CV_init_preg_incs = raw_reading(18)
    Else
        CV_init_preg_incs = REGPOS
    End If
    
    Msgform.Label1.AutoSize = True
    Msgform.Label1.Caption = ts$(33)        ' "Zeroing Regulator"
    Msgform.Refresh
    
'    fn1 = FreeFile
'    Open EXE_Path$ + "capwin.tmp" For Input As #fn1
'    fn2 = FreeFile
    
'    If current_unit% = 1 Then
'        default_lohm_filename = EXE_Path$ + "lohmtable.cal.FM-" + str$(flowMeterIndex) + ".cal"
'        Open default_lohm_filename For Output As #fn2
'    Else
'        default_lohm_filename = EXE_Path$ + "lohmtable.cal.unit" + str$(current_unit%) + ".FM-" + str$(flowMeterIndex) + ".cal"
'        Open default_lohm_filename For Output As #fn2
'    End If
    
    If ExtraPG Then
        Run_Lohm_Table_Calibration_For_FlowMeter = -n%
        'Print #fn2, -n%
    Else
        Run_Lohm_Table_Calibration_For_FlowMeter = n%
        'Print #fn2, n%
    End If
    
'    ReDim CV_flow!(n%), intermediate_CV_Value!(1, n%)
    
'    For i = 1 To n%
'
'        DoEvents
'
'        Input #fn1, CV_flow!(flowMeterIndex, i), intermediate_CV_Value!(flowMeterIndex, 0, i)
'
'        If ExtraPG Then
'            Input #fn1, intermediate_CV_Value!(flowMeterIndex, 1, i)
'            Print #fn2, str$(CV_flow!(flowMeterIndex, i)); ","; str$(intermediate_CV_Value!(flowMeterIndex, 0, i)); ","; str$(intermediate_CV_Value!(flowMeterIndex, 1, i))
'        Else
'            Print #fn2, str$(CV_flow!(flowMeterIndex, i)); ","; str$(intermediate_CV_Value!(flowMeterIndex, 0, i))
'        End If
'
'    Next i
'
'    Close #fn1
'    Close #fn2
'
'    'If the user entered a valid filename to save the lohm tables, copy the default table
'    users_lohm_filename = gpps2(Curr_U$, "lohmpath", IFile$, "")
'    If users_lohm_filename <> "" Then
'        On Error Resume Next
'        If current_unit% = 1 Then
'            FileCopy default_lohm_filename, users_lohm_filename + ".FM-" + str$(flowMeterIndex) + ".cal"
'        Else
'            FileCopy default_lohm_filename, users_lohm_filename + ".unit" + str$(current_unit%) + ".FM-" + str$(flowMeterIndex) + ".cal"
'        End If
'        On Error GoTo 0
'    End If
'
'    Kill EXE_Path$ + "capwin.tmp"
    Zero_Reg
    
    Rem close valve 2 all the way
    Msgform.Label1.AutoSize = True
    Msgform.Label1.Caption = ts$(11)        ' "Closing valve 2"
    Msgform.Refresh
    Send_RS232 ("C" + mv1_index_char)
    
    While RSEcho("V" + mv1_index_char, 1) <> Asc("S")
    Wend
    
    If status_lights_enable Then setStatusLights 1
    
    RUNNING = False
    Aborted = False
    
    If OldMaxAirFlow > lohmMaxAirflow Then
        lohmMaxAirflow = OldMaxAirFlow
    End If
    
    If PA = 0 Then lohmMaxAirflow = 500000
   
    Exit Function
    
check_abort_for_pause:
    If Aborted And Not abort_confirmed Then
        temp_regpos = REGPOS
        Zero_Reg
        If MsgBox(ts$(442), vbYesNo) = vbNo Then        ' "Do you really want to abort?"
            inc_reg temp_regpos
            Aborted = False
            Msgform.StopTest.Visible = True
        Else
            abort_confirmed = True
        End If
    End If
    Return
End Function

Sub calcHumidityTable()

    Dim nextFlow As Single
    Dim nextBubblerMVPostion As Long
    Dim positionInc As Long
    Dim nextPosition As Long
    Dim flowInc As Integer
    Dim maxNumRetries As Integer, numRetries As Integer
    Dim openBubblerMV As Boolean
    Dim mv2FullyOpened As Boolean
    
    Dim currentPosition As Single
    Dim stableFlow As Single
    Dim stableHumidity As Single

    Dim timeout As Integer
    Dim startTime As Single

    timeout = 15 'seconds

    'set size of tables that will hold the humidity data
    humidityTableMaxSize = 100
    humidityTableCurrentSize = 0
    ReDim humidityTable(humidityTableMaxSize)
    

    nextFlow = 1000 'start at 1 liter (1000 cc's)
    flowInc = 1000 'increase by at least 1 liter for each data point
    maxNumRetries = 50 'exit the calibration routine after this many tries and no flow increase
    numRetries = 0
    openBubblerMV = True 'flag to mark the direction we should be going with the bubbler mv
    positionInc = 3000 'amount to move bubbler mv (in counts) when collecting humidity readings
    mv2FullyOpened = False 'MV2 starts out closed, and is then pulsed open to create flow
        
    'prepare humidty table file
    Open "humidty_table.dat" For Output As #55
    'Print #55, "Bubbler MV Pos, Humidity (%), Flow Rate (cc/min)"
    

    'close valve 2 all the way, then we'll pulse it open to get the flow we want
    updateMsgLabel1 ts$(11)        ' "Closing valve 2"
    Send_RS232 ("C" + mv1_index_char)
    While RSEcho("V" + mv1_index_char, 1) <> Asc("S")
        DoEvents
    Wend
    
    'close bubbler mv all the way, then we'll pulse it open to get the humidities we want
    updateMsgLabel1 "Closing bubbler motor valve..."   ' "Closing bubbler mv"
    Send_RS232 ("CS")
    While RSEcho("VS", 1) <> Asc("S")
        DoEvents
    Wend
    
    'increment the regulator to 500 counts, then pulse open mv2 to get some flow,
    'this is done until the mv is fully open, then the reg is incremented to increase flow
    'updateMsgLabel1 "Incrementing regulator..."
    
    inc_reg 500
    updateMsgLabel1 "Reg Pos: " & str(REGPOS)
        
continue_humidity_table_loop:
    While numRetries < maxNumRetries And Not Aborted
            
        ReadXReturnX4 1
        updateMsgLabel "Flow = " & x5 & " cc"
            
        'Attempt to reach next flow rate using either MV2 or the regulator
        If Not mv2FullyOpened Then
            ' pulse mv2 open to reach next flow
            startTime = Timer
            While x5 < nextFlow And Timer - startTime < timeout And Timer - startTime >= 0
                Pulse_V2 0
                ReadXReturnX4 3
                updateMsgLabel1 "MV2 Pos: " & str(x4)
                ReadXReturnX4 1
                DoEvents
                updateMsgLabel "Flow = " & x5 & " cc"
            Wend
            mv2FullyOpened = checkIfMV2FullyOpened
        Else
            'inc regulator to reach next flow
            startTime = Timer
            While x5 < nextFlow And Timer - startTime < timeout And Timer - startTime >= 0
                inc_reg 1
                updateMsgLabel1 "Reg Pos: " & str(REGPOS)
                ReadXReturnX4 1
                DoEvents
                updateMsgLabel "Flow = " & x5 & " cc"
            Wend
        End If
        
        'wait for stable flow rate
        waitForStableFlowRate (True)
        
        
        'check if the flow has increased the necessary amount
        If x5 < nextFlow Then
            numRetries = numRetries + 1
            GoTo continue_humidity_table_loop
        End If
        
        If openBubblerMV Then
            ReadXReturnX4 33 'read open limit
            bubblerMV_OLIMIT = x4
            ReadXReturnX4 31 'read position
            nextPosition = x4
            updateMsgLabel1 "Bubbler MV Pos: " & str(x4)
            
            Do While nextPosition < bubblerMV_OLIMIT
                'go to next bubbler mv position
                'Send_RS232 "GS" + str(nextPosition)
                Send_RS232l "GS", nextPosition
                
                While RSEcho("VS", 1) <> Asc("S") 'wait for bubbler mv to stop moving
                    DoEvents
                Wend
                
                ReadXReturnX4 31
                updateMsgLabel1 "Bubbler MV Pos: " & str(x4)
            
                'wait for a stable humidity
                waitForStableHumidity
                
                'record the stable humidity, current flow rate, and bubbler mv position
                ReadXReturnX4 1 're-read flow
                stableFlow = x5
                ReadXReturnX4 31 're-read mv position
                currentPosition = x4
                stableHumidity = readHumiditySensor
                
                addHumidityTableDataToArray currentPosition, stableHumidity, stableFlow
                                        
                'save to file
                Print #55, currentPosition & "," & stableHumidity & "," & stableFlow
                                        
                nextPosition = currentPosition + positionInc
            Loop
        
            openBubblerMV = False
        Else
            ReadXReturnX4 32 'read close limit
            bubblerMV_CLIMIT = x4
            ReadXReturnX4 31 'read position
        
            nextPosition = x4
            updateMsgLabel1 "Bubbler MV Pos: " & str(x4)
            
            Do While nextPosition > bubblerMV_CLIMIT
                'go to next bubbler mv position
                'Send_RS232 "GS" + str(nextPosition)
                Send_RS232l "GS", nextPosition
            
                While RSEcho("VS", 1) <> Asc("S") 'wait for bubbler mv to stop moving
                    DoEvents
                Wend
            
                ReadXReturnX4 31
                updateMsgLabel1 "Bubbler MV Pos: " & str(x4)
                
                'wait for a stable humidity
                waitForStableHumidity
                
                'record the stable humidity, current flow rate, and bubbler mv position
                ReadXReturnX4 1 're-read flow
                stableFlow = x5
                ReadXReturnX4 31 're-read mv position
                currentPosition = x4
                stableHumidity = readHumiditySensor
                
                addHumidityTableDataToArray currentPosition, stableHumidity, stableFlow
                                        
                'save to file
                Print #55, currentPosition & "," & stableHumidity & "," & stableFlow
                                        
                nextPosition = currentPosition - positionInc
            Loop
        
            openBubblerMV = True
        End If
                        
        ' set next flow rate to reach
        nextFlow = nextFlow + flowInc
        
        'reset number of retries
        numRetries = 0
    Wend
    
    Close #55
        
End Sub

'use linear interpolation on the humidtyTable array to find the desired bubbler mv position for the given humidity and flow rate
'Function getBubblerMVPosition(humidity As Single, Flow As Single) As Long
'
'    Dim squaredError As Single
'    Dim smallestError As Single
'    Dim secondSmallestError As Single
'    Dim closestIndex As Integer
'    Dim secondClosestIndex As Integer
'    Dim humiditySpan As Single
'    Dim returnVal As Single
'    Dim i As Integer
'
'    smallestError = 10000
'    secondSmallestError = 10000
'    closestIndex = 1
'    secondClosestIndex = 2
'
'    For i = 1 To humidityTableMaxSize
'
'        squaredError = (humidityTable(i).humidity - humidity) ^ 2 + (humidityTable(i).flowRate - Flow) ^ 2
'
'        If squaredError < smallestError Then
'            secondSmallestError = smallestError
'            secondClosestIndex = closestIndex
'            smallestError = squaredError
'            closestIndex = i
'        ElseIf squaredError < secondSmallestError Then
'            secondSmallestError = squaredError
'            secondClosestIndex = i
'        End If
'
'    Next i
'
'    humiditySpan = Abs(humidityTable(closestIndex).humidity - humidityTable(secondClosestIndex).humidity)
'
'    'calc weighted average position of two closest points
'    returnVal = (1 - Abs(humidity - humidityTable(closestIndex).humidity) / humiditySpan) * humidityTable(closestIndex).bubblerMVPos + _
'                (1 - Abs(humidity - humidityTable(secondClosestIndex).humidity) / humiditySpan) * humidityTable(secondClosestIndex).bubblerMVPos
'
'    getBubblerMVPosition = CLng(returnVal)
'
'End Function

Sub addHumidityTableDataToArray(bubblerMVPos As Single, humidity As Single, flowRate As Single)

    humidityTableCurrentSize = humidityTableCurrentSize + 1
    
    If humidityTableCurrentSize > humidityTableMaxSize Then
        humidityTableMaxSize = humidityTableMaxSize + 100
        ReDim Preserve humidityTable(humidityTableMaxSize)
    End If
    
    humidityTable(humidityTableCurrentSize).bubblerMVPos = bubblerMVPos
    humidityTable(humidityTableCurrentSize).humidity = humidity
    humidityTable(humidityTableCurrentSize).flowRate = flowRate

End Sub

Sub loadHumidityTable()

    On Error GoTo handle_humidityTable_load_error
    
    Dim currentLine As String
    Dim result As SplitStringResult
    
    Open "humidty_table.dat" For Input As #55
    
    'reset size of humidity table array
    humidityTableMaxSize = 100
    humidityTableCurrentSize = 0
    ReDim humidityTable(humidityTableMaxSize)
    
    Do While Not EOF(55)
        Line Input #55, currentLine
        result = splitString(currentLine, ",")
        addHumidityTableDataToArray CSng(result.values(1)), CSng(result.values(2)), CSng(result.values(3))
    Loop
    
    Close #55
    
handle_humidityTable_load_error:
    MsgBox "Error loading the humidity table, please run a humdity table calibration before running a test using humidity!"

End Sub

Sub waitForStableHumidity()
    
    Dim timeout As Integer
    Dim startTime As Long
    Dim elapsedTime As Long
    Dim waitTime As Long
    Dim minWaitTime As Long
    Dim tolerance As Single
    Dim h1 As Single, h2 As Single
    
    timeout = stableHumidityMaxWaitTime 'seconds until a timeout
    minWaitTime = stableHumidityMinWaitTime 'minimum time to wait before leaving stability routine
    waitTime = stableHumiditySleepTime 'wait for this many milli's before taking each reading
    tolerance = stableHumidityTolerance 'two readings must be within this percentage to be stable
    
    If timeout = 0 Then Exit Sub
    
    startTime = Timer 'timer returns number of seconds elapsed since midnight
    elapsedTime = Timer - startTime

    While elapsedTime < timeout And elapsedTime >= 0 And Not Aborted 'make sure it's positive, if case a test is being run right before the clock strikes midnight
        
        'read humidity sensor
        h1 = readHumiditySensor
        updateHumidityDisplay
        
        'wait for a few seconds
        Waitms waitTime, False
        
        'read humidity sensor again
        h2 = readHumiditySensor
        updateHumidityDisplay
        
        'compare two previous flow readings, exit if they're within range
        If Abs(h2 - h1) < tolerance And elapsedTime > minWaitTime Then
            Exit Sub
        End If
        
        elapsedTime = Timer - startTime
        
    Wend

End Sub

Sub waitForStableFlowRate(updateScreen As Boolean)

    Dim timeout As Integer
    Dim startTime As Long
    Dim elapsedTime As Long
    Dim waitTime As Long
    Dim tolerance As Single
    Dim f1 As Single, f2 As Single
    
    timeout = 5 'seconds until a timeout
    startTime = Timer 'timer returns number of seconds elapsed since midnight
    waitTime = 500 'wait for this many milli's before taking each reading
    tolerance = 500 'two readings must be within this many cc's of each other to be stable
    elapsedTime = Timer - startTime

    While elapsedTime < timeout And elapsedTime >= 0 'make sure it's positive, in case a test is being run right before the clock strikes midnight
        
        'read flow meter
        ReadXReturnX4 1
        f1 = x5
        If updateScreen Then
            updateMsgLabel "Flow = " & x5 & " cc"
        End If
        
        'wait for a few seconds
        Waitms waitTime, False
        
        'read flow meter again
        ReadXReturnX4 1
        f2 = x5
        If updateScreen Then
            updateMsgLabel "Flow = " & x5 & " cc"
        End If
        'compare two previous flow readings, exit if they're within range
        If Abs(f2 - f1) < tolerance Then
            Exit Sub
        End If
        
        elapsedTime = Timer - startTime
    Wend

End Sub

Function checkIfMV2FullyOpened() As Boolean

    ReadXReturnX4 3 'read position
    
    If x4 >= oLimit Then
        checkIfMV2FullyOpened = True
    Else
        checkIfMV2FullyOpened = False
    End If

End Function

Sub updateMsgLabel1(str As String)
    Msgform.Label1.AutoSize = True
    Msgform.Label1.Caption = str
    Msgform.Refresh
End Sub

Sub updateMsgLabel(str As String)
    Msgform.Label.AutoSize = True
    Msgform.Label.Caption = str
    Msgform.Refresh
End Sub


' calc_chamber_vol is replaced by calc_diff_vol(true)
' calc_diff_vol is replaced by calc_diff_vol(false)
'Sub calc_chamber_vol()
'' Calculate volume of sample chamber
'
'    If AirTop Then
'        Move_Valve 19, "O" ' make sure bottom valve is open as they seal the chamber
'    End If
'    MsgBox ts$(44)      ' "Put Non-Porous Disk in Sample Chamber and Seal"
'    RUNNING = True
'    ' bottom valve does not need to be open for this since the sample shouldn't leak
'    Diff_Volume = find_volume(1)
'    WPPS "Capstuff", "Chamber_Volume", Str$(Diff_Volume), CSFile$
'
'End Sub

Sub calc_diff_vol(first_part_only As Boolean)

    Dim compression_special As Boolean
    Dim do_all_volumes As Boolean
    Dim original_selected_volume_index As Integer
    Dim i As Integer
    
    do_all_volumes = False
    If (first_part_only = False) And Num_Microflow_Volumes > 1 Then
        If MsgBox("Do you want to calibrate all of the Microflow Volumes?", vbYesNo) = vbYes Then
            do_all_volumes = True
        End If
    End If

    If AirTop Then Move_Valve 19, "O" ' make sure bottom valve is open as they seal the chamber
    MsgBox ts$(44)      ' "Put Non-Porous Disk in Sample Chamber and Seal"
    RUNNING = True
    If autocompress Then
        ' ask for compression pressure
        Got_Value = -9 ' default so if they cancel we will know it
        GetCompressionPressure.Show 1
        If Got_Value <> -9 Then
            compression_pressure = Got_Value
            'compression_pressure = compression_pressure / PCNV
            If compression_pressure = 0 And Not allowZeroCompression Then
                compression_pressure = 20
                compression_special = True
            Else
                compression_special = False
            End If
            If creg_table_size% > 0 Then
                If creg_table_pres!(creg_table_size%) < compression_pressure Then
                    MsgBox (ts$(331))                       ' "Compression Pressure greater than maximum calibrated pressure for regulator."
                    compression_pressure = creg_table_pres!(creg_table_size%)
                End If
            End If
            move_compression_regulator_to_pressure (compression_pressure)
            If compression_special Then compression_pressure = 0
            WPPS "Capstuff", "compression_pressure", str$(compression_pressure), CSFile$
            save_user_global_stuff
        Else
            MsgBox ts$(332)         ' "The compression regulator will be left at its current position"
        End If
    End If
    If autopiston Or (autocompress And compression_pressure <> 0 And (current_unit% = 1 Or current_unit% <= number_of_pistons)) Then
        ' engage piston
        If compression_special Then
            move_piston "C"
        Else
            safety_canceled = False
            If safetydown Then
                If safetydowndoor Then
                    ' do auto door switch thing instead of key press thing
                    check_safety_door True
                Else
                    safetykeypress.mainlabel.Caption = ts$(206)         ' "Piston About To Lower"
                    safetykeypress.Show 1
                End If
            ElseIf autopiston Then
                check_safety_door True
            End If
            If Not safety_canceled Then move_piston "O"
        End If
    End If      ' autocompression
                    
    ' bottom valve does not need to be open for this since the sample shouldn't leak
    Diff_Volume(0) = find_volume(1)
    If autopiston Or (autocompress And Not compression_special) Then
        safety_canceled = False
        If safetyup And Vpos(15) = 1 Then
            If safetyupdoor Then
                ' do auto door switch thing instead of key press thing
                check_safety_door True
            Else
                safetykeypress.mainlabel.Caption = ts$(166)     ' "Piston About To Raise"
                safetykeypress.Show 1, progress
            End If
        ElseIf autopiston Then
            check_safety_door True
        End If
        If Not safety_canceled Then move_piston "C"
    End If
    If manuallySelectedChamber = 1 Then
        WPPS "Capstuff", "Chamber_Volume", str$(Diff_Volume(0)), CSFile$
    Else
        WPPS "Capstuff", "Chamber_Volume" + Format$(manuallySelectedChamber), str$(Diff_Volume(0)), CSFile$
    End If
    
    If first_part_only Then Exit Sub
    
    MsgBox ts$(45)      ' "Remove Non-Porous Disk and Connect Top of Chamber to Instrument"
    If AirTop Then Move_Valve 19, "C"
    If autopiston Or (autocompress And Not compression_special) Then
        safety_canceled = False
        If safetydown Then
            If safetydowndoor Then
                ' do auto door switch thing instead of key press thing
                check_safety_door True
            Else
                safetykeypress.mainlabel.Caption = ts$(206)         ' "Piston About To Lower"
                safetykeypress.Show 1
            End If
        ElseIf autopiston Then
            check_safety_door True
        End If
        If Not safety_canceled Then
            move_piston "O"
        End If
    End If
    If do_all_volumes Then
        original_selected_volume_index = Current_Microflow_Volume_Index
        For Current_Microflow_Volume_Index = 1 To Num_Microflow_Volumes
            update_microflow_volume_valves
            Diff_Volume(manuallySelectedChamber + Current_Microflow_Volume_Index - 1) = find_volume(2) - Diff_Volume(0)
        Next Current_Microflow_Volume_Index
        Current_Microflow_Volume_Index = original_selected_volume_index
        update_microflow_volume_valves
    Else
        Diff_Volume(manuallySelectedChamber + Current_Microflow_Volume_Index - 1) = find_volume(2) - Diff_Volume(0)
    End If
    
    If autopiston Or (autocompress And Not compression_special) Then
        safety_canceled = False
        If safetyup And Vpos(15) = 1 Then
            If safetyupdoor Then
                ' do auto door switch thing instead of key press thing
                check_safety_door True
            Else
                safetykeypress.mainlabel.Caption = ts$(166)     ' "Piston About To Raise"
                safetykeypress.Show 1, progress
            End If
        ElseIf autopiston Then
            check_safety_door True
        End If
        If Not safety_canceled Then
            move_piston "C"
        End If
    End If
    
    If do_all_volumes Then
        WPPS "Capstuff", "Diff_Volume", str$(Diff_Volume(1)), CSFile$
        For i = 2 To Num_Microflow_Volumes
            WPPS "Capstuff", "Diff_Volume" + Format$(manuallySelectedChamber + i - 1), str$(Diff_Volume(manuallySelectedChamber + i - 1)), CSFile$
        Next i
    Else
        If manuallySelectedChamber = 1 And Current_Microflow_Volume_Index = 1 Then
            WPPS "Capstuff", "Diff_Volume", str$(Diff_Volume(1)), CSFile$
        Else
            WPPS "Capstuff", "Diff_Volume" + Format$(manuallySelectedChamber + Current_Microflow_Volume_Index - 1), str$(Diff_Volume(manuallySelectedChamber + Current_Microflow_Volume_Index - 1)), CSFile$
        End If
    End If
    
    RUNNING = False
    If AirTop Then Move_Valve 19, "O"
End Sub

Sub Calc_MaxLowFlow()
    Dim numerator As Single
    Dim denominator As Single
    Dim multiplier As Single
    Dim adder As Single
    Dim result As Single
    
    numerator = DAC_two - FX1(0, 0)
    denominator = FX2(0, 0) - FX1(0, 0)
    multiplier = FY2(0, 0) * gasflowconversionfactor - FY1(0, 0)
    adder = FY1(0, 0)
    
    result = numerator / denominator
    result = result * multiplier
    result = result + adder
    MaxLowFlow = result
    'MaxLowFlow = (DAC_two - FX1(0, 0)) / (FX2(0, 0) - FX1(0, 0)) * (FY2(0, 0) * gasflowconversionfactor - FY1(0, 0)) + FY1(0, 0)
End Sub

Sub Calc_MaxLQFlow()
    Dim FTot As Single
    Dim Cnt As Single
    Dim T As Single
    Dim h As Single
    Dim Ret$, temp$
    Dim lastH As Single
    Dim lastT As Single
    Dim firstT As Single
    Dim VOL As Single
    Dim lastx4 As Long
    Dim l_temp As Long
    Dim P As Single
    Dim fn As Integer
    Dim LOHM(40) As Single
    Dim highestValue As Single
    Dim lowestValue As Single
    Dim highestIndex As Integer
    Dim lowestIndex As Integer
    Dim sumLohm As Single
    Dim i As Integer
    
RECalc:
    TitleScrn.MousePointer = 11
    Init_System
    Dry_Chamber_Control "C"
    If dualregulator And regnum = 1 Then
        Move_Valve 16, "C"
        regnum = 0
        If (air_inlets = 2) Then
            Move_Valve 15, "C"
            current_air_inlet = 1
        End If

    End If
    
    If Auto_fill Then
        temp$ = ts$(46) + vbCrLf + ts$(47) + vbCrLf + ts$(48) + vbCrLf + ts$(49)  ' "The sample chamber should be empty."/"Insert large insert into chamber."/"Screw on cap with Quick-Connect."/"Attach Penetrometer hose to cap."
    Else
        Move_Valve 2, "C"
        If v20_exists Then Move_Valve 19, "C"
        If Drain12 Then Move_Valve 11, "C"
        temp$ = ts$(46) + vbCrLf + ts$(47) + vbCrLf + ts$(48) + vbCrLf + ts$(50)   ' "The sample chamber should be empty."/"Insert large insert into chamber."/"Screw on cap with Quick-Connect."/"Fill sample chamber with water."
    End If
    
    reply% = MsgBox(temp$ + vbCrLf + ts$(51), 49, ts$(52))      ' "Press OK when Complete."/"Calibration Setup"
    If reply% = 2 Then
        TitleScrn.MousePointer = 0
        Exit Sub
    End If
        
    Rem penetrometer fill handled by the load_sample routine
    TType%(current_unit%) = -1 ' special for max liq flow test
    pass = 2 ' special for max liq flow test
    Aborted = False
    Load_Sample first_array
    If Aborted = True Then
        TitleScrn.MousePointer = 0
        Exit Sub
    End If
    ' load_sample should also set pres% to the right channel for reading pressures for later in the test
    RUNNING = True ' to allow auto pressure range switching
    If status_lights_enable Then setStatusLights 2

    Msgform.Label.Caption = ts$(53)         ' "Liquid Calibration"
    Msgform.Refresh
        
    If liqpermonly Then
        Move_Valve 2, "C"
    Else
        Move_Valve 2, "O"
    End If
    
    ' 6.71.78 don't use ambient any more, but only for new systems that have an ip regulator
    If ip_reg_enable Then
        ' open valve 2 all the way
        openv2completely
        
        ' increase pressure to about 2 PSI
        l_temp = regpos_from_p(2)
        If l_temp > 4000 Then l_temp = 4000
        If REGPOS < l_temp Then inc_reg l_temp - REGPOS
        ' open valve 9 to let this pressure go to the penetrometer
        Move_Valve 8, "O"
    End If
    fn = FreeFile
    If penetrometer_select = 1 Then
        Open EXE_Path$ + "maxlqflow.txt" For Output As #fn
    Else
        Open EXE_Path$ + "maxlqflow2.txt" For Output As #fn
    End If
    Print #fn, "T,P,h,lastH,lastT,dt,dh,flow,lohm"
    If Drain12 Then Move_Valve 11, "O"
    FTot = 0: Cnt = 0
        
A3720:
    'Debug.Print "A3720"
    T = Timer
    ReadXReturnX4 4
    ' 50 counts is -2.25% of full scale.  For version 7 this would be
    ' 650 counts.
    ' 20000 counts is 97.5% of full scale
    ' 6.71.80 changed this from - to + so that we wait for the float to really be
    ' in range before we start making our measurements
    'If x4 <= (DAC_zero - DAC_span * 0.0225) Or x4 >= (DAC_span * 0.975 + DAC_zero) Then GoTo A3720
    
    'JF 8-22-10
    If x4 <= (pen_min_counts + pen_span * 0.0225) Or x4 >= pen_max_counts Then GoTo A3720
    'If x4 <= (DAC_zero + DAC_span * 0.0225) Or x4 >= pen_max_counts Then GoTo A3720
    h = x5
    firstT = T
A3740:
    lastH = h
    lastT = T
    lastx4 = x4
    'Debug.Print "A3740"
A3760:
    'Debug.Print "A3760"
    T = Timer
    ReadXReturnX4 2
    
    
    P = x5 - P0
    ReadXReturnX4 4
    h = x5
    ' 0.1 seconds added to midnight check to fix roundoff error that happens in some machines
    If T + 0.1 < lastT Then lastT = lastT - 86400!
    If PA = 0 Then
        FTot = 1000
        Cnt = 1
        GoTo exit_calc
    End If
    'Debug.Print "A3760: " + Str$(x4)
    
    If x4 <= DAC_under Or x4 >= pen_max_counts Then GoTo exit_calc
    
    ' 500 counts is 2.5% (1/40) of a 20,000 count span
    ' (it is also the zero value of a ver. 6, but I think in this case we
    '  want 2.5%, since the zero value of a ver. 7 is 2000, which would be
    '  3.333% and would therefore represent a different value.)
    If Abs(x4 - lastx4) < (DAC_span / 40) Or (T - lastT) < 0.2 Then GoTo A3760
    
    VOL = shortHandIfelse((Second_Penetrometer And penetrometer_select = 2), P2CSECAREA * (h - lastH), CSECAREA * (h - lastH))
    DoEvents
    f = VOL / (lastT - T) * 60
    If f > 0 Then
        If Second_Penetrometer And penetrometer_select = 2 Then
            LOHM(Cnt) = Sqr(P + P2PSIPERCM * (lastH + h) / 2) * 75700 / f
        Else
            LOHM(Cnt) = Sqr(P + PSIPERCM * (lastH + h) / 2 - sample_zero_point) * 75700 / f
        End If
        Write #fn, T - firstT, P, h, lastH, lastT - firstT, T - lastT, lastH - h, f, LOHM(Cnt)
        
        Debug.Print "Lohm: " + str$(LOHM(Cnt)) 'AJB 11-21-09
        
        FTot = FTot + f
        Cnt = Cnt + 1
        If Cnt = 1 Then
            highestValue = LOHM(Cnt)
            lowestValue = LOHM(Cnt)
            highestIndex = 1
            lowestIndex = 1
        ElseIf LOHM(Cnt) > highestValue Then
            highestValue = LOHM(Cnt)
            highestIndex = Cnt
        ElseIf LOHM(Cnt) <= lowestValue Then
            lowestValue = LOHM(Cnt)
            lowestIndex = Cnt
        End If
    End If
    GoTo A3740
        
exit_calc:
    Close #fn
    If ip_reg_enable Then
        Move_Valve 8, "O" ' vent the penetrometer
        Zero_Reg
        excercize_valve_2 ' this results in valve 2 being closed all the way
    End If
    RUNNING = False
    If status_lights_enable Then setStatusLights 1
    Unload Msgform
    If Cnt = 0 Then
        MsgBox ts$(54)          ' "Can not calculate maximum liquid flow - something is wrong with the penetrometer settings as no flow readings could be taken."
    Else
        MsgBox ts$(55) + " " + str$(FTot / Cnt) + " cc/min" + vbCrLf + " " + ts$(57), 0, ts$(58)    ' "The calibrated liquid flow of"/"cc/min"/"was calculated."/"Calibration Done"
        Ret$ = str$(FTot / Cnt)
        If penetrometer_select = 1 Then
            WPPS "Capstuff", "MAXLQFLOW", Ret$, CSFile$
        Else
            WPPS "Capstuff", "MAXLQFLOW2", Ret$, CSFile$
        End If
        If Cnt = 1 Then
            liquid_lohm(penetrometer_select) = LOHM(1)
        ElseIf Cnt = 2 Then
            liquid_lohm(penetrometer_select) = LOHM(2)
        Else
            sumLohm = 0
            For i = 1 To Cnt
                If (i <> highestIndex) And (i <> lowestIndex) Then sumLohm = sumLohm + LOHM(i)
            Next i
            liquid_lohm(penetrometer_select) = sumLohm / (Cnt - 2)
        End If
        If penetrometer_select = 1 Then
            WPPS "Capstuff", "liquid_lohm", str$(liquid_lohm(1)), CSFile$
        Else
            WPPS "Capstuff", "liquid_lohm2", str$(liquid_lohm(2)), CSFile$
        End If
    End If
    TitleScrn.MousePointer = 0
    Screen.MousePointer = 0
    
End Sub

Function Check_PassFail(a As Single) As Integer
' Check the value of a to see if it falls within the bounds of minPassDiameter() and maxPassDiameter() for
' a pass/fail test. Output:
'               -1: below bounds
'                0: within bounds (passes)
'                1: above bounds

    If a >= minPassDiameter(current_unit%) And a <= maxPassDiameter(current_unit%) Then
        Check_PassFail = 0
    ElseIf a < minPassDiameter(current_unit%) Then
        Check_PassFail = -1
    Else
        Check_PassFail = 1
    End If

End Function

Sub check_safety_door(cancelable As Boolean)
safety_canceled = False ' they haven't canceled yet
Do
    If (RSEcho("R@", ver1or2) And 1) = 0 Then Exit Sub ' the door switch is activated, simply return
    ' ask them to close the door
    If cancelable Then
        If MsgBox("Close door so piston can move safely", vbOKCancel) = vbCancel Then
            safety_canceled = True
            Exit Sub
        End If
    Else
        MsgBox "Close door so piston can move safely", vbOK
    End If
Loop
End Sub

Sub checkLegalSettings()
    ' make sure that ttype and tmode are set to legal values for this type of machine
    If H2OPERM = False And TType%(current_unit%) = 4 Then
        TType%(current_unit%) = 1
        TMode%(current_unit%) = 1
    End If
    If DiffPG = False And lvperm_enable = False And TType%(current_unit%) = 6 Then
        TType%(current_unit%) = 1
        TMode%(current_unit%) = 1
    End If
    If GasPerm = True And liqpermonly = False And (TType%(current_unit%) = 1 Or TType%(current_unit%) = 2 Or TType%(current_unit%) = 4) Then
        TType%(current_unit%) = 3
        TMode%(current_unit%) = 0
    End If
    If liqpermonly = True And (TType%(current_unit%) = 1 Or TType%(current_unit%) = 2 Or TType%(current_unit%) = 3 Or TType%(current_unit%) = 5) Then
        TType%(current_unit%) = 4
        TMode%(current_unit%) = 2
    End If
    If itester = True And (TType%(current_unit%) = 1 Or TType%(current_unit%) = 3) Then
        TType%(current_unit%) = 2
        TMode%(current_unit%) = 2
    End If
'    If BPTester = True And (TType%(current_unit%) = 1 Or TType%(current_unit%) = 3 Or TType%(current_unit%) = 5) Then
    If BPTester = True And (TType%(current_unit%) = 1 Or TType%(current_unit%) = 3) Then
        TType%(current_unit%) = 2
        TMode%(current_unit%) = 1
    End If
    If integrity = False And TType%(current_unit%) = 2 And TMode%(current_unit%) = 2 Then TMode%(current_unit%) = 1
    If hydrohead = False And TType%(current_unit%) = 2 And TMode%(current_unit%) = 3 Then TMode%(current_unit%) = 1
    If hydrohead_exclusive = True Then
        TType%(current_unit%) = 2
        TMode%(current_unit%) = 3
    End If
    If WESA_enabled = False And TType%(current_unit%) = 3 And TMode%(current_unit%) = 1 Then TMode%(current_unit%) = 0
    If PDrop = False And TType%(current_unit%) = 3 And TMode%(current_unit%) = 2 Then TMode%(current_unit%) = 0
End Sub

Sub CleanOut()
    Dim i As Integer
    Dim T As Single
    
    If AirTop Then
        reply% = MsgBox(ts$(59), 4, ts$(60))         ' "CleanOut is not really necessary for your machine.  Do you wish to do it anyway?"/"CleanOut"
    Else
        reply% = MsgBox(ts$(61), 4, ts$(60))     ' "Do you wish to do a Final CleanOut to remove remaining liquid from the system?"/"Cleanout"
    End If
    If reply% = 7 Then Exit Sub
    Zero_Reg
    Move_Valve 10, "C"
    Pres% = 1
    If AirTop Then
        reply% = MsgBox(ts$(62) + vbCrLf + ts$(63), 1, ts$(60))      ' "Remove any sample from the chamber, seal the empty chamber, and attach the air hose." /"Press OK to continue."/"CleanOut"
    Else
        reply% = MsgBox(ts$(64) + vbCrLf + ts$(63), 1, ts$(60))      '"Remove any sample from the chamber and install the nonporous insert."/"Press OK to continue."
    End If
    If reply% = 2 Then Exit Sub
    openv2completely
    Dry_Chamber_Control "O"
    MsgBox ts$(65), 0, ts$(60)           ' "The drain will now be pulsed to purge any fluid."/"CleanOut"
    If newreg Then
        reg_goto SHFP + (reg_ol - SHFP) \ 5
    Else
        For i = 1 To 50 Step 1: inc_reg 10: Next i
    End If
    If Drain12 Then
        Move_Valve 11, "O"
        If v20_exists Then Move_Valve 19, "C"
        Move_Valve 2, "C"
    Else
        Move_Valve 2, "O"
    End If
    
Cl_Again:
    For i = 1 To 10
        T = Timer
        waitseconds 10
        'While (Timer - T < 10) And (Timer > T): DoEvents: Wend
        If Drain12 Then
            Move_Valve 11, "C"
        Else
            Move_Valve 2, "C"
        End If
        waitseconds 3
        ' 6.71.25
        ' this time delay didn't actually work since it didn't reset T to Timer
        ' at the beginning.  It is changed to a working 3 second delay anyway
        'While (Timer - T < 3) And (Timer > T): DoEvents: Wend
        If Drain12 Then
            Move_Valve 11, "C"
        Else
            Move_Valve 2, "O"
        End If
    Next i
    reply% = MsgBox(ts$(66) + vbCrLf + ts$(67), 4, ts$(60))  ' "Check drain to see if fluid is still coming from the machine."/"Is further purging necessary?"
    If reply% = 6 Then GoTo Cl_Again
    Init_System
    Move_Valve 2, "C"
    If Drain12 Then Move_Valve 11, "C"
    MsgBox ts$(68), 0, ts$(60)     ' "Cleanout Complete."/"CleanOut"
    Screen.MousePointer = 0
    
End Sub

Function convert_to_c(T, u$)
' Fahrenheit to Celsius
    
    If Right$(UCase$(u$), 1) <> "C" Then
        convert_to_c = (T - 32) * 5 / 9
    Else
        convert_to_c = T
    End If
    
End Function
Function close_v2_completely()
    
    Rem real easy this one!
    If Not hasMultipleMVs Then
        
            Send_RS232 "C" + mv1_index_char
        
        While RSEcho("V" + mv1_index_char, 1) <> Asc("S")
            
            tryhold
        Wend
        
    Else
        Send_RS232 "C" + mv1_index_char
        While RSEcho("V" + mv1_index_char, 1) <> Asc("S")
            tryhold
        Wend
        
        Send_RS232 "C" + mv2_index_char
        While RSEcho("V" + mv2_index_char, 1) <> Asc("S")
            tryhold
        Wend
        
        If numberOfMotorValves > 2 Then
            Send_RS232 "C" + mv3_index_char
            While RSEcho("V" + mv3_index_char, 1) <> Asc("S")
                tryhold
            Wend
        End If
    End If
End Function

Function cregpos_from_p(P As Single) As Long
' return the compressure regulator position that should give a pressure of p

    Dim i As Integer

    If creg_table_size% <= 1 Then
        ' estimate based on creg_ol and creg_cl and 0 to 100 PSI
        If P <= 0 Then
            cregpos_from_p = creg_cl
        ElseIf P >= 100 Then
            cregpos_from_p = creg_ol
        Else
            cregpos_from_p = P * (creg_ol - creg_cl) / 100 + creg_cl
        End If
    Else
        i = 2
        While i < creg_table_size% And P > creg_table_pres!(i)
            i = i + 1
        Wend
        If P > creg_table_pres!(i) Then
            cregpos_from_p = creg_table_pos(i)
        Else
            cregpos_from_p = (P - creg_table_pres!(i - 1)) * (creg_table_pos(i) - creg_table_pos(i - 1)) / (creg_table_pres!(i) - creg_table_pres!(i - 1)) + creg_table_pos(i - 1)
        End If
    End If

End Function

Sub calc_CV()
' this has been renamed to Run_Lohm_Table_Calibration
End Sub

Function CVcalc(P, f)
' this is actually the lohm calculation - we switched
' cleaned up and additional comments added 5-19-05
' Called with pressure P, in PSIA
' and flow f in standard cc/min
' Global variable P0 has atmospheric pressure in PSIA
' Global variable Pres% has 0 or 1 when using the high pressure gauge and
'  2 or 3 when using the low pressure gauge
' The return value is the corrected P value, which should be lower than the called P value
' due to the flow rate and the resistance of the line, but it should never get below P0
    
    'hold the index to the flow meter we're currently reading from, used to access the right lohm data in the lohm arrays
    Dim fm%

    'Find out which flow meter we're using
    If HFLOW% = 0 Or HFLOW% = 1 Then
    
        If motorValveIndex = 0 Then
            fm% = 1
        ElseIf motorValveIndex = 1 Then
            fm% = 2
        End If
        
    ElseIf HFLOW% = 2 Or HFLOW% = 3 Then
    
        If motorValveIndex = 0 Then
            fm% = 3
        ElseIf motorValveIndex = 1 Then
            fm% = 4
        End If
        
    End If


    Dim CVP As Single
    Dim fn As Single
    Dim Lohm_Flow As Single
    Dim LOHM As Single
    Dim j%
    ' if you call this when using the frazier pressure gauge
    ' it will return the original value of P
    ' (Pres% is never > 3, but if it ever is, we can't use the lohm calibration anyway)
    If Pres% > 3 Or FrazierRunning Then
        CVcalc = P
        Exit Function
    End If
    ' j%=0 for high pressure gauge, 1 for low pressure gauge
    If Pres% < 2 Then j% = 0 Else j% = 1
    Rem new variables (array) for creation of separate file showing raw and corrected pressures
    Dim times_in_here As Integer

    Rem This function calls another function ,intermediate_CV, to return an interpolated CV value
    
    ' if the flow is 0 (or negative) there can't be any back pressure so the corrected P
    ' must be the current P.
    If f <= 0 Then CVcalc = P: Exit Function
    
    ' find out the lohm value (resistance) from the table for the current flow rate and pressure gauge
    LOHM = intermediate_CV(fm%, j%, f)
    
    Rem this equation wants flow in SLPM so we have to do this
    Lohm_Flow = f / 1000#
    
    ' **************************
    ' Following is the old equation Jeff Dixon used
    ' CVP = (((Lohm * Lohm_Flow / (2 * 276)) ^ 2) / P0) + P0
    ' New equation Ron Webber derived from Lee information about lohm, 3/18/04:
    ' CVP = 0.5 * (P + Sqr(P ^ 2 - 4 * ((Lohm * Lohm_Flow) / (2 * 276)) ^ 2))
    ' Notes: solved using quadratic formula
    '        271 is the gas constant for air - N2 is 276 -- but this doesn't matter for what we're doing,
    '           as long as it's consistent.
    '        There is also a temperature correction factor that has been left out:
    '           =1 at 23 C; varies from .97 to 1.07 over 0 - 100 F temperature range
    ' **************************
    ' This equation is now done in two parts so we can trap out a possible negative square root
    ' when flow is 0, equation reduces to:
    ' CVP = 0.5 * (P + Sqr(P ^ 2 - 0))
    ' which is the same as CVP = P
    ' When resistance (lohm) is 0, the same thing happens.
    ' As flow goes up, or as resistance goes up, the value inside the SQR goes down
    ' The lowest it should be able to get is 0, which results in CVP = P/2
    ' To keep going lower when the resistance is even higher, we can redefine the square root
    ' function so that the square root of a negative number is the negative of the square root
    ' of the absolute value of the number.  This may not be valid, but it keeps the equation
    ' continuous and the only way you will get there is if the lohm value is incorrect in the first
    ' place.
    CVP = P ^ 2 - 4 * ((LOHM * Lohm_Flow) / (2 * 276)) ^ 2
    If CVP >= 0 Then
        CVP = (0.5 * (P + Sqr(CVP)))
    Else
        CVP = (0.5 * (P - Sqr(-CVP)))
    End If
    'CVP = shortHandIfelse(CVP >= 0, (0.5 * (P + Sqr(CVP))), (0.5 * (P - Sqr(-CVP))))
    ' don't return a value higher than P
    If CVP >= P Then
        ' this shouldn't be possible because CVP is the average of P and some value that is less than P
        CVcalc = P
        Exit Function
    End If
    
    Rem experimental jsd April 22, 2001
    Rem Create Array with Raw and corrected pressures, then output at end of test.
    If V2Percent = 21 Then
        If lohm_counter = 0 And times_in_here = 0 Then
            fn = FreeFile
            Open EXE_Path$ + "Lohm Correction File.dat" For Output As #fn
            Print #fn, "Raw Pressure"; ","; "Lohm Pressure"; ","; "Flow (SLPM)"; ","; "Interpolated Lohm"
            Close #fn
            size_of_lohm_array = 2000
            ReDim Lohm_P(size_of_lohm_array)
            ReDim Lohm_Val(size_of_lohm_array)
            ReDim Lohm_F(size_of_lohm_array)
            ReDim Raw_P(size_of_lohm_array)
            times_in_here = 1
        End If
        
        If lohm_counter >= size_of_lohm_array Then
            lohm_counter = lohm_counter + 1
            ReDim Preserve Lohm_P(size_of_lohm_array + 2000#)
            ReDim Preserve Lohm_F(size_of_lohm_array + 2000#)
            ReDim Preserve Lohm_Val(size_of_lohm_array + 2000#)
            ReDim Preserve Raw_P(size_of_lohm_array + 2000#)
            size_of_lohm_array = size_of_lohm_array + 2000#
            Lohm_P(lohm_counter) = CVP
            Lohm_Val(lohm_counter) = LOHM
            Lohm_F(lohm_counter) = Lohm_Flow
            Raw_P(lohm_counter) = P
        Else
            lohm_counter = lohm_counter + 1
            Lohm_P(lohm_counter) = CVP
            Lohm_Val(lohm_counter) = LOHM
            Lohm_F(lohm_counter) = Lohm_Flow
            Raw_P(lohm_counter) = P
        End If
    End If
    
    Rem new feature to stop test if correction approaching actual pressure
    Rem formula corrected 5-19-05 - it wasn't working properly ever since we changed the meaning of
    Rem CVP when we started using the quadratic lohm formula
    Rem This didn't hurt anything - it just stopped tests from stopping early if there was too much
    Rem flow correction.  All the data was still good (except maybe for data that shouldn't have
    Rem been taken in the first place)
    If P > P0 And Lohm_Flow > 20# Then
        If (1 + (CVP - P0) / (P - P0)) <= 1.2 Then cv_warning_flag = True ' simply set flag for end of test that the sample is possibly too open for the given machine
        If (1 + (CVP - P0) / (P - P0)) <= Lohm_Ratio Then ' if this is negative, correction exceeds sample dP
            CVcalc = CVP
            cv_flag = True    ' this sets a bit more extreme message that the sample is DEFINITELY too open !!
            If V2INCR > 0 Then HKey2$ = "T"   ' have to turn around as the correction is larger than the sample restriction !!!!bad_cv_correction = True
            Exit Function
        End If
    End If
    If CVP < P0 Then
        ' This CAN happen if the lohm value is high, the flow is above 0, and the
        ' pressure has not increased at all or only very little.
        ' let the corrected pressure go only as low as P0 or P, whichever is lower
        ' This will allow a return value less than P0 only if the inital P value
        ' is also less then P0, which will not stop the compensation for a drifting
        ' pressure gauge and a too-high P0 value
        CVP = shortHandIfelse(P0 <= P, P0, P)
    End If
    CVcalc = shortHandIfelse(Disable_CV = True, P, CVP)
End Function

Sub dat_size_check(X As dat_array, s As Long)
    If s <= X.s Then Exit Sub
    X.s = s + 100
    ReDim Preserve X.a(X.s)
End Sub

Sub Diff_Perm_Test()

    Dim p_atm As Single
    Dim T As Single
    Dim tlast As Single
    Dim tstart As Single
    Dim tnext As Single
    Dim curtime As Single
    Dim pcurr As Single
    Dim tcurr As Single
    Dim x1 As Single
    Dim x2 As Single
    Dim fn As Integer, fn2 As Integer
    Dim P0 As Single
    Dim DPatm As Single ' reading of diffpg at atmospheric pressure - used to correct for back pressure
    Dim lasttemp As Single ' last temperature reading
    Dim settle_fail As Boolean
    Dim upped_reg_last_time As Boolean

    RunTimer = Timer
    progress.Timer1.Interval = 2000
    progress.Timer1.Enabled = True
    progress.Label2.Caption = ts$(74) + " - " + ts$(75)       ' "Time - min."
    progress.Picture1.ScaleHeight = PY2(4) - PY1(4)
    progress.Picture1.ScaleWidth = mf_time(current_unit%)
    progress.Picture1.ScaleTop = 0
    progress.Picture1.ScaleLeft = 0
    progress.X_Max.Caption = str$(mf_time(current_unit%))
    progress.Y_Max.Caption = Format$((PY2(4) - PY1(4)) * PCNV, "#0.#####")

    If status_lights_enable Then setStatusLights 2
    If MF_Settle Then
        Move_Valve 2, "O"
        progress.Line25.Caption = ts$(443)      ' "Waiting for microflow pressure to settle"
        Do
            settle_fail = False
            Move_Valve 13, "C" ' close venting valve
            ' wait 5 seconds
            waitseconds 5
            ReadXReturnX4 13 + dpgplus%
            plast = x5
            T = Timer
            Do
                ReadXReturnX4 13 + dpgplus%
                tlast = Timer
                If tlast + 0.1 < T Then T = T - 86400
                progress.Line26 = ts$(229) + ": " + Format$(x5 - plast, "#0.00000") + " PSI,  " + ts$(74) + "=" + Format$(tlast - T, "####0.00")     ' "Pressure"/"time"
                If Abs(x5 - plast) > MF_Settle_pressure Then
                    settle_fail = True
                    Exit Do
                End If
            Loop Until ((tlast - T) >= MF_Settle_time) Or Aborted
            Move_Valve 13, "O" ' open venting valve
            If settle_fail And Not Aborted Then
                progress.Line26.Caption = ts$(444) + " " + Format$(tlast - T, "#####.##") + " " + ts$(445)     ' "Venting and retrying - failure after"/"seconds"
                waitseconds 2
            End If
        Loop While settle_fail And Not Aborted
        tlast = Timer
        While tlast + 0.1 < RunTimer: tlast = tlast + 86400: Wend
        MF_Total_Settling_time = tlast - RunTimer
        progress.Line26.Caption = ts$(446) + " " + Format$(tlast - RunTimer, "##########.##") + " " + ts$(445)          ' "Pressure settled after""seconds"
        Move_Valve 2, "C"
    End If
    progress.Line25.Caption = ts$(70)           ' "Zeroing regulator - please wait."
    'Zero_Reg
    'If ExtraPG Then
    '    Move_Valve 10, "O"
    '    pres% = 2
    'End If
    Move_Valve 10, "C"
    Pres% = 1
    
    ReadXReturnX4 2
    
    p_atm = x5
    progress.Line25.Caption = ts$(71)       ' "Opening valve 2 - please wait."
    OPENV2MOSTLY
    Move_Valve 0, "C"
   
    Dim MF_RegStep As Integer
    MF_RegStep = val(gpps2("Capstuff", "xregstep", CSFile$, "10"))
    
    ' Step up to the holding pressure
    Do
        inc_reg MF_RegStep
        T = Timer
        'While Timer - T < 1: DoEvents: Wend
        waitseconds 1
        
        ReadXReturnX4 2
            
        progress.Line25.Caption = ts$(72) + ": " + Xformat$((x5 - p_atm) * PCNV, "###0.000  ") + PU$    ' "Internal Pressure"
        progress.Refresh
        DoEvents
        If Aborted Then Exit Do
    Loop While (x5 - p_atm) < mf_press(current_unit%)

    fn = FreeFile
    'Open OutFilename$(current_unit%) For Append As #fn
    Open EXE_Path$ + "lastdata.cft" For Append As #fn
    Print #fn, Diff_Volume(manuallySelectedChamber + Current_Microflow_Volume_Index - 1)
    ' 6.71.67
    If dryChamberTemperature <> 0 Then
    'If temperature% > 0 Then
        fn2 = FreeFile
        Open EXE_Path$ + "tempdata.txt" For Output As #fn2
    End If
    ReadXReturnX4 13 + dpgplus%
    plast = x5 - PY1(4)
    DPatm = plast ' remember the pressure reading before we close valve 14
    Move_Valve 13, "C"
    ' new: if closing of valve 14 caused the pressure to drop,
    ' wait until pressure has risen back up again
    Do
        DoEvents
        ReadXReturnX4 13 + dpgplus%
        pcurr = x5 - PY1(4)
        If pcurr < plast Then plast = pcurr
        If x4 < 100 Then pcurr = plast
    Loop Until (pcurr > plast) Or (HKey$ = "A")
    P0 = pcurr
    plast = pcurr - P0
    If dryChamberTemperature <> 0 Then
    'If temperature% > 0 Then
        'If temperature% > 1 Then
        '    ReadXReturnX4 30
        'Else
        '    ReadXReturnX4 27
        'End If
        lasttemp = readNewTemperature(dryChamberTemperature)
    End If
    ReadXReturnX4 2

    ' Record to main data file
    'If (temperature% <= 0 Or Not MF_recordTemperature) Then
    If (dryChamberTemperature = 0 Or Not MF_recordTemperature) Then
        Print #fn, "0,"; x5 - p_atm; ","; plast
    Else ' There is a temperature probe and user wants to record data
        Print #fn, "0,"; x5 - p_atm; ","; plast; ","; lasttemp
    End If
    ' Record to tempdata file
    'If temperature% > 0 Then Print #fn2, "0"; vbTab; x5 - p_atm; vbTab; plast; vbTab; lasttemp
    If dryChamberTemperature <> 0 Then Print #fn2, "0"; vbTab; x5 - p_atm; vbTab; plast; vbTab; lasttemp
    
    tlast = 0
    tstart = Timer
    tnext = tstart
    curtime = tstart
    upped_reg_last_time = False
    While ((curtime - tstart) < mf_time(current_unit%) * 60) And (HKey$ <> "A")
        While (curtime - tnext < Step_Time(current_unit%) * 60) And HKey$ <> "A"
            Rem read and update graph
            ReadXReturnX4 13 + dpgplus%
            pcurr = x5 - PY1(4) - P0
            If pcurr > PY2(4) - PY1(4) - P0 Then HKey$ = "A"
            If tstart > curtime + 0.1 Then tstart = tstart - 86400
            tcurr = (curtime - tstart) / 60
            'If temperature% > 0 Then
            '    If temperature% > 1 Then
            '        ReadXReturnX4 30
            '    Else
            '        ReadXReturnX4 27
            '    End If
            If dryChamberTemperature <> 0 Then lasttemp = readNewTemperature(dryChamberTemperature)
            
            ReadXReturnX4 2
            
            ' correct internal reading by the back pressure
            x5 = x5 - (pcurr + P0 - DPatm)
            progress.Line25.Caption = ts$(72) + ": " + Xformat$((x5 - p_atm) * PCNV, "###0.000  ") + PU$ + "  " + ts$(73) + ": " + Xformat$(pcurr * PCNV, "###0.000  ") + PU$ + "  " + ts$(75) + ": " + Format$(tcurr, "#####0.00 ") + ts$(74) ' "Internal Pressure"/"External Pressure"/"Time"/"min."
            progress.Line25.Refresh
            x1 = PY2(4) - PY1(4) - P0 - plast
            x2 = PY2(4) - PY1(4) - P0 - pcurr
            If x1 < 0 Then x1 = 0
            If x2 < 0 Then x2 = 0
            'If x2 < x1 And tcurr > tlast Then
            If tcurr > tlast Then
                progress.Picture1.Line (tlast, x1)-(tcurr, x2), RGB(255, 0, 255)
                plast = pcurr
                tlast = tcurr
            End If
            DoEvents
            If (x5 - p_atm) < mf_press(current_unit%) And microflowregulator Then
                If upped_reg_last_time Then
                    inc_reg 2
                Else
                    inc_reg 1 ' was 10
                End If
                upped_reg_last_time = True
            Else
                upped_reg_last_time = False
            End If
            curtime = Timer
            If tnext > curtime + 0.1 Then tnext = tnext - 86400
        Wend
        Rem store data point
        'If temperature% > 0 And MF_recordTemperature Then
        If dryChamberTemperature <> 0 And MF_recordTemperature Then
            Print #fn, tcurr; ","; x5 - p_atm; ","; plast; ","; lasttemp
        Else
            Print #fn, tcurr; ","; x5 - p_atm; ","; plast
        End If
        'If temperature% > 0 Then
        If dryChamberTemperature <> 0 Then Print #fn2, tcurr; vbTab; x5 - p_atm; vbTab; plast; vbTab; lasttemp
        tnext = tnext + Step_Time(current_unit%) * 60
        curtime = Timer
        If tstart > curtime + 0.1 Then tstart = tstart - 86400
    Wend
    Rem all done

    Print #fn, "0,0"
    If MF_linearSeal Then
        If MF_sealDiam > 0 Then
            Print #fn, "s" + Format$(3.14159265 * MF_sealDiam)   ' CapRep expects circumference, not diameter
        ElseIf MF_innerDiam > 0 Then
            Print #fn, "id" + Format$(MF_innerDiam)             ' This is in diameter, not circumference!
            Print #fn, "od" + Format$(MF_outerDiam)             ' This is in diameter, not circumference!
        End If
    End If
    Close #fn
    If dryChamberTemperature <> 0 Then
    'If temperature% > 0 Then
        Close #fn2
    End If
    
    ' before we do this, we want to vent the system backwards until the pressure
    ' in the system is back to atmospheric pressure
    HKey$ = "" ' turn off abort signal if they gave it.  They will have to re-abort to cancel this
    Do
        ReadXReturnX4 13 + dpgplus%
        plast = x5 - PY1(4) - P0 - DPatm
        ReadXReturnX4 2
        If (x5 - p_atm) > plast Then ' if we are still above the bottom pressure, lower faster
            lower_reg 10
        ElseIf (x5 - p_atm) > plast - mf_press(current_unit%) Then
            lower_reg 1
        Else
            inc_reg 1
        End If
        DoEvents
        progress.Line25.Caption = ts$(72) + ": " + Xformat$((x5 - p_atm) * PCNV, "###0.000  ") + PU$ + "  " + ts$(73) + ": " + Xformat$(plast * PCNV, "###0.000  ") + PU$ + " " + ts$(447)  ' "Venting Slowly - please wait"
        progress.Line25.Refresh
    Loop Until (((plast - DPatm) < mf_press(current_unit%)) And (REGPOS <= 0)) Or (HKey$ = "A") Or ((x5 - p_atm) <= 0)
    Zero_Reg
    Move_Valve 2, "O"
    Move_Valve 13, "O"
    If ExtraPG Then
        Move_Valve 10, "O"
        Pres% = 2
    End If
    excercize_valve_2
    Move_Valve 2, "C"

    If autocompress Or autopiston Then
        If safetyup And Vpos(15) = 1 Then
            If safetyupdoor Then
                ' do auto door switch thing instead of key press thing
                check_safety_door False
            Else
                safetykeypress.mainlabel.Caption = ts$(166)             ' "Piston About To Raise"
                safetykeypress.cancelbutton.Visible = False
                safetykeypress.Show 1, progress
            End If
        End If
        move_piston "C"
    End If
    If status_lights_enable Then setStatusLights 1
    
    MsgBox ts$(76), 0, ts$(77)               ' "Test Finished, Remove Sample"
    do_final_copy
    'FileCopy EXE_Path$ + "lastdata.cft", OutFilename$(current_unit%)

End Sub

Sub excercize_valve_2()

    Dim times_tried_closing_valve%
    Dim k As Single
    Dim T As Single
    Dim local_time As Single
    Dim vtarg As Long
    Dim NCLIMIT As Long
    Dim x4v2 As Long
    
    ' open valve 1 while doing this
    Move_Valve 0, "O" ' This will help clear out any residual high pressure trapped between valve 1 and the needle valve
    If low_flow_controller Then set_lfctrl 4000
    If nov2 Then
        Move_Valve 0, "C"
        If low_flow_controller Then zero_lfctrl
        Exit Sub
    End If
    
    If v2solenoid Then
        ' this has to be version 6 machine
        ' just close valve 2
        Send_RS232 ("C" + mv1_index_char)
        ' close valve 1 after closing valve 2
        Move_Valve 0, "C"
        If low_flow_controller Then zero_lfctrl
        Exit Sub
    End If
    
    'Rem move valve 2 to 4500 to make sure it works
    ' now just move valve to 500 greater than its close limit
    ' make sure to open valve to at least SV2P+200
    ' we want to make sure that v2 has opened enough to let any
    ' residual pressure bleed out before starting the test
    times_tried_closing_valve% = 0
    motorValveIndex = 0
    
retry_closing_valve_1:
    times_tried_closing_valve% = times_tried_closing_valve% + 1

    Send_RS232 ("O" + mv1_index_char)

    ReadXReturnX4 3
    DoEvents
    ' 500 counts is 1/40 of a 20000 span
    vtarg = cLimit + DAC_span / 40
    ' 200 counts is 1/100 of a 20000 span
    If vtarg < SV2P + DAC_span / 100 Then vtarg = SV2P + DAC_span / 100
    If x4 < vtarg And PA <> 0 Then
        Do
            Send_RS232 ("O" + mv1_index_char)
            ReadXReturnX4 3
            DoEvents
        Loop While x4 < cLimit + 500
    End If
    
    Send_RS232 ("S" + mv1_index_char)
    
    waitseconds 2
    DoEvents

    Send_RS232 ("C" + mv1_index_char)

    ' set NCLIMIT one higher than the close limit can possibly read
    NCLIMIT = DAC_over + 1
    T = Timer

    Do
        ReadXReturnX4 3
        local_time = Timer
        If x4 < NCLIMIT Then NCLIMIT = x4: T = local_time
        If local_time + 0.1 < T Then T = T - 86400!
        DoEvents
    Loop While local_time - T < 1
    NCLIMIT = NCLIMIT + 1

    ' 10 counts is 1/2000 of the span
    If NCLIMIT > (cLimit + DAC_span / 2000) Then
        If times_tried_closing_valve% < 4 Then
            GoTo retry_closing_valve_1
        End If
        If Not ignoreMVErrors Then
            Beep
            MsgBox "MV1" + vbCrLf + ts$(78) + vbCrLf + ts$(79), 0, "CapWin"         ' "The motorized valve needs to be calibrated."/
            Aborted = True                              'abort test added 5/26/93 JP, v6.52.04
        End If
    End If
    
    If hasMultipleMVs Then
        times_tried_closing_valve% = 0
        motorValveIndex = 1
        
retry_closing_valve_2:
        times_tried_closing_valve% = times_tried_closing_valve% + 1
        
        Send_RS232 ("O" + mv2_index_char)
        ReadXReturnX4 3
        DoEvents
        vtarg = CLIMIT2 + DAC_span / 40
        ' 200 counts is 1/100 of a 20000 span
        If vtarg < SV2P + DAC_span / 100 Then vtarg = SV2P + DAC_span / 100
        If x4 < vtarg And PA <> 0 Then
            Do
                ReadXReturnX4 3
                DoEvents
            Loop While x4 < vtarg
        End If
        
        Send_RS232 ("S" + mv2_index_char)
        waitseconds 2
        DoEvents
        Send_RS232 ("C" + mv2_index_char)
    
        ' set NCLIMIT one higher than the close limit can possibly read
        NCLIMIT = DAC_over + 1
        T = Timer
    
        Do
            ReadXReturnX4 3
            local_time = Timer
            If x4 < NCLIMIT Then NCLIMIT = x4: T = local_time
            If local_time + 0.1 < T Then T = T - 86400!
            DoEvents
        Loop While local_time - T < 1
        NCLIMIT = NCLIMIT + 1
    
        ' 10 counts is 1/2000 of the span
        If NCLIMIT > (CLIMIT2 + DAC_span / 2000) Then
            If times_tried_closing_valve% < 4 Then
                GoTo retry_closing_valve_2
            End If
            If Not ignoreMVErrors Then
                Beep
                MsgBox "MV2" + vbCrLf + ts$(78) + vbCrLf + ts$(79), 0, "CapWin"         ' "The motorized valve needs to be calibrated."/
                Aborted = True                              'abort test added 5/26/93 JP, v6.52.04
            End If
        End If
        
        If numberOfMotorValves = 3 Then
            times_tried_closing_valve% = 0
            motorValveIndex = 2
            
retry_closing_valve_3:
            times_tried_closing_valve% = times_tried_closing_valve% + 1
            
            Send_RS232 ("O" + mv3_index_char)
            ReadXReturnX4 3
            DoEvents
            vtarg = CLIMIT3 + DAC_span / 40
            ' 200 counts is 1/100 of a 20000 span
            If vtarg < SV2P + DAC_span / 100 Then vtarg = SV2P + DAC_span / 100
            If x4 < vtarg And PA <> 0 Then
                Do
                    ReadXReturnX4 3
                    DoEvents
                Loop While x4 < vtarg
            End If
            
            Send_RS232 ("S" + mv3_index_char)
            waitseconds 2
            DoEvents
            Send_RS232 ("C" + mv3_index_char)
        
            ' set NCLIMIT one higher than the close limit can possibly read
            NCLIMIT = DAC_over + 1
            T = Timer
        
            Do
                ReadXReturnX4 3
                local_time = Timer
                If x4 < NCLIMIT Then NCLIMIT = x4: T = local_time
                If local_time + 0.1 < T Then T = T - 86400!
                DoEvents
            Loop While local_time - T < 1
            NCLIMIT = NCLIMIT + 1
        
            ' 10 counts is 1/2000 of the span
            If NCLIMIT > (CLIMIT3 + DAC_span / 2000) Then
                If times_tried_closing_valve% < 4 Then
                    GoTo retry_closing_valve_3
                End If
                If Not ignoreMVErrors Then
                    Beep
                    MsgBox "MV3" + vbCrLf + ts$(78) + vbCrLf + ts$(79), 0, "CapWin"         ' "The motorized valve needs to be calibrated."/
                    Aborted = True                              'abort test added 5/26/93 JP, v6.52.04
                End If
            End If
        End If
    End If
    
    Move_Valve 0, "C" ' close valve 1 when all done
    If low_flow_controller Then zero_lfctrl
    
End Sub

Function file_copy(new_user$, file_name$) As Boolean

    Dim f1 As Integer, f2 As Integer, a$

    f1 = -1
    f2 = -1
    On Error GoTo bad_copy
    f1 = FreeFile
    Open EXE_Path$ + "users\" + Curr_U$ + "\" + file_name$ For Input As f1
    f2 = FreeFile
    Open EXE_Path$ + "users\" + new_user$ + "\" + file_name$ For Output As f2
    While Not EOF(f1)
        Line Input #f1, a$
        Print #f2, a$
    Wend
    Close #f1
    Close #f2
    file_copy = False
    On Error GoTo 0 'added by HDS 6/4/99
    Exit Function
bad_copy:
    Resume bad_copy2
bad_copy2:
    If f1 >= 0 Then Close #f1
    If f2 >= 0 Then Close #f2
    file_copy = True
    On Error GoTo 0 'added by HDS 6/4/99

End Function
Function find_volume(i%)

    Dim t0 As Single
    Dim curtime As Single
    Dim lasttime As Single
    Dim lastpulse As Single
    Dim sum#
    Dim f0 As Single
    Dim fmin As Single
    Dim fmax As Single
    Dim flowchannum As Integer
    Dim flowtarget As Single

    If PA = 0 Then
        find_volume = i% * 100
        Exit Function
    End If
    
    Move_Valve 2, "O"
    Move_Valve 13, "O"
    'excercize_valve_2
    Init_System
    Move_Valve 10, "C" ' init_system will open valve 11, and we want to leave it closed
    If microflow_extraChamber Then Dry_Chamber_Control "C" ' special case - second microflow chamber
            ' requires that valve 4 is set as if it is for the liquid permeability to shut off
            ' the primary air chamber.
    ' wait for stable reading on low flow meter
    Msgform.cancel.Visible = False
    Msgform.lb.Visible = False
    Msgform.ok.Visible = True
    Msgform.ok.Caption = ts$(80)            ' "Force"
    Msgform.Label1.Visible = True
    
    If GasPerm Then
        Msgform.Label1.Caption = ts$(81)    ' "Waiting for flow meter to stabilize"
        flowchannum = 1
        HFLOW% = 1 ' low range of lowest high flow meter
        flowtarget = 50
    Else
        Msgform.Label1.Caption = ts$(82)    ' "Waiting for low flow meter to stabilize"
        flowchannum = 0
        flowtarget = BUBLFLOW
    End If
    
    Msgform.Label.Caption = ""
    Msgform.Show 0
    Msgform.ok.SetFocus
    Msgform.Refresh
    t0 = Timer
    ReadXReturnX4 flowchannum
    f0 = x5
    fmin = f0
    fmax = f0
    
    Do
        DoEvents
        ReadXReturnX4 flowchannum
        f0 = x5
        Msgform.Label.Caption = Format$(f0, "##0.0000") + " cc/min"
        Msgform.Refresh
        If f0 < fmin Then
            fmin = f0
            t0 = Timer
        ElseIf f0 > fmax Then
            fmax = f0
            t0 = Timer
        End If
        curtime = Timer
        If curtime + 0.1 < t0 Then t0 = t0 - 86400
    Loop Until Msgform.ok.Visible = False Or (curtime - t0) > 15
    
    Pres% = 1
    ReadXReturnX4 2

    P0 = x5
    Msgform.cancel.Visible = False
    Msgform.lb.Visible = False
    Msgform.ok.Visible = True
    Msgform.ok.Caption = ts$(84)        ' "Record"
    Msgform.Label1.Visible = True
    If Num_Microflow_Volumes > 1 Then
        Msgform.Label1.Caption = ts$(85) + " " + Format$(i%) + "-" + Format$(Current_Microflow_Volume_Index)
    Else
        Msgform.Label1.Caption = ts$(85) + " " + str$(i%)   ' "Calculating volumes - part"
    End If
    Msgform.Label.Caption = ""
    Msgform.Show 0
    Msgform.ok.SetFocus
    Msgform.Refresh
    
    If Not GasPerm Then
        Move_Valve 0, "O"
        If low_flow_controller Then
            ' leave the venting valve open until the flow meter stabilizes
            ' low_flow_controller always means airtop and ip_reg
            move_motorized_regulator_to_pressure 14.7 + max_bp_pres_dif
            zero_lfctrl
            ' new for bd
            set_low_flow_rate 2 ' just to make sure it goes up
            ' wait for flow to go above 1 cc/min (it should, given our increase in pressure)
            t0 = Timer
            Do
                ReadXReturnX4 flowchannum
                Msgform.Label.Caption = "1: " + Xformat$(x5 - f0, "###.###")
                If Timer + 0.01 < t0 Then t0 = t0 - 86400
            Loop While (Timer - t0) < 30 And (x5 - f0) < 1
            ' wait for flow to go below 0.5 cc/min as it comes back down
            zero_lfctrl ' new for bd
            t0 = Timer
            Do
                ReadXReturnX4 flowchannum
                Msgform.Label.Caption = "2: " + Xformat$(x5 - f0, "###.###")
                If Timer + 0.01 < t0 Then t0 = t0 - 86400
            Loop While (Timer - t0) < 300 And (x5 - f0) > 0.5
            set_low_flow_rate flowtarget
            ' wait for flow to get to 80% of flow target
            t0 = Timer
            Do
                ReadXReturnX4 flowchannum
                Msgform.Label.Caption = "3: " + Xformat$(x5 - f0, "###.###")
                If Timer + 0.01 < t0 Then t0 = t0 - 86400
            Loop While (Timer - t0) < 300 And (x5 - f0) < flowtarget * 0.8
            ' show the flow for 5 more seconds
            t0 = Timer
            Do
                ReadXReturnX4 flowchannum
                Msgform.Label.Caption = "4: " + Xformat$(x5 - f0, "###.###")
                If Timer + 0.01 < t0 Then t0 = t0 - 86400
            Loop While (Timer - t0) < 5
            ' close the venting valve
            Move_Valve 2, "C"
        End If
    End If
    
    If GasPerm Or Not low_flow_controller Then
        If REGPOS < 0 Then REGPOS = 0
        
        ' we haven't already raised the pressure, so do it now
        If newreg Then
            reg_goto SBPP
        ElseIf ip_reg_enable Then
            ' increase pressure to at least 4 atmospheres or all the way, whichever is lower
            move_motorized_regulator_to_pressure 4 * 14.7
        Else
            While REGPOS < SBPP: inc_reg 10: Wend   '  initial pressure
        End If
    End If
        
    If GasPerm Then
        Rem pulse open valve 2 until we see at least 50 cc/min flow
        Do
            Pulse_V2 0
            ReadXReturnX4 flowchannum
        Loop Until (x5 - f0) > 50
    End If
    
    t0 = Timer
    lasttime = 0
    lastpulse = 0
    Move_Valve 2, "C"
    If i% = 2 Then Move_Valve 13, "C"
    sum# = 0
    Do
        DoEvents
        curtime = Timer
        While curtime + 0.1 < t0
            t0 = t0 - 86400
        Wend
        If (curtime - t0) > lasttime Then
            ReadXReturnX4 flowchannum
            sum# = sum# + (x5 - f0) * (curtime - t0 - lasttime) / 60
            lasttime = curtime - t0
            If (x5 - f0) < flowtarget And (curtime - t0 - lastpulse) > 1 Then
                inc_reg 10
                lastpulse = curtime - t0
            End If
        End If
        ReadXReturnX4 2

        If x5 > P0 Then
          Msgform.Label.Caption = Format$((x5 - P0) / P0 * 100, "##0.0") + "%  " + Format$(sum#, "###0.00") + "cc = " + Format$(sum# / ((x5 - P0) / P0), "###0.00") + " cc"
        Else
          Msgform.Label.Caption = ts$(86)       ' "Pressure has not gone up yet - possible leak"
        End If
        Msgform.Refresh
    Rem 1.25 changed to 2 in following line for test for bruce
    Loop Until x5 >= P0 * 1.25 Or Msgform.ok.Visible = False
    sum# = sum# / ((x5 - P0) / P0)
    Zero_Reg
    Move_Valve 2, "O"
    Move_Valve 13, "O"
    Move_Valve 10, "C"
    If GasPerm Then
        ' close valve 2 all the way
        Send_RS232 ("C" + mv1_index_char)
    Else
        Move_Valve 0, "C"
        If low_flow_controller Then zero_lfctrl
        If AirTop Then Move_Valve 2, "O"
    End If
    Unload Msgform
    find_volume = sum#
    
End Function

Function flowformat$(f)

    If f <= 10 Then
        flowformat$ = Xformat$(f, "##0.0000")
    ElseIf f <= 100 Then
        flowformat$ = Xformat$(f, "###0.000")
    ElseIf f <= 1000 Then
        flowformat$ = Xformat$(f, "####0.00")
    ElseIf f <= 10000 Then
        flowformat$ = Xformat$(f, "#####0.0")
    Else
        flowformat$ = Xformat$(f, "######0.")
    End If

End Function

'Function FrazierAnalysis() As Single
'    Dim R As Integer
'    Dim interpFlow!, SampleArea!, conversion_number!
'
'    If UBound(TDat_Press) < 2 Then
'        slope = (TDat_Flow(1) - TDat_Flow(0)) / (TDat_Press(1) - TDat_Press(0))
'        intercept = TDat_Flow(1) - slope * TDat_Press(1)
'    Else
'        R = LinRegres(UBound(TDat_Press) + 1, LBound(TDat_Press), TDat_Press(), TDat_Flow())
'        slope = Slope2
'        intercept = 0
'    End If
'
'    If R <> 0 Then GoTo ErrorReg
'
'    interpFlow! = slope * (FrazierPress) + intercept
'    SampleArea! = pi * (Diam(current_unit%) ^ 2) / 4
'    SampleArea! = SampleArea! * (1 / (2.54 ^ 2)) * (1 / (12 ^ 2))
'
'    conversion_number! = 60 * 3.53146667215E-05
'
'    FrazierAnalysis = interpFlow! * conversion_number! / SampleArea!
'
'    Exit Function
'
'ErrorReg:
'    MsgBox "Unable to manipulate sample data.  Check your data file."
'End Function

Sub Get_Capstuff()

    Dim Ret$, i As Long, temp$, unit%, feature%
    Dim f_liq_perm As Boolean   ' local if feature calls for liquid permeability
    Dim f_low_pres As Boolean   ' local if feature calls for low pressure gauge
    Dim f_diff_pg As Boolean    ' local if feature calls for microflow
    Dim f_auto_fill As Boolean  ' local if feature calls for autofill
    Dim j As Integer, k As Integer
    ' now global
    'Dim microflowporometer As Boolean ' local to determine machine name in special case
    ' 6.71.67
    Dim temperature% ' local for use in automatically updating to new temperature configuration
    Dim watlow_com_number As Integer ' local for use in updating

    ' feature% is local to this subroutine since the mapping
    ' differs depending on the hardware version
    ' It is stored in the global capwin_feature_number for comparison purposes only
    ' Don't use any of the bits in capwin_feature_number to determine what features
    ' are actually present, only use it to compare with the feature number read from
    ' the instrument.

    Ret$ = String$(255, " ")
    '** VERSION and feature number decode
    i = GPPS("Capstuff", "VERSION", "6.0", Ret$, 255, CSFile$)
    version = val(Ret$)
    If version < 7 Then
        ver2or3 = 2
        ver1or2 = 1
        ver1or3 = 1
        ver1or20 = 1
    Else
        ver2or3 = 3
        ver1or2 = 2
        ver1or3 = 3
        ver1or20 = 20
    End If

    ' feature number for version 6
    i = GPPS("Capstuff", "Feature", "0", Ret$, 255, CSFile$)
    feature% = val(Ret$)
    
    capwin_feature_number = feature%
    ' xhflow is the first bit in both 6 and 7
    xhflow = ((feature% And 1) = 1)

    If version < 7 Then
        ' 1 in 20,000 converter
        DAC_under = 1
        DAC_zero = 500
        DAC_span = 20000
        DAC_two = 20500
        DAC_over = 23000
    Else
        ' 1 in 60,000 converter
        DAC_under = 0
        DAC_zero = 2000
        DAC_span = 60000
        DAC_two = 62000
        DAC_over = 65535
    End If
    
    Rem process feature numbers
    autopiston = False ' default - this is a new special thing
    FrazierPiston = False

    ' common feature bits for both hardware 6 and 7:
    f_low_pres = ((feature% And 2) = 2)
    integrity = ((feature% And 4) = 4)
    ' liquid permeability if 8 or 16 or both
    f_liq_perm = ((feature% And 24) <> 0)
    ' drain12 if 16 is on
    Drain12 = ((feature% And 16) = 16)
    ' there is an offset if there is a diffpg gauge
    dpgplus% = 16
    ' feature bits that are different in 6 and 7:
    If version < 7 Then
        ' drain12 is motorized if both 8 and 16
        Drain12Motorized = ((feature% And 24) = 24)
        ' newreg is true only for motorized regulators
        newreg = ((feature% And 32) = 0)
        auxin = ((feature% And 64) = 64)
        f_diff_pg = ((feature% And 128) = 128)
        v2solenoid = ((feature% And 256) = 256)
        autocompress = ((feature% And 512) = 512)
        dualregulator = ((feature% And 1024) = 1024)
        ip_reg_enable = ((feature% And 2048) = 2048)
        ' can't have both motorized regulator and i/p regulator
        If ip_reg_enable Then newreg = False
        low_flow_controller = False
        ip_creg_enable = False
        f_auto_fill = False
    Else
        ' no motorized regulator in version 7
        newreg = False
        ' drain12 is never motorized in version 7
        Drain12Motorized = False
        ' no aux input (yet) in version 7)
        f_diff_pg = ((feature% And 32) = 32)
        v2solenoid = ((feature% And 64) = 64)
        autocompress = ((feature% And 128) = 128)
        dualregulator = ((feature% And 256) = 256)
        f_auto_fill = ((feature% And 512) = 512)
        auxin = ((feature% And 1024) = 1024)
        ' i/p converter is always enabled in version 7
        ip_reg_enable = True
        low_flow_controller = True ' this may get turned off if there is no low flow meter at all
        TitleScrn.commdebugmenu.Visible = True
        ip_creg_enable = True ' this may be set false for special cases
        If gpps2("Capstuff", "motorized_compression_regulator", CSFile$, "N") = "Y" Then
            ip_creg_enable = False
        End If
    End If
Dim asdf$

i = GPPS("Capstuff", "AIRRESISTIVITY", "N", Ret$, 255, CSFile$)
AirResistivity = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")

i = GPPS("Capstuff", "FLUIDSENSOR", "N", Ret$, 255, CSFile$)
fluidsensor = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")

'GEOPORE STUFF
i = GPPS("Capstuff", "GeoPoreValve", "N", Ret$, 255, CSFile$)
geoPoreValve = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
If geoPoreValve Then
    i = GPPS("Capstuff", "GeoFlowMeterSwitch", "N", Ret$, 255, CSFile$)
    geoFlowMeterSwitch = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    
    i = GPPS("Capstuff", "GeoValveStopPercent", "17.1", Ret$, 255, CSFile$)
    closedPercent = CDbl(nulltrim(Ret$))
    i = GPPS("Capstuff", "GeoExtraValve", "6", Ret$, 255, CSFile$)
    
    Dim splitArray1$(), theItem1%, iq1%
    splitArray1$ = split(Ret$, ",")
    ReDim GeoExtraValve(UBound(splitArray1$))
    
        For iq1% = 0 To UBound(splitArray1)
            theItem1% = CInt(splitArray1(iq1%))
            GeoExtraValve(iq1%) = theItem1% - 1
        Next iq1%
        
    'GeoExtraValve = CInt(nulltrim(Ret$)) - 1
    i = GPPS("Capstuff", "GeoFlow", "120000", Ret$, 255, CSFile$)
    geoFlow = CLng(nulltrim(Ret$)) ' jglann
End If

i = GPPS("Capstuff", "TempProbe", "N", Ret$, 255, CSFile$)
If (Left$(UCase$(LTrim$(Ret$)), 1) = "Y") Then
    tempProbe = True
    i = GPPS("Capstuff", "TempProbeMinC", "2000", Ret$, 255, CSFile$)
    tempProbeMinC = CLng(nulltrim(Ret$))
    i = GPPS("Capstuff", "TempProbeMaxC", "60000", Ret$, 255, CSFile$)
    tempProbeMaxC = CLng(nulltrim(Ret$))
    i = GPPS("Capstuff", "TempProbeMinV", "0", Ret$, 255, CSFile$)
    tempProbeMinV = CLng(nulltrim(Ret$))
    i = GPPS("Capstuff", "TempProbeMaxV", "200", Ret$, 255, CSFile$)
    tempProbeMaxV = CLng(nulltrim(Ret$))
    i = GPPS("Capstuff", "TempProbeChannel", "27", Ret$, 255, CSFile$)
    tempProbeChannel = CInt(nulltrim(Ret$))
    i = GPPS("Capstuff", "TempProbeLabel", "F", Ret$, 255, CSFile$)
    tempProbeLabel = nulltrim(Ret$)
Else
    tempProbe = False
End If
Ret$ = String$(255, " ")
i = GPPS(Curr_U$, "BPPostPurge", "N", Ret$, 255, IFile$)
If (Left$(UCase$(LTrim$(Ret$)), 1) = "Y") Then
    BPPostPurge = True
Else
    BPPostPurge = False
End If

i = GPPS(Curr_U$, "BPPostPurgeDuration", "20", Ret$, 255, IFile$)
    BPPostPurgeDuration = CInt(nulltrim(Ret$))
    
'adds support for latching valves (which are backwards!) values
'should be comma seperated

i = GPPS("Capstuff", "LatchingValves", "0", Ret$, 255, CSFile$)

Select Case nulltrim(Ret$)
    Case "0"
        LatchValves = False
    Case Else
        LatchValves = True
        Dim splitArray$(), theItem%, iq%

        splitArray = split(Ret$, ",")
        For iq% = 0 To UBound(splitArray)
            theItem% = CInt(splitArray(iq%))
            LatchingValves(theItem% - 1) = True
        Next iq%
End Select


' now read in things that have to be set first because they
' can affect or be affected by other things:
    
    ' hydrohead determination must be before low flow range
    ' because if there is no low flow meter this will turn
    ' off the hydrohead

    i = GPPS("Capstuff", "HydroHead", "N", Ret$, 255, CSFile$)
    If Left$(UCase$(LTrim$(Ret$)), 1) = "Y" Then
        hydrohead = True
' 6.71.38x begin
        hydrohead_exclusive = False
        burst = False
    ElseIf Left$(UCase$(LTrim$(Ret$)), 1) = "E" Then
        hydrohead = True
        hydrohead_exclusive = True
        burst = False
    ElseIf Left$(UCase$(LTrim$(Ret$)), 1) = "B" Then
        hydrohead = False ' changed to False, you cannot have hydrohead and burst at the same time - surik
        hydrohead_exclusive = False
        burst = True
    Else
        hydrohead = False
        hydrohead_exclusive = False
        burst = False
' 6.71.38x end
    End If
    
    If hydrohead Then
        i = GPPS("Capstuff", "HHDrain12", "N", Ret$, 255, CSFile$)
        If Left$(UCase$(LTrim$(Ret$)), 1) = "Y" Then
            Drain12 = True
        End If
        
        i = GPPS("Capstuff", "Mullen", "N", Ret$, 255, CSFile$)
        If Left$(UCase$(LTrim$(Ret$)), 1) = "Y" Then
            mullen = True
        Else
            mullen = False
        End If
    End If
    
    i = GPPS("Capstuff", "SkipV2Limits", "N", Ret$, 255, CSFile$)
    skipLimits = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    
    i = GPPS("Capstuff", "ShowEndPassCause", "N", Ret$, 255, CSFile$)
    If Left$(UCase$(LTrim$(Ret$)), 1) = "Y" Then
        showEndPassCause = True
    Else
        showEndPassCause = False
    End If
        
    ' low flow range can set gas permeability (if no low flow meter)
    ' and can also be a verification of the integrity flow meter
    ' (if the low range is >= the high range)
    '**low flow high
    i = GPPS("Capstuff", "FX1_00", str$(DAC_zero), Ret$, 255, CSFile$)
    FX1(0, 0) = val(Ret$)
    i = GPPS("Capstuff", "FX2_00", str$(DAC_two), Ret$, 255, CSFile$)
    FX2(0, 0) = val(Ret$)
    i = GPPS("Capstuff", "FY1_00", "0", Ret$, 255, CSFile$)
    FY1(0, 0) = val(Ret$)
    i = GPPS("Capstuff", "FY2_00", "30", Ret$, 255, CSFile$)
    FY2(0, 0) = val(Ret$)
    
    If FY2(0, 0) = 0 Then
        GasPerm = True ' no low flow meter means this is a gas permeameter
        low_flow_controller = False
        hydrohead = False ' can't do hydrohead without a low flow meter
        'TitleScrn.Extra_Low.Visible = False
        TitleScrn.calibmenu(8).Visible = False
    End If
    '** low flow low
    i = GPPS("Capstuff", "FX1_01", str$(DAC_zero), Ret$, 255, CSFile$)
    FX1(0, 1) = val(Ret$)
    i = GPPS("Capstuff", "FX2_01", str$(DAC_two), Ret$, 255, CSFile$)
    FX2(0, 1) = val(Ret$)
    i = GPPS("Capstuff", "FY1_01", "0", Ret$, 255, CSFile$)
    FY1(0, 1) = val(Ret$)
    i = GPPS("Capstuff", "FY2_01", "12", Ret$, 255, CSFile$)
    FY2(0, 1) = val(Ret$)
    If low_flow_controller Then
        i = GPPS("Capstuff", "max_bp_pres_dif", "0", Ret$, 255, CSFile$)
        max_bp_pres_dif = val(Ret$)
        If max_bp_pres_dif <= 0 Then
            WPPS "Capstuff", "max_bp_pres_dif", "20", CSFile$
            max_bp_pres_dif = 20
        End If
        i = GPPS("Capstuff", "reverse_flow_controller", "-1", Ret$, 255, CSFile$)
        reverse_flow_controller = (val(Ret$) = 1)
        If val(Ret$) = -1 Then
            WPPS "Capstuff", "reverse_flow_controller", "0", CSFile$
        End If
    End If
    
    ' check integrity with feature value
    ' this can change the integrity boolean
    If FY2(0, 0) * 0.5 <= FY2(0, 1) Then
        If Not integrity Then
            MsgBox "Warning:  Feature number mismatch with Integrity flow meter setting"
            integrity = True
        End If
    Else
        ' for version 7 and higher, feature number always trumps fy2 value
        If integrity And version < 7 Then
            MsgBox "Warning:  Feature number mismatch with Integrity flow meter setting"
            integrity = False
        End If
    End If
    
    i = GPPS("Capstuff", "PENZERO", str$(DAC_zero), Ret$, 255, CSFile$)
    PENZERO = val(Ret$)
    
    i = GPPS("Capstuff", "PENTWO", str$(DAC_two), Ret$, 255, CSFile$)
    PENTWO = val(Ret$)
    
    PENSPAN = PENTWO - PENZERO

    i = GPPS("Capstuff", "P2PENZERO", str$(DAC_zero), Ret$, 255, CSFile$)
    P2PENZERO = val(Ret$)
    
    i = GPPS("Capstuff", "P2PENTWO", str$(DAC_two), Ret$, 255, CSFile$)
    P2PENTWO = val(Ret$)
    
    P2PENSPAN = P2PENTWO - P2PENZERO


    GPPS "Capstuff", "DisableSpanAdjustments", "N", Ret$, 255, CSFile$
    disableSpanAdjustments = (nulltrim(Ret$) = "Y")

    i = GPPS("Capstuff", "FrazierTester", "N", Ret$, 255, CSFile$)
    FrazierTester = IIf(nulltrim(Ret$) = "Y", True, False)
        ' Load purge routine options
    showPurgeOption = IIf(gpps2("Capstuff", "show_purge_option", CSFile$, "N") = "Y", True, False)
    purgeStopCounts = val(gpps2("Capstuff", "purge_stop_counts", CSFile$, "5000"))
    
    ' Load remap options - Mix
    Remap = gpps2("Capstuff", "Remap", CSFile$, "V1:V1")
    UseRemap = IIf(gpps2("Capstuff", "UseRemap", CSFile$, "N") = "Y", True, False)
    ShowRemapOption = IIf(gpps2("Capstuff", "ShowRemapOption", CSFile$, "N") = "Y", True, False)
    RemapOptionCaption = gpps2("Capstuff", "RemapOptionCaption", CSFile$, "Use Board Remapping")
    FireOnRemap = gpps2("Capstuff", "FireOnRemap", CSFile$, "")
    FireOnUnRemap = gpps2("Capstuff", "FireOnUnRemap", CSFile$, "")
    
    ParseRemap
        
    ' Load count range math override values
    ParseReadingMath
    
    ' Load pretest valve flip options
    Flip1Show = IIf(gpps2("Capstuff", "Flip1Show", CSFile$, "N") = "Y", True, False)
    Flip2Show = IIf(gpps2("Capstuff", "Flip2Show", CSFile$, "N") = "Y", True, False)
    Flip1Name = gpps2("Capstuff", "Flip1Name", CSFile$, "Open V4")
    Flip2Name = gpps2("Capstuff", "Flip2Name", CSFile$, "Open V9")
    Flip1Valve = RonValvePosition(val(gpps2("Capstuff", "Flip1ValvePosition", CSFile$, "4")) - 1)
    Flip2Valve = RonValvePosition(val(gpps2("Capstuff", "Flip2ValvePosition", CSFile$, "9")) - 1)
    
    ' Load Athena values
    GPPS "Capstuff", "UseAthena1", "N", Ret$, 2, CSFile$
    UseAthena1 = IIf(Left(Ret$, 1) = "Y", True, False)
    GPPS "Capstuff", "Athena1Units", "F", Ret$, 255, CSFile$
    Athena1Units = Ret$
    GPPS "Capstuff", "Athena1Channel", "1", Ret$, 2, CSFile$
    Athena1Channel = val(Left(Ret$, 1))
    Athena1Target = val(gpps2("Capstuff", "Athena1Target", CSFile$, "20"))
    GPPS "Capstuff", "Athena1InTest", "N", Ret$, 2, CSFile$
    Athena1InTest = IIf(Left(Ret$, 1) = "Y", True, False)
    GPPS "Capstuff", "Athena1NeverInTest", "N", Ret$, 2, CSFile$
    Athena1NeverInTest = IIf(Left(Ret$, 1) = "Y", True, False)
    ' channel 2
    GPPS "Capstuff", "UseAthena2", "N", Ret$, 2, CSFile$
    UseAthena2 = IIf(Left(Ret$, 1) = "Y", True, False)
    GPPS "Capstuff", "Athena2Units", "F", Ret$, 255, CSFile$
    Athena2Units = Ret$
    
    GPPS "Capstuff", "Athena2Channel", "2", Ret$, 2, CSFile$
    Athena2Channel = val(Left(Ret$, 1))
    Athena2Target = val(gpps2("Capstuff", "Athena2Target", CSFile$, "20"))
    GPPS "Capstuff", "Athena2InTest", "N", Ret$, 2, CSFile$
    Athena2InTest = IIf(Left(Ret$, 1) = "Y", True, False)
    GPPS "Capstuff", "Athena2NeverInTest", "N", Ret$, 2, CSFile$
    Athena2NeverInTest = IIf(Left(Ret$, 1) = "Y", True, False)
    
    ' Load flag for LP use of regulator calibration
    UseRegCalForLP = IIf(gpps2("Capstuff", "UseRegCalForLP", CSFile$, "N") = "Y", True, False)
    
    'JF 2-15-2010
    'New for Humidity control for Baxter
    GPPS "Capstuff", "HasHumidityControls", "N", Ret$, 255, CSFile$
    hasHumidityControls = (nulltrim(Ret$) = "Y")
    If hasHumidityControls Then
        GPPS "Capstuff", "HumidityGaugeNumber", "8", Ret$, 255, CSFile$
        humidityGaugeNumber = val(Ret$)
        GPPS "Capstuff", "HumidityRegulatorPosition", "3", Ret$, 255, CSFile$
        humidityRegulatorPosition = val(Ret$)
        GPPS "Capstuff", "humiditySensorZeroCounts", "2000", Ret$, 255, CSFile$
        humiditySensorZeroCounts = val(Ret$)
        GPPS "Capstuff", "humiditySensorFullCounts", "31000", Ret$, 255, CSFile$
        humiditySensorFullCounts = val(Ret$)
    End If

    GPPS "Capstuff", "autopiston", "N", Ret$, 255, CSFile$
    autopiston = (UCase$(nulltrim(Ret$)) = "Y")
    FrazierPiston = (UCase$(nulltrim(Ret$)) = "F")
    If (autopiston Or FrazierPiston) And autocompress Then
        MsgBox ts$(88)          ' "Error: Can't have autopiston and autocompress both on"
        autopiston = False
        FrazierPiston = False
    End If
    
    GPPS "Capstuff", "safetyup", "X", Ret$, 255, CSFile$
    If Left$(Ret$, 1) = "X" Then
        WPPS "Capstuff", "safetyup", "N", CSFile$
        safetyup = False
        safetyupdoor = False
    Else
        safetyup = (UCase$(nulltrim(Ret$)) = "Y")
        safetyupdoor = (UCase$(nulltrim(Ret$)) = "A")
        If safetyupdoor Then safetyup = True
    End If
    GPPS "Capstuff", "safetydown", "X", Ret$, 255, CSFile$
    If Left$(Ret$, 1) = "X" Then
        WPPS "Capstuff", "safetydown", "N", CSFile$
        safetydown = False
        safetydowndoor = False
    Else
        safetydown = (UCase$(nulltrim(Ret$)) = "Y")
        safetydowndoor = (UCase$(nulltrim(Ret$)) = "A")
        If safetydowndoor Then safetydown = True
    End If
    
    i = GPPS("Capstuff", "vacuum_purge_enable", "N", Ret$, 255, CSFile$)
    vacuum_purge_enable = (UCase$(nulltrim(Ret$)) = "Y")
    TitleScrn.runmenu(7).Visible = vacuum_purge_enable
    If vacuum_purge_enable Then
        num_vacuum_purge_cycles = val(gpps2("Capstuff", "num_vacuum_purge_cycles", CSFile$, "1"))
    End If
    
    bubbler_enable = (UCase$(gpps2("Capstuff", "bubbler_enable", CSFile$, "N")) = "Y")
    ' default values just in case
    BubblerLevelZero = 2000
    bubblerLevelSpan = 62000
    BubblerLevelChannel = -1
    If bubbler_enable Then
        BubblerLevelChannel = val(gpps2("Capstuff", "BubblerLevelChannel", CSFile$, "-1"))
        If BubblerLevelChannel >= 0 Then
            BubblerLevelZero = val(gpps2("Capstuff", "BubblerLevelZero", CSFile$, "2000"))
            bubblerLevelSpan = val(gpps2("Capstuff", "BubblerLevelSpan", CSFile$, "62000"))
        End If
    End If
' Added to work with cratridge tests
   m_bBPCreateLogFile = (UCase$(gpps2("Capstuff", "createLogFile", CSFile$, "N")) = "Y")
   m_bBPFindingForCartridge = (UCase$(gpps2("Capstuff", "BPFindingForCartridge", CSFile$, "N")) = "Y")
   If (m_bBPFindingForCartridge) Then
        m_nBPPressureArraySize = val(gpps2("Capstuff", "BPNumberOfPressurePointsToUse", CSFile$, "39"))
   End If
   'bubWaitTime = val(gpps2("Capstuff", "MinBPTime", CSFile$, "30"))
   
   ' we implemented this to make  not fully functional device to work (should be removed later on).
   ' when it sets to "N", the BPT does not require fill and drain after the each test.
   m_bDeviceIsReadyForDrainAndFill = (UCase$(gpps2("Capstuff", "DeviceIsReady", CSFile$, "Y")) = "Y")
   ' When it sets to "Y", then it shows Pressure vs Time graph on the progress window.
   BP_UsePressureVsTime = (UCase$(gpps2("Capstuff", "UsePressueVsTime", CSFile$, "N")) = "Y")
'Added 11-26-07 --Denis
    ' auto_wet_enable assumes two chambers of auto wetting - this is the only thing we have
    ' made so far.  When we make an auto-wetting system with a different number of chambers
    ' we will have to change this
    auto_wet_enable = (UCase$(gpps2("Capstuff", "auto_wet_enable", CSFile$, "N")) = "Y")
    auto_soak_enable = (UCase$(gpps2("Capstuff", "auto_soak_enable", CSFile$, "N")) = "Y")
    If auto_soak_enable Then
        ' only initialize these if we need them
        ' initialized to one less than value in ini file because move_valve command uses
        ' 0-based valve counting (move_valve 0 = control of valve "1")
        ' Fill valve for channel 1 defaults to 13 (the autofill valve on a liquid perm)
        Fill_ValveA = val(gpps2("Capstuff", "auto_wetting_fill_valveA", CSFile$, "13")) - 1
        ' Drain valve for channel 1 defaults to 12 (the drain valve on a liquid perm)
        Drain_ValveA = val(gpps2("Capstuff", "auto_wetting_drain_valveA", CSFile$, "12")) - 1
        ' Fill valve for channel 2 defaults to 6 (a currently unused valve)
        Fill_ValveB = val(gpps2("Capstuff", "auto_wetting_fill_valveB", CSFile$, "6")) - 1
        ' Drain valve for channel 2 defaults to 7 (a currently unused valve)
        Drain_ValveB = val(gpps2("Capstuff", "auto_wetting_drain_valveB", CSFile$, "7")) - 1
'        SecondPiston = val(gpps2("Capstuff", "second_piston", CSFile$, "8")) - 1
    End If
    rotating_chamber_enable = (UCase$(gpps2("Capstuff", "rotating_chamber_enable", CSFile$, "N")) = "Y")
    
    
    
    status_lights_enable = (UCase$(gpps2("Capstuff", "status_lights_enable", CSFile$, "N")) = "Y")
    pen_max_counts = val(gpps2("Capstuff", "pen_max_counts", CSFile$, str$(DAC_span * 0.975 + DAC_zero)))
    pen_min_counts = val(gpps2("Capstuff", "pen_min_counts", CSFile$, str$(DAC_zero)))
    pen_span = pen_max_counts - pen_min_counts
    
    leakTestPassPercent = val(gpps2("Capstuff", "leakTestPassPercent", CSFile$, str$(0.05)))
    
    slurry_tube_exists = (UCase$(gpps2("Capstuff", "slurry_tube_exists", CSFile$, "N")) = "Y") '6.71.123.01
    If slurry_tube_exists Then
        Slurry_wash_valve = val(gpps2("Capstuff", "Slurry_wash_valve", CSFile$, "28")) - 1
        Slurry_tube_vent_valve = val(gpps2("Capstuff", "Slurry_tube_vent_valve", CSFile$, "29")) - 1
        Slurry_wash_pump = val(gpps2("Capstuff", "Slurry_wash_pump", CSFile$, "30")) - 1
        Slurry_tank_paddle = val(gpps2("Capstuff", "Slurry_tank_paddle", CSFile$, "31")) - 1
        Slurry_tube_top_shut_off = val(gpps2("Capstuff", "Slurry_tube_top_shut_off", CSFile$, "7")) - 1
        Slurry_tube_fill_valve = val(gpps2("Capstuff", "Slurry_tube_fill_valve", CSFile$, "8")) - 1
    End If
    
    v22_exists = (UCase$(gpps2("Capstuff", "v22_exists", CSFile$, "N")) = "Y")
    piston_position_transducer_exists = (UCase$(gpps2("Capstuff", "piston_position_transducer_exists", CSFile$, "N")) = "Y") '6.71.123.01
    valve_limit_offset = val(gpps2("Capstuff", "valve_limit_offset", CSFile$, "0"))
    If dualregulator Then
        reg2_high_flow_switch_count = val(gpps2("Capstuff", "reg2_high_flow_switch_count", CSFile$, "300"))
    End If
    ' if "lvperm_enable"="N" then there is no liquid vapor perm section
    ' if "lvperm_enable"="E" then there is only a liquid vapor perm section
    ' Anything else means that there is a liquid vapor perm section along
    ' with a normal capflow section.
    i = GPPS("Capstuff", "lvperm_enable", "N", Ret$, 255, CSFile$)
    lvperm_enable = (UCase$(nulltrim(Ret$)) <> "N")
    lvperm_exclusive = (UCase$(nulltrim(Ret$)) = "E")
    
    If lvperm_enable Then
        i = GPPS("Capstuff", "aux_p1_span", "100", Ret$, 255, CSFile$)
        aux_p1_span = val(Ret$)
        i = GPPS("Capstuff", "aux_p2_span", "100", Ret$, 255, CSFile$)
        aux_p2_span = val(Ret$)
        If Not auxin Then
            MsgBox "Conflict between lvperm enable and aux input feature bit"
            ' lvperm_enable ROM must have aux bit turned on, though
            ' this aux port is not used otherwise
        End If
        auxin = False ' disable aux input when lvperm is using it
        GPPS "Capstuff", "lvperm_numvalves", "0", Ret$, 255, CSFile$
        lvperm_numvalves = val(Ret$)
        If lvperm_numvalves = 0 Then
            ' set default
            lvperm_numvalves = 5
            WPPS "Capstuff", "lvperm_numvalves", "5", CSFile$
        End If
    End If
    
    ' h2operm variable moved up here so we can determine the
    ' difference between a bubble point tester and a liquid
    ' permeameter with hydrohead
    i = GPPS("Capstuff", "H2OPERM", "N", Ret$, 255, CSFile$)
    H2OPERM = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    
'    If H2OPERM <> f_liq_perm Then follows inserted code
' **********
' Begin LEP code entered by search for Tim Richards 04 05 14
'
    If Left$(UCase$(LTrim$(Ret$)), 1) = "B" Then
        ' Treat the liquid permeability variable as if the ini switch were a "Y"
        H2OPERM = True
        g_bBalanceNotPenet = True
    Else
        g_bBalanceNotPenet = False
    End If
'
' End inserted code by Tim Richards 04 05 14
' **********

    If H2OPERM <> f_liq_perm Then
      MsgBox "Warning:  Feature number mismatch with H2OPerm variable"
    End If
 
    ' must get values for high flow meter before we determine if this is
    ' is a bubble point tester or not
    '** high 1 high
    i = GPPS("Capstuff", "FX1_10", str$(DAC_zero), Ret$, 255, CSFile$)
    FX1(1, 0) = val(Ret$)
    i = GPPS("Capstuff", "FX2_10", str$(DAC_two), Ret$, 255, CSFile$)
    FX2(1, 0) = val(Ret$)
    i = GPPS("Capstuff", "FY1_10", "0", Ret$, 255, CSFile$)
    FY1(1, 0) = val(Ret$)
    i = GPPS("Capstuff", "FY2_10", "10000", Ret$, 255, CSFile$)
    MaxHighFlow = val(Ret$)
    FY2(1, 0) = MaxHighFlow
    
    '** high 1 low
    i = GPPS("Capstuff", "FX1_11", str$(DAC_zero), Ret$, 255, CSFile$)
    FX1(1, 1) = val(Ret$)
    i = GPPS("Capstuff", "FX2_11", str$(DAC_two), Ret$, 255, CSFile$)
    FX2(1, 1) = val(Ret$)
    i = GPPS("Capstuff", "FY1_11", "0", Ret$, 255, CSFile$)
    FY1(1, 1) = val(Ret$)
    i = GPPS("Capstuff", "FY2_11", "4000", Ret$, 255, CSFile$)
    FY2(1, 1) = val(Ret$)

    'Diff Perm option not available on all machines.  Hence, we just have to
    'make sure it is intialized in Capstuff
    i = GPPS("Capstuff", "DIFFPG", "Not_Found", Ret$, 255, CSFile$)
    If nulltrim(Ret$) = "Not_Found" Then
        WPPS "Capstuff", "DIFFPG", "N", CSFile$
        DiffPG = False
    Else
        DiffPG = (UCase$(nulltrim(Ret$)) = "Y")
    End If
    If DiffPG <> f_diff_pg Then
      MsgBox "Warning:  Feature number mismatch with DiffPG variable"
      DiffPG = False
      f_diff_pg = False
    End If
    microflow_extraChamber = False
    If DiffPG Then
        i = GPPS("Capstuff", "microflow_extraChamber", "-1", Ret$, 255, CSFile$)
        If val(Ret$) = -1 Then
            WPPS "Capstuff", "microflow_extraChamber", "0", CSFile$
        Else
            microflow_extraChamber = (val(Ret$) = 1)
        End If
    End If
    liqpermonly = False
    BPTester = False
    itester = False
    microflowporometer = False
    
    
    If FY2(1, 1) = 0 Then
        If integrity Then
            itester = True
        ElseIf DiffPG = True Then
            ' leave things as they are
            microflowporometer = True
        ElseIf H2OPERM Then
            liqpermonly = True
            TitleScrn.calibmenu(2).Visible = False
            TitleScrn.calibmenu(3).Visible = False
            TitleScrn.loadbackuplohm.Visible = False
            TitleScrn.lohmTableFrame.Visible = False
        Else
            BPTester = True
            ' 6.71.38x allow hydrohead in bubble point tester - comment out next line
            ' hydrohead = False
            'TitleScrn.Extra_Low.Visible = False
      '      TitleScrn.filemenu(6).Visible = False
      '      TitleScrn.filemenu(7).Visible = False
            TitleScrn.runmenu(3).Visible = False
            'TitleScrn.runmenu(4).Visible = False
            'TitleScrn.calibmenu(1).Visible = False
            TitleScrn.modifymenu(2).Visible = False
            TitleScrn.modifymenu(3).Visible = False
            TitleScrn.modifymenu(4).Visible = False
            TitleScrn.calibmenu(3).Visible = False
            TitleScrn.calibmenu(4).Visible = False
            TitleScrn.calibmenu(5).Visible = False
            TitleScrn.calibmenu(7).Visible = False
            TitleScrn.loadbackuplohm.Visible = False
            TitleScrn.lohmTableFrame.Visible = False
            'TitleScrn.calibrateMv2.Visible = False
        End If
    End If

    i = GPPS("Capstuff", "AUTOFILL", "N", Ret$, 255, CSFile$)
    Auto_fill = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    ' on version 6, autofill over-rides drain12.  We have only made
    ' one or two autofill version 6 machines
    ' we now have an autofill version 7.  In this one, the autofill valve
    ' doesn't override the drain12 valve - autofill is valve 13
    ' it is feature number
    If Auto_fill And version >= 7 Then
        If Not f_auto_fill Then
            MsgBox "Warning: Feature number mismatch with Autofill variable"
            Auto_fill = False
        End If
    ' drain12 must be on in the feature to allow auto_fill
    ElseIf Auto_fill And Not Drain12 Then
        MsgBox "Warning:  Feature number mismatch with Autofill variable"
        Auto_fill = False
    End If
    ' if auto_fill is still on, it will override the drain12 on version <7
    If Auto_fill And version < 7 Then
        ' Autofill can't have any of the new feature 16 features
        Drain12 = False
        Drain12Motorized = False
    End If
    
    ' if auxin is still on (lvperm can turn it off) then we may have
    ' either a fluid sensor or a temperature probe
    If auxin Then
        i = GPPS("Capstuff", "FLUIDSENSOR", "N", Ret$, 255, CSFile$)
        'fluidsensor = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
        ' temperature% is the number of temperature probes there are
        ' this can be 0 ("N"), 1 ("Y"), or more ("2" or more)
        i = GPPS("Capstuff", "TEMPERATURE", "N", Ret$, 255, CSFile$)
        If Left$(UCase$(LTrim$(Ret$)), 1) = "Y" Then
            temperature% = 1
        ElseIf val(Ret$) > 0 Then
            temperature% = val(Ret$)
        Else
            temperature% = 0
        End If
    Else
        'fluidsensor = False
        temperature% = 0
    End If
    GPPS "Capstuff", "use_time", "N", Ret$, 255, CSFile$
    use_time = (UCase$(Left$(Ret$, 1)) = "Y")
    If fluidsensor Then
        i = GPPS("Capstuff", "FSX0", str$(DAC_zero), Ret$, 255, CSFile$)
        fsx0 = val(Ret$)
        i = GPPS("Capstuff", "FSX1", str$(DAC_two), Ret$, 255, CSFile$)
        fsx1 = val(Ret$)
        i = GPPS("Capstuff", "FSY0", "0", Ret$, 255, CSFile$)
        fsy0 = val(Ret$)
        i = GPPS("Capstuff", "FSY1", "100", Ret$, 255, CSFile$)
        fsy1 = val(Ret$)
        i = GPPS("Capstuff", "FSUNIT", "gm", Ret$, 255, CSFile$)
        fsunit$ = nulltrim(Ret$)
    End If
    
    'SkipFlowStabilize
    Dim skipper$
    i = GPPS("Capstuff", "SkipFlowStabilize", "N", Ret$, 255, CSFile$)
    skipper = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    If skipper = "N" Then
        SkipFlowStabilize = False
    Else
        SkipFlowStabilize = True
    End If
    ' read in old watlow_com_number temporarily in case we need to update
    i = GPPS("Capstuff", "external_watlow_com_number", "0", Ret$, 255, CSFile$)
    watlow_com_number = val(Ret$)
    ' 6.71.67 new temperature probe variables
    dryChamberTemperature = getNewTemperatureValue("dryChamberTemperature")
    wetChamberTemperature = getNewTemperatureValue("wetChamberTemperature")
    reservoirTemperature = getNewTemperatureValue("reservoirTemperature")
    airTemperature = getNewTemperatureValue("airTemperature")
    cabinetTemperature = getNewTemperatureValue("cabinetTemperature")
    bubblerTemperature = getNewTemperatureValue("bubblerTemperature")
    hydroHeadTemperature = getNewTemperatureValue("hydroHeadTemperature")
    mullenTemperature = getNewTemperatureValue("mullenTemperature")
    
    watlowViaModbus(1) = (gpps2("Capstuff", "Watlow1ViaModbus", CSFile$, "N") = "Y")
    watlowViaModbus(2) = (gpps2("Capstuff", "Watlow2ViaModbus", CSFile$, "N") = "Y")
    watlowViaModbus(3) = (gpps2("Capstuff", "Watlow3ViaModbus", CSFile$, "N") = "Y")
    athena = val(gpps2("Capstuff", "Athena", CSFile$, "0"))
    
    ' if all three of these are 0, and temperature% is > 0 then we need to initialize these
    If dryChamberTemperature = 0 And wetChamberTemperature = 0 And reservoirTemperature = 0 And _
       bubblerTemperature = 0 And cabinetTemperature = 0 And airTemperature = 0 And _
       hydroHeadTemperature = 0 And mullenTemperature = 0 And _
       (temperature% > 0 Or watlow_com_number > 0) Then
        ' this section of code should only run once, when you first run the new program on an old configuration
        If temperature% = 0 Then
            ' it must just be a watlow com number, which was always on the dry chamber
            ' watlow com number 1 = new internal number -1 (C1A)
            ' watlow com number 2 = new internal number -3 (C2A)
            dryChamberTemperature = 1 - (watlow_com_number * 2)
            WPPS "Capstuff", "dryChamberTemperature", "C" + Format$(watlow_com_number) + "A", CSFile$
        ElseIf temperature% = 1 Then
            If H2OPERM Then
                ' single probe is on the wet chamber
                wetChamberTemperature = 1
                WPPS "Capstuff", "wetChamberTemperature", "G1", CSFile$
                ' also check for watlow com number, because that is valid in this case
                If watlow_com_number > 0 Then
                    dryChamberTemperature = 1 - (watlow_com_number * 2)
                    WPPS "Capstuff", "dryChamberTemperature", "C" + Format$(watlow_com_number) + "A", CSFile$
                End If
            Else
                ' single probe is on the dry chamber
                dryChamberTemperature = 1
                WPPS "Capstuff", "dryChamberTemperature", "G1", CSFile$
                ' ignore watlow_com_number in this case.  Don't bother with a warning because we never
                ' shipped a machine with this configuration
            End If
        Else ' temperature must be 2, as there is no other legal value
            If H2OPERM Then
                ' first probe is on the wet chamber
                wetChamberTemperature = 1
                WPPS "Capstuff", "wetChamberTemperature", "G1", CSFile$
                ' second probe is on the reservoir
                reservoirTemperature = 2
                WPPS "Capstuff", "reservoirTemperature", "G2", CSFile$
                ' also check for watlow com number, because that is valid in this case
                If watlow_com_number > 0 Then
                    dryChamberTemperature = 1 - (watlow_com_number * 2)
                    WPPS "Capstuff", "dryChamberTemperature", "C" + Format$(watlow_com_number) + "A", CSFile$
                End If
            Else
                ' this is a warning condition since we don't know what to do with the second probe
                dryChamberTemperature = 1
                WPPS "Capstuff", "dryChamberTemperature", "G1", CSFile$
                MsgBox "Warning: check configuration of temperature probes.  Second probe may not be assigned properly."
                ' second probe is on the reservoir because we don't know where else to put it
                reservoirTemperature = 2
                WPPS "Capstuff", "reservoirTemperature", "G2", CSFile$
                ' ignore watlow_com_number in this case.  Don't bother with a warning because we never
                ' shipped a machine with this configuration
            End If
        End If
    End If
    
    ' 6.71.67 we no longer use this
    'watlow_com_number = Val(gpps2("capstuff", "external_watlow_com_number", CSFile$, "0"))
    'If watlow_com_number <= 0 Then TitleScrn.check_external_temperature.Visible = False
    
    
    ' 6.71.67 all temperature probes have the same range values, if they are being read from the
    '  aux port.  Otherwise, if they are read directly from the Watlow (either CXX or RXX) then
    '  they don't need conversion since they don't come in as counts
    'If temperature% > 0 Then
    ' this is only needed if one or more of the temperature probes are set to 1 or 2
    If (dryChamberTemperature = 1) Or (dryChamberTemperature = 2) Or _
       (wetChamberTemperature = 1) Or (wetChamberTemperature = 2) Or _
       (reservoirTemperature = 1) Or (reservoirTemperature = 2) Then
        i = GPPS("Capstuff", "TSX0", str$(DAC_zero), Ret$, 255, CSFile$)
        tsx0 = val(Ret$)
        i = GPPS("Capstuff", "TSX1", str$(DAC_two), Ret$, 255, CSFile$)
        tsx1 = val(Ret$)
        i = GPPS("Capstuff", "TSY0", "0", Ret$, 255, CSFile$)
        tsy0 = val(Ret$)
        i = GPPS("Capstuff", "TSY1", "2000", Ret$, 255, CSFile$)
        tsy1 = val(Ret$)
        i = GPPS("Capstuff", "TSUNIT", "deg. C", Ret$, 255, CSFile$)
        tsunit$ = nulltrim(Ret$)
        If Len(tsunit$) = 1 Then
            tsunit$ = "deg. " + UCase$(tsunit$)
        End If
        If Len(tsunit$) <> 6 Or Left$(tsunit$, 5) <> "deg. " Then
            MsgBox ts$(91)          ' "Improper format for TSUNIT - should be C or F"
        End If
    End If
    ' check for improper configuration of the temperature variables
    ' we will now temporarily reuse the watlow_com_number variable to indicate which, if any
    ' of the PC com ports we are going to need to use
    watlow_com_number = 0 ' we aren't using any yet
    If dryChamberTemperature < 0 Then
        ' can't be a conflict with first one
        watlow_com_number = Int((1 - dryChamberTemperature) / 2)
    End If
    If wetChamberTemperature < 0 Then
        ' reuse no-longer-needed temperature% variable for this
        temperature% = Int((1 - wetChamberTemperature) / 2)
        If watlow_com_number > 0 And watlow_com_number <> temperature% Then
            MsgBox "Error:  wetChamberTemperature can not use different PC COMM port from dryChamberTemperature"
            wetChamberTemperature = 0
        Else
            watlow_com_number = temperature%
        End If
    End If
    If reservoirTemperature < 0 Then
        ' reuse no-longer-needed temperature% variable for this
        temperature% = Int((1 - reservoirTemperature) / 2)
        If watlow_com_number > 0 And watlow_com_number <> temperature% Then
            MsgBox "Error:  reservoirTemperature can not use different PC COMM port from dryChamberTemperature or wetChamberTemperature"
            wetChamberTemperature = 0
        End If
    End If
    ' watlow_com_number should now be set to the actual PC COMM port we want to use for the temperature
    ' probe, so set the object on the title screen accordingly
'    If TitleScrn.AuxComm.PortOpen = True Then
'        TitleScrn.AuxComm.PortOpen = False
'    End If
    'If watlow_com_number > 0 Then TitleScrn.AuxComm.CommPort = watlow_com_number
    ' we could check for duplicates, but we will actually allow them so we can handle cases where there is only one probe but you want
    ' to use it for more than one thing.
         
    i = GPPS("Capstuff", "COMPRESSION", "N", Ret$, 255, CSFile$)
    compression = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    
    If compression Then
        i = GPPS("Capstuff", "AllowZeroCompression", "N", Ret$, 255, CSFile$)
        allowZeroCompression = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    End If
    
    If Left$(UCase$(LTrim$(Ret$)), 1) = "D" Then
        compression = True
        dual_stage_compression = True
    Else
        dual_stage_compression = False
    End If
    ' note that you can have compression with autocompress
    ' but you can't have autocompress without compression
    If autocompress And Not compression Then
        MsgBox "Warning: Feature number mismatch - can't have autocompression without compression"
        autocompress = False
    End If

    i = GPPS("Capstuff", "Second_Penetrometer", "N", Ret$, 255, CSFile$)
    Second_Penetrometer = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    ' can't have second penetrometer unless you have a first one
    If Second_Penetrometer And (Not H2OPERM And Not hydrohead) Then
        MsgBox "Warning:  Feature conflict with Second_Penetrometer and H2OPerm"
        Second_Penetrometer = False
    End If
    ' have to have auxin if there is a second penetrometer
    If Second_Penetrometer And Not auxin Then
        MsgBox "Warning:  Feature conflict with aux input feature and Second_Penetrometer"
        Second_Penetrometer = False
    End If
    TitleScrn.penselecthead.Visible = Second_Penetrometer
    
    If Second_Penetrometer Then
        liqperm_penetrometer = val(gpps2("Capstuff", "liqperm_penetrometer", CSFile$, "0"))
        hydrohead_penetrometer = val(gpps2("Capstuff", "hydrohead_penetrometer", CSFile$, "0"))
        mullen_penetrometer = val(gpps2("Capstuff", "mullen_penetrometer", CSFile$, "0"))
        burst_penetrometer = val(gpps2("Capstuff", "burst_penetrometer", CSFile$, "0"))
    End If
    
    i = GPPS("Capstuff", "SampleEjectionSystem", "N", Ret$, 255, CSFile$)
    sampleEjectionSystem = Left$(Ret$, 1)
    
    ' airtop must be after autofill since autofill can turn off drain12
    i = GPPS("Capstuff", "AirTop", "N", Ret$, 255, CSFile$)
    AirTop = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    ' if airtop is on and we are liquid perm, we must have a drain valve
    If AirTop And H2OPERM And (Not Drain12) Then
        MsgBox "Warning:  Feature conflict with AirTop, H2OPerm, and feature 16 (drain valve 12)"
        AirTop = False
    End If
    ' if we are liquid perm and we have a drain valve, we must also have airtop
    If (Not AirTop) And H2OPERM And Drain12 Then
        MsgBox "Warning:  Feature conflict with AirTop, H2OPerm, and feature 16 (drain valve 12)"
        AirTop = True
    End If
    
    If H2OPERM Or mullen Then
    
'        TitleScrn.calibmenu(4).Visible = True directly follows inserted code
' **********
' Begin Mettler Balance INI file code entry for use of a balance entered by
' search for Tim Richards on Wednesday 04 05 26
'
' g_iMettler_fluid_min (grams)
' g_iMettler_fluid_max (grams)
' g_iMettler_fluid_density (grams/mL)
'
    ' scale minimum is 0, but it will read -29g ---i saw it.
'Function gpps2(section$, keyname$, filename$, default$) As String
' These defaults were measured on
    g_iMettler_fluid_min = val(gpps2("Capstuff", "Mettler_fluid_min", CSFile$, "0")) '*****DEF ALUTES!!!!!!!!!!!!
    
    ' scale maximum is 220, and so let's back off a little bit
    g_iMettler_fluid_max = val(gpps2("Capstuff", "Mettler_fluid_max", CSFile$, "40")) '*****DEF ALUTES!!!!!!!!!!!!

    ' water has a density of 1, being one with water.
    g_iMettler_fluid_density = val(gpps2("Capstuff", "Mettler_fluid_density", CSFile$, "1.000")) '*****DEF ALUTES!!!!!!!!!!!!

    ' Negative counts offset for AutoTest. TAR 040614
    g_iMettler_Negative_Counts_Offset = val(gpps2("Capstuff", "Mettler_Negative_Counts_Offset", CSFile$, "-100")) '*****DEF ALUTES!!!!!!!!!!!!

    ' Maximum fluid through the sample. mL. TAR 040629
    g_iMettler_MaxFlowSetPoint = val(gpps2("Capstuff", "Mettler_Fluid_Flow_Max", CSFile$, "10")) '*****DEF ALUTES!!!!!!!!!!!!
'
' End Mettler Balance INI file code entry by Tim Richards 04 05 26
' **********
    ' set ret$ back to proper buffer size for next set of GPPS commands.
    Ret$ = String$(255, " ")

        TitleScrn.calibmenu(4).Visible = True
        i = GPPS("Capstuff", "PEN500", "53.34", Ret$, 255, CSFile$)     '(Tim Richards note mark)
        PEN500 = val(Ret$)
        i = GPPS("Capstuff", "PEN20500", "27.94", Ret$, 255, CSFile$)
        PEN20500 = val(Ret$)
        i = GPPS("Capstuff", "CSECAREA", "0.3166922", Ret$, 255, CSFile$)
        CSECAREA = val(Ret$)
        i = GPPS("Capstuff", "PSIPERCM", "0.014209", Ret$, 255, CSFile$)
        PSIPERCM = val(Ret$)
        i = GPPS("Capstuff", "max_liq_pres", "200", Ret$, 255, CSFile$)
        max_liq_pres = val(Ret$)
        i = GPPS("Capstuff", "lperm_initializeRegulatorPressure", "0", Ret$, 255, CSFile$)
        lperm_initializeRegulatorPressure = val(Ret$)
        If lperm_initializeRegulatorPressure = 0 Then
            lperm_initializeRegulatorPressure = 0.5
            WPPS "Capstuff", "lperm_initializeRegulatorPressure", "0.5", CSFile$
        End If
        i = GPPS("Capstuff", "lperm_regulatorIncrementSteps", "0", Ret$, 255, CSFile$)
        lperm_regulatorIncrementSteps = val(Ret$)
        If lperm_regulatorIncrementSteps = 0 Then
            lperm_regulatorIncrementSteps = 1
            WPPS "Capstuff", "lperm_regulatorIncrementSteps", "1", CSFile$
        End If
        i = GPPS("Capstuff", "lperm_autoFillVentTime", "-1", Ret$, 255, CSFile$)
        lperm_autoFillVentTime = val(Ret$)
        If lperm_autoFillVentTime < 0 Then
            lperm_autoFillVentTime = 5
            WPPS "Capstuff", "lperm_autoFillVentTime", "5", CSFile$
        End If
        If Second_Penetrometer Then
            i = GPPS("Capstuff", "2PEN500", "53.34", Ret$, 255, CSFile$)
            P2PEN500 = val(Ret$)
            i = GPPS("Capstuff", "2PEN20500", "27.94", Ret$, 255, CSFile$)
            P2PEN20500 = val(Ret$)
            i = GPPS("Capstuff", "2CSECAREA", "0.3166922", Ret$, 255, CSFile$)
            P2CSECAREA = val(Ret$)
            i = GPPS("Capstuff", "2PSIPERCM", "0.014209", Ret$, 255, CSFile$)
            P2PSIPERCM = val(Ret$)
            GPPS "Capstuff", "Second_Penetrometer_V9", "9", Ret$, 255, CSFile$
            Second_Penetrometer_V9 = val(Ret$)
            GPPS "Capstuff", "Second_Penetrometer_V12", "12", Ret$, 255, CSFile$
            Second_Penetrometer_V12 = val(Ret$)
            GPPS "Capstuff", "Second_Penetrometer_V13", "13", Ret$, 255, CSFile$
            Second_Penetrometer_V13 = val(Ret$)
            GPPS "Capstuff", "Second_Penetrometer_V23", "23", Ret$, 255, CSFile$
            Second_Penetrometer_V23 = val(Ret$)
        End If
        GPPS "capstuff", "bottom_fill_point", "not set", Ret$, 255, CSFile$
        If Left$(Ret$, 7) = "not set" Then
            bottom_fill_point = 0
            WPPS "capstuff", "bottom_fill_point", "0", CSFile$
        Else
            bottom_fill_point = val(Ret$)
        End If
        GPPS "capstuff", "sample_zero_point", "not set", Ret$, 255, CSFile$
        If Left$(Ret$, 7) = "not set" Then
            sample_zero_point = 0
            WPPS "capstuff", "sample_zero_point", "0", CSFile$
        Else
            sample_zero_point = val(Ret$)
        End If
        GPPS "capstuff", "penetrometer_start_test_point", "not set", Ret$, 255, CSFile$
        ' added check for valid value 6.71.20
        If (Left$(Ret$, 7) = "not set") Or (val(Ret$) < ((PEN500 + PEN20500) / 2)) Then
            penetrometer_start_test_point = PEN500
            WPPS "capstuff", "penetrometer_start_test_point", str$(PEN500), CSFile$
        Else
            penetrometer_start_test_point = val(Ret$)
        End If
        GPPS "capstuff", "max_fill_point", "not set", Ret$, 255, CSFile$
        If Left$(Ret$, 7) = "not set" Then
            max_fill_point = PEN500
            WPPS "capstuff", "max_fill_point", str$(PEN500), CSFile$
        Else
            max_fill_point = val(Ret$)
        End If
        
        GPPS "capstuff", "minimum_liquid_test_stop_point", "not set", Ret$, 255, CSFile$
        If Left$(Ret$, 7) = "not set" Then
            minimum_liquid_test_stop_point = PEN500
            WPPS "capstuff", "minimum_liquid_test_stop_point", str$(minimum_liquid_test_stop_point), CSFile$
        Else
            minimum_liquid_test_stop_point = val(Ret$)
        End If
    End If

    i = GPPS("Capstuff", "EXTRAPG", "N", Ret$, 255, CSFile$)
    ExtraPG = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    If ExtraPG <> f_low_pres Then
      MsgBox "Warning:  Feature number mismatch with ExtraPG variable"
      'turn them both off
      ExtraPG = False
      f_low_pres = False
    End If
        
    If ExtraPG Then
        '** pg 1 high
        i = GPPS("Capstuff", "PX1_2", str$(DAC_zero), Ret$, 255, CSFile$)
        PX1(2) = val(Ret$)
        i = GPPS("Capstuff", "PX2_2", str$(DAC_two), Ret$, 255, CSFile$)
        PX2(2) = val(Ret$)
        i = GPPS("Capstuff", "PY1_2", "0", Ret$, 255, CSFile$)
        PY1(2) = val(Ret$)
        i = GPPS("Capstuff", "PY2_2", "19.3421", Ret$, 255, CSFile$)
        PY2(2) = val(Ret$)
    
        '** pg 1 low
        i = GPPS("Capstuff", "PX1_3", str$(DAC_zero), Ret$, 255, CSFile$)
        PX1(3) = val(Ret$)
        i = GPPS("Capstuff", "PX2_3", str$(DAC_two), Ret$, 255, CSFile$)
        PX2(3) = val(Ret$)
        i = GPPS("Capstuff", "PY1_3", "0", Ret$, 255, CSFile$)
        PY1(3) = val(Ret$)
        i = GPPS("Capstuff", "PY2_3", "3.86842", Ret$, 255, CSFile$)
        PY2(3) = val(Ret$)
    End If
        
    ' 11-20-07 set minbubflow to default values before we try to read it in
    ' this code taken from the autoparm editor form load, with some modifications
    If dualregulator = True Then
        ' 500 PSI machine
        minbubflow = 10#
    ElseIf (PY2(0) >= 160) And (ExtraPG = False) Then
        minbubflow = 10#
    Else
        minbubflow = 5#
    End If
    minbubflow = val(gpps2("Capstuff", "MinBubFlow", CSFile$, str$(minbubflow)))

' now for stuff where the order doesn't matter:
    
    ' 6.71.102
    i = GPPS("Capstuff", "Air_Inlets", "-42", Ret$, 255, CSFile$)
    If val(Ret$) = -42 Then
        WPPS "Capstuff", "Air_Inlets", "1", CSFile$
        air_inlets = 1
    Else
        air_inlets = val(Ret$)
        If air_inlets < 1 Then air_inlets = 1
        If air_inlets > 2 Then air_inlets = 2
        If air_inlets = 2 Then
            i = GPPS("Capstuff", "Air_Inlet_1_Max_P", "-42", Ret$, 255, CSFile$)
            If val(Ret$) = -42 Then
                WPPS "Capstuff", "Air_Inlet_1_Max_P", "100", CSFile$
                air_inlet_1_max_p = 100
            Else
                air_inlet_1_max_p = val(Ret$)
            End If
        End If
    End If
    
    i = GPPS("Capstuff", "reg1pmax", "100", Ret$, 255, CSFile$)
    reg1pmax = val(Ret$)
    ' 6.71.20 begin
    i = GPPS("Capstuff", "second_regulator_starting_point", "0", Ret$, 255, CSFile$)
    second_regulator_starting_point = val(Ret$)
    i = GPPS("Capstuff", "switch_high_flow_enabled", "1", Ret$, 255, CSFile$)
    switch_high_flow_enabled = (val(Ret$) = 1)
    ' 6.71.20 end
    GPPS "Capstuff", "network_connection_enabled", "42", Ret$, 255, CSFile$
    If val(Ret$) = 42 Then
        WPPS "Capstuff", "network_connection_enabled", "0", CSFile$
        network_connection_enabled = False
    Else
        network_connection_enabled = (val(Ret$) = 1)
    End If
    'edc 12-07-06 added to read border from the capwin.ini file
    i = GPPS("Capstuff", "border", "0000FF", Ret$, 255, CSFile$)
    lngBorderColor = val(Ret$)
    i = GPPS("Capstuff", "penet_refill_delay", "undefined", Ret$, 255, CSFile$)
    If Ret$ = "undefined" Then
        WPPS "Capstuff", "penet_refill_delay", "0", CSFile$
        penet_refill_delay = 0
    Else
        penet_refill_delay = val(Ret$)
        If penet_refill_delay < 0 Then penet_refill_delay = 0
    End If
    
    '**valve limits
    i = GPPS("Capstuff", "CLIMIT", "2000", Ret$, 255, CSFile$)
    cLimit = val(Ret$)
    i = GPPS("Capstuff", "OLIMIT", "14000", Ret$, 255, CSFile$)
    oLimit = val(Ret$)
    If cLimit = 0 And oLimit = 0 Then
        ' when there is a solenoid valve 2, it doesn't matter
        ' if the limits are 0, there is still a v2, so nov2 must
        ' be false
        nov2 = Not v2solenoid
    Else
        nov2 = False
    End If
    
    
    If nov2 Then
      TitleScrn.runmenu(4).Visible = False
      TitleScrn.calibmenu(1).Visible = False
    End If

    If newreg Or ip_reg_enable Then
        TitleScrn.calibmenu(6).Visible = True
    End If
    
    i = GPPS("Capstuff", "V2Percent", "100", Ret$, 255, CSFile$)
    V2Percent = val(Ret$)
    If V2Percent < 0 Or V2Percent > 100 Then V2Percent = 100
    If V2Percent < 20 Then   ' changed for versions 5.1 or less
    'to allow v2 to open and close very small amount, or else the flowmeter in a gas permeameter
    'could be initialized with flow running through it.
      MsgBox ts$(87)        ' ("Lowest Suggested V2Percent is 20 - Setting Value to 20")    ' not safe if this is below 20%
      V2Percent = 20
    End If
        
    Rem new variable for cv calculation - how many clicks on regulator
    Ret$ = String$(255, " ")
    i = GPPS("Capstuff", "CVRegInc", "4", Ret$, 255, CSFile$)
    Cv_reg_inc = val(Ret$)
    If Cv_reg_inc <= 1 Then Cv_reg_inc = 2
        
    Rem new variable for cv calculation - how much correction allowed (i.e. ratio of P-P0/CvP-P0)
    Ret$ = String$(255, " ")
    i = GPPS("Capstuff", "Lohm_Tolerance", "1.10", Ret$, 255, CSFile$)
    Lohm_Ratio = val(Ret$)
    If Lohm_Ratio <= 1 Then Lohm_Ratio = 1.01
    
    i = GPPS("Capstuff", "UnitNumber", "0", Ret$, 255, CSFile$)
    unitnumber = val(Ret$)
    
    i = GPPS("Capstuff", "Penetrometer_Select", "1", Ret$, 255, CSFile$)
    penetrometer_select = val(Ret$)
    TitleScrn.selpen(penetrometer_select).Checked = True
    TitleScrn.selpen(3 - penetrometer_select).Checked = False

    i = GPPS("Capstuff", "PSIPERCC", "0", Ret$, 255, CSFile$)
    PSIPERCC = val(Ret$)
    If PSIPERCC <= 0 Then PSIPERCC = 0

    i = GPPS("Capstuff", "cfanal", "N", Ret$, 255, CSFile$)
    If Left$(UCase$(LTrim$(Ret$)), 1) = "Y" Then
      CFAnal = True
    End If
    
    If Not UAC_Enabled Then
        i = GPPS("Capstuff", "supervisor", "Y", Ret$, 255, CSFile$)
        supervisor = (UCase$(nulltrim(Ret$)) <> "N")
        i = GPPS("Capstuff", "superpass", "", Ret$, 255, CSFile$)
        superpass = nulltrim(Ret$)
    End If
    i = GPPS("Capstuff", "SimpleQC", "0", Ret$, 255, CSFile$)
    simpleqc_enable = (val(Ret$) = 1)
    
'    i = GPPS("Capstuff", "crossoverdebug", "N", Ret$, 255, CSFile$)
'    crossoverdebug = (nulltrim(Ret$) = "Y")
    i = GPPS("Capstuff", "debug_button_enable", "N", Ret$, 255, CSFile$)
    debug_button_enable = (UCase$(nulltrim(Ret$)) <> "N")
    
    i = GPPS("Capstuff", "FrazierPressureGauge", "N", Ret$, 255, CSFile$)
    FrazierPressureGauge = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    FrazierRunning = False
    
    i = GPPS("Capstuff", "Debug", "N", Ret$, 255, CSFile$)
    If Left$(UCase$(LTrim$(Ret$)), 10) = "NOFAILSAFE" Then
      NoFailSafe = True
      MsgBox ts$(89)        ' "WARNING:  Fail Safe Mode Turned OFF!!!"
    Else
      NoFailSafe = False
    End If
    
    i = GPPS("Capstuff", "3wayvalve", "N", Ret$, 255, CSFile$)
    way3 = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    
    i = GPPS("Capstuff", "log_comm", "N", Ret$, 255, CSFile$)
    log_comm = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    
    'i = GPPS("Capstuff", "log_raw", "N", Ret$, 255, CSFile$)
    'log_raw = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    
    i = GPPS("Capstuff", "five_one_reg", "N", Ret$, 255, CSFile$)
    reg5 = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    
    ' Superseded by LoadTextStrings (in TitleScrn)
    'i = GPPS("Capstuff", "system_font", "MS Sans Serif", Ret$, 255, CSFile$)
    'system_font = nulltrim(Ret$)
    'i = GPPS("Capstuff", "font_size", "8", Ret$, 255, CSFile$)
    'font_size = Val(Ret$)
    'i = GPPS("Capstuff", "font_bold", "1", Ret$, 255, CSFile$)
    'font_bold = (Val(Ret$) <> 0)
    
    '** pg 1 high
    i = GPPS("Capstuff", "PX1_0", str$(DAC_zero), Ret$, 255, CSFile$)
    PX1(0) = val(Ret$)
    i = GPPS("Capstuff", "PX2_0", str$(DAC_two), Ret$, 255, CSFile$)
    PX2(0) = val(Ret$)
    i = GPPS("Capstuff", "PY1_0", "0", Ret$, 255, CSFile$)
    PY1(0) = val(Ret$)
    i = GPPS("Capstuff", "PY2_0", "193.421", Ret$, 255, CSFile$)
    PY2(0) = val(Ret$)
    
    '** pg 1 low
    i = GPPS("Capstuff", "PX1_1", str$(DAC_zero), Ret$, 255, CSFile$)
    PX1(1) = val(Ret$)
    i = GPPS("Capstuff", "PX2_1", str$(DAC_two), Ret$, 255, CSFile$)
    PX2(1) = val(Ret$)
    i = GPPS("Capstuff", "PY1_1", "0", Ret$, 255, CSFile$)
    PY1(1) = val(Ret$)
    i = GPPS("Capstuff", "PY2_1", "38.6842", Ret$, 255, CSFile$)
    PY2(1) = val(Ret$)

    i = GPPS("Capstuff", "Reg_Zero_Time", "8", Ret$, 255, CSFile$)
    reg_zero_time = val(Ret$)

    i = GPPS("Capstuff", "External Hydrohead", "N", Ret$, 255, CSFile$)
    externalhydrohead = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    
    i = GPPS("Capstuff", "READAT", "N", Ret$, 255, CSFile$)
    readatenabled = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    
    i = GPPS("Capstuff", "WESA", "N", Ret$, 255, CSFile$)
    WESA_enabled = (Left$(UCase$(LTrim$(Ret$)), 1) <> "N")
    WESA_exclusive = (Left$(UCase$(LTrim$(Ret$)), 1) = "E")
    
    i = GPPS("Capstuff", "PDrop", "N", Ret$, 255, CSFile$)
    PDrop = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    
    i = GPPS("Capstuff", "serial_number", "None Given", Ret$, 255, CSFile$)
    serial_number$ = nulltrim(Ret$)

    Rem added jsd for new cv work
    Disable_CV = False
    bad_cv_correction = False
    'skiplowflowcv = False
    cv_withmulti_v2 = True
    Rem don't need this anymore as we now use the more sophisicated look-up table
    Ret$ = String$(255, " ")
    i = GPPS("Capstuff", "CV", "20", Ret$, 255, CSFile$)
    cv = val(Ret$)
    If cv = 0 Then Disable_CV = True
    'If cv = 99 Then cv_withmulti_v2 = True
    'cv = cv * 19749.786
    'CV = CV * CV  '  pre-correct for 70F, air, flow in ccpm, pressure in psia.  Also, pre-square cv for use in formula.
    
    Rem throw in a variable to turn off hflow1 cv calibration
    Rem added by jsd jan 2001
    'MedFM_CV_Disable = True
    Rem this disables the old way of doing Lohm/CV with v2 opened 100%....
    Rem set to default to true, as this is now OK
    
    Ret$ = String$(255, " ")
    i = GPPS("Capstuff", "HFlow1_Disable", "-1", Ret$, 255, CSFile$)
    MedFM_CV_Disable = val(Ret$)
    
    If xhflow Then
        i = GPPS("Capstuff", "xhflow_meters", "1", Ret$, 255, CSFile$)
        xhflow_meters = val(Ret$)
        
        '** high 2 high
        i = GPPS("Capstuff", "FX1_12", str$(DAC_zero), Ret$, 255, CSFile$)
        FX1(1, 2) = val(Ret$)
        i = GPPS("Capstuff", "FX2_12", str$(DAC_two), Ret$, 255, CSFile$)
        FX2(1, 2) = val(Ret$)
        i = GPPS("Capstuff", "FY1_12", "0", Ret$, 255, CSFile$)
        FY1(1, 2) = val(Ret$)
        i = GPPS("Capstuff", "FY2_12", "200000", Ret$, 255, CSFile$)
        FY2(1, 2) = val(Ret$)
    
        '** high 2 low
        i = GPPS("Capstuff", "FX1_13", str$(DAC_zero), Ret$, 255, CSFile$)
        FX1(1, 3) = val(Ret$)
        i = GPPS("Capstuff", "FX2_13", str$(DAC_two), Ret$, 255, CSFile$)
        FX2(1, 3) = val(Ret$)
        i = GPPS("Capstuff", "FY1_13", "0", Ret$, 255, CSFile$)
        FY1(1, 3) = val(Ret$)
        i = GPPS("Capstuff", "FY2_13", "80000", Ret$, 255, CSFile$)
        FY2(1, 3) = val(Ret$)
            
        If xhflow_meters = 2 Then
            '** high 3 high
            i = GPPS("Capstuff", "FX1_14", str$(DAC_zero), Ret$, 255, CSFile$)
            FX1(1, 4) = val(Ret$)
            i = GPPS("Capstuff", "FX2_14", str$(DAC_two), Ret$, 255, CSFile$)
            FX2(1, 4) = val(Ret$)
            i = GPPS("Capstuff", "FY1_14", "0", Ret$, 255, CSFile$)
            FY1(1, 4) = val(Ret$)
            i = GPPS("Capstuff", "FY2_14", "200000", Ret$, 255, CSFile$)
            FY2(1, 4) = val(Ret$)
        
            '** high 3 low
            i = GPPS("Capstuff", "FX1_15", str$(DAC_zero), Ret$, 255, CSFile$)
            FX1(1, 5) = val(Ret$)
            i = GPPS("Capstuff", "FX2_15", str$(DAC_two), Ret$, 255, CSFile$)
            FX2(1, 5) = val(Ret$)
            i = GPPS("Capstuff", "FY1_15", "0", Ret$, 255, CSFile$)
            FY1(1, 5) = val(Ret$)
            i = GPPS("Capstuff", "FY2_15", "80000", Ret$, 255, CSFile$)
            FY2(1, 5) = val(Ret$)
        End If
    End If
        
    If DiffPG Or num_sample_pressure_gauges >= 1 Then
        TitleScrn.calibmenu(5).Visible = True
        '** pg 1 high
        i = GPPS("Capstuff", "PX1_4", str$(DAC_zero), Ret$, 255, CSFile$)
        PX1(4) = val(Ret$)
        i = GPPS("Capstuff", "PX2_4", str$(DAC_two), Ret$, 255, CSFile$)
        PX2(4) = val(Ret$)
        i = GPPS("Capstuff", "PY1_4", "0", Ret$, 255, CSFile$)
        PY1(4) = val(Ret$)
        i = GPPS("Capstuff", "PY2_4", "19.3421", Ret$, 255, CSFile$)
        PY2(4) = val(Ret$)
    
        '** pg 1 low
        i = GPPS("Capstuff", "PX1_5", str$(DAC_zero), Ret$, 255, CSFile$)
        PX1(5) = val(Ret$)
        i = GPPS("Capstuff", "PX2_5", str$(DAC_two), Ret$, 255, CSFile$)
        PX2(5) = val(Ret$)
        i = GPPS("Capstuff", "PY1_5", "0", Ret$, 255, CSFile$)
        PY1(5) = val(Ret$)
        i = GPPS("Capstuff", "PY2_5", "3.86842", Ret$, 255, CSFile$)
        PY2(5) = val(Ret$)
    End If
    ' diff_volume is needed by both diffpg and lvperm
    If lvperm_enable Or DiffPG Then
        i = GPPS("Capstuff", "Diff_Volume", "0", Ret$, 255, CSFile$)
        Diff_Volume(1) = val(Ret$)
        If Diff_Volume(1) <= 0 Then MsgBox "Warning:  'Diff_Volume' parameter not set!"
    End If

    If autocompress Or num_sample_pressure_gauges = 2 Then
        '** cpg high
        i = GPPS("Capstuff", "PX1_6", str$(DAC_zero), Ret$, 255, CSFile$)
        PX1(6) = val(Ret$)
        i = GPPS("Capstuff", "PX2_6", str$(DAC_two), Ret$, 255, CSFile$)
        PX2(6) = val(Ret$)
        i = GPPS("Capstuff", "PY1_6", "0", Ret$, 255, CSFile$)
        PY1(6) = val(Ret$)
        i = GPPS("Capstuff", "PY2_6", "250", Ret$, 255, CSFile$)
        PY2(6) = val(Ret$)
    
        '** cpg low
        i = GPPS("Capstuff", "PX1_7", str$(DAC_zero), Ret$, 255, CSFile$)
        PX1(7) = val(Ret$)
        i = GPPS("Capstuff", "PX2_7", str$(DAC_two), Ret$, 255, CSFile$)
        PX2(7) = val(Ret$)
        i = GPPS("Capstuff", "PY1_7", "0", Ret$, 255, CSFile$)
        PY1(7) = val(Ret$)
        i = GPPS("Capstuff", "PY2_7", "50", Ret$, 255, CSFile$)
        PY2(7) = val(Ret$)
        ' compression_pressure is now stored with the user
        'i = GPPS("Capstuff", "compression_pressure", "20", Ret$, 255, CSFile$)
        'compression_pressure = Val(Ret$)
        piston_area = val(gpps2("Capstuff", "piston_area", CSFile$, "1"))
        Compression_Increase_Factor = val(gpps2("Capstuff", "Compression_Increase_Factor", CSFile$, "0"))
        TitleScrn.calibmenu(9).Visible = True
        fixed_sample_diameter_cm = val(gpps2("Capstuff", "fixed_sample_diameter_cm", CSFile$, "1")) '6.71.123.14
        use_fixed_sample_diameter_cm = (UCase$(gpps2("Capstuff", "use_fixed_sample_diameter_cm", CSFile$, "N")) = "Y") '6.71.123.14
    End If
    
    If piston_position_transducer_exists Or hasSampleEject Then '6.71.123.01
       
        'piston position transducer
        i = GPPS("Capstuff", "PX1_8", str$(DAC_zero), Ret$, 255, CSFile$)
        PX1(8) = val(Ret$)
        i = GPPS("Capstuff", "PX2_8", str$(DAC_two), Ret$, 255, CSFile$)
        PX2(8) = val(Ret$)
        i = GPPS("Capstuff", "PY1_8", "0", Ret$, 255, CSFile$)
        PY1(8) = val(Ret$)
        i = GPPS("Capstuff", "PY2_8", "110", Ret$, 255, CSFile$)
        PY2(8) = val(Ret$)
    
        i = GPPS("Capstuff", "PX1_9", str$(DAC_zero), Ret$, 255, CSFile$)
        PX1(9) = val(Ret$)
        i = GPPS("Capstuff", "PX2_9", str$(DAC_two), Ret$, 255, CSFile$)
        PX2(9) = val(Ret$)
        i = GPPS("Capstuff", "PY1_9", "0", Ret$, 255, CSFile$)
        PY1(9) = val(Ret$)
        i = GPPS("Capstuff", "PY2_9", "110", Ret$, 255, CSFile$)
        PY2(9) = val(Ret$)
    End If
    
    If slurry_tube_exists Then '6.71.123.01

        'slurry_tube_pressure
        i = GPPS("Capstuff", "PX1_10", str$(DAC_zero), Ret$, 255, CSFile$)
        PX1(10) = val(Ret$)
        i = GPPS("Capstuff", "PX2_10", str$(DAC_two), Ret$, 255, CSFile$)
        PX2(10) = val(Ret$)
        i = GPPS("Capstuff", "PY1_10", "0", Ret$, 255, CSFile$)
        PY1(10) = val(Ret$)
        i = GPPS("Capstuff", "PY2_10", "110", Ret$, 255, CSFile$)
        PY2(10) = val(Ret$)
    End If
    
    i = GPPS("Capstuff", "servo_table_exists", "N", Ret$, 255, CSFile$)
    Servo_Table_Exists = (UCase$(Left$(UCase$(LTrim$(Ret$)), 1)) = "Y")
    
    i = GPPS("Capstuff", "tank_level_exists", "N", Ret$, 255, CSFile$)
    tank_level_exists = (UCase$(Left$(UCase$(LTrim$(Ret$)), 1)) = "Y")
    If tank_level_exists Then
        i = GPPS("Capstuff", "min_tank_fill_level", "80", Ret$, 255, CSFile$)
        min_tank_fill_level = val(Ret$)
        
        i = GPPS("Capstuff", "tank_level_location", "38", Ret$, 255, CSFile$)
        tank_level_location = val(Ret$)
        
        i = GPPS("Capstuff", "tankFullCounts", "63000", Ret$, 255, CSFile$)
        tankFullCounts = val(Ret$)
        i = GPPS("Capstuff", "tankZeroCounts", "2000", Ret$, 255, CSFile$)
        tankZeroCounts = val(Ret$)
    Else
        i = GPPS("Capstuff", "penetro_level_exists", "N", Ret$, 255, CSFile$)
        tank_level_exists = (UCase$(Left$(UCase$(LTrim$(Ret$)), 1)) = "Y")
        If tank_level_exists Then
            i = GPPS("Capstuff", "min_penetro_fill_level", "80", Ret$, 255, CSFile$)
            min_tank_fill_level = val(Ret$)
            
            i = GPPS("Capstuff", "penetro_level_location", "38", Ret$, 255, CSFile$)
            tank_level_location = val(Ret$)
            
            i = GPPS("Capstuff", "penetroFullCounts", "63000", Ret$, 255, CSFile$)
            tankFullCounts = val(Ret$)
            i = GPPS("Capstuff", "penetroZeroCounts", "2000", Ret$, 255, CSFile$)
            tankZeroCounts = val(Ret$)
        End If
    End If
    
    
    'AJB 11-05-09 modified code below to allow the use of a slurry tube or a tank level sensor.
    If slurry_tube_exists Or tank_level_exists Then
        i = GPPS("Capstuff", "slurry_wash_pump_max_flow_cc", "2300", Ret$, 255, CSFile$)
        slurry_wash_pump_max_flow_cc = val(Ret$)
        i = GPPS("Capstuff", "slurry_tube_almost_empty_counts", "20720", Ret$, 255, CSFile$)
        slurry_tube_almost_empty_counts = val(Ret$)
        i = GPPS("Capstuff", "slurry_tube_almost_empty_cm", "2.54", Ret$, 255, CSFile$)
        slurry_tube_almost_empty_cm = val(Ret$)
        i = GPPS("Capstuff", "slurry_tube_almost_full_counts", "57000", Ret$, 255, CSFile$)
        slurry_tube_almost_full_counts = val(Ret$)
        i = GPPS("Capstuff", "slurry_tube_almost_full_cm", "27.94", Ret$, 255, CSFile$)
        slurry_tube_almost_full_cm = val(Ret$)
'        i = GPPS("Capstuff", "slurry_tube_csecarea_cm2", "20.258", Ret$, 255, CSFile$)
'        slurry_tube_csecarea_cm2 = val(Ret$)
'        i = GPPS("Capstuff", "SlurryTankVolume_cc", "7570.0", Ret$, 255, CSFile$)
'        SlurryTankVolume_cc = val(Ret$)
        i = GPPS("Capstuff", "WashTankVolume_cc", "2839.0", Ret$, 255, CSFile$)
        WashTankVolume_cc = val(Ret$)
    End If

    'Square Pore option not available on all machines.  Just init it in Capstuff
    i = GPPS("Capstuff", "SqrPore", "Not_Found", Ret$, 255, CSFile$)
    If nulltrim(Ret$) = "Not_Found" Then
        WPPS "Capstuff", "SqrPore", "N", CSFile$
        SqrPore = False
    Else
        SqrPore = (UCase$(nulltrim(Ret$)) = "Y")
    End If
    
    i = GPPS("Capstuff", "TOPFILL", "N", Ret$, 255, CSFile$)
    TopFill = (UCase$(Left$(UCase$(LTrim$(Ret$)), 1)) = "Y")
    i = GPPS("Capstuff", "CHAMBERS", "1", Ret$, 255, CSFile$)
    chambers = val(Ret$)
    i = GPPS("Capstuff", "Dry_Chambers", "1", Ret$, 255, CSFile$)
    dry_chambers = val(Ret$)
    i = GPPS("Capstuff", "reg_pulse_min", "12", Ret$, 255, CSFile$)
    reg_pulse_min = val(Ret$)
    i = GPPS("Capstuff", "reg_pulse_max", "12", Ret$, 255, CSFile$)
    reg_pulse_max = val(Ret$)

    '**FLOW limits
    i = GPPS("Capstuff", "MAXAIRFLOW", "1000000", Ret$, 255, CSFile$)
    MaxAirFlow = val(Ret$)
    i = GPPS("Capstuff", "MAXLQFLOW", "1000000", Ret$, 255, CSFile$)
    MaxLQFlow(1) = val(Ret$)
    i = GPPS("Capstuff", "MAXLQFLOW2", "1000000", Ret$, 255, CSFile$)
    MaxLQFlow(2) = val(Ret$)
    i = GPPS("Capstuff", "liquid_lohm", "0", Ret$, 255, CSFile$)
    liquid_lohm(1) = val(Ret$)
    i = GPPS("Capstuff", "liquid_lohm2", "0", Ret$, 255, CSFile$)
    liquid_lohm(2) = val(Ret$)
        
    If version >= 7 Then
        Rem read in version 7 specific things
        i = GPPS("Capstuff", "xignore", "10", Ret$, 255, CSFile$)
        i = val(Ret$)
        If i < 0 Then i = 0
        If i > 255 Then i = 255
        xignore = i
        i = GPPS("Capstuff", "xmult", "10", Ret$, 255, CSFile$)
        i = val(Ret$)
        If i < 1 Then i = 1
        If i > 255 Then i = 255
        xmult = CByte(i)
        i = GPPS("Capstuff", "xjiffy", "6", Ret$, 255, CSFile$)
        i = val(Ret$)
        If i < 1 Then i = 1
        If i > 255 Then i = 255
        xjiffy = CByte(i)
    End If

    ' LoopingDemo is for a looping  test demonstration - not something a user
    ' should be accessing, so there is no reference to it in the interface. If LoopingDemo
    ' is set to "Y" and a test is run, it will loop indefinitely until
    ' stopped by the user.
    LoopingDemo = (gpps2("Capstuff", "LOOPINGDEMO", CSFile$, "N") = "Y")

    ' Debug liquid permeability - no reference to it in the interface
    debugH20Perm = (gpps2("Capstuff", "debugh20perm", CSFile$, "N") = "Y")

    ' Same thing for bubble point
    debugBP = (gpps2("capstuff", "debugBP", CSFile$, "N") = "Y")
    
    debugRunCPass = (gpps2("capstuff", "debugRunCPass", CSFile$, "N") = "Y")

    ' recirculation system
    recirculation = (gpps2("capstuff", "recirculation", CSFile$, "N") = "Y")
    doorlock = (gpps2("capstuff", "doorlock", CSFile$, "N") = "Y")
    
    ' allow them to use the tank level sensor even if they don't have recirculation
    'If recirculation Then
        ReserveTankLevelChannel = val(gpps2("Capstuff", "ReserveTankLevelChannel", CSFile$, "-1"))
        If ReserveTankLevelChannel >= 0 Then
            ReserveTankLevelZero = val(gpps2("Capstuff", "ReserveTankLevelZero", CSFile$, "2000"))
            ReserveTankLevelSpan = val(gpps2("Capstuff", "ReserveTankLevelSpan", CSFile$, "62000"))
            ReserveTankFillLightValve = val(gpps2("Capstuff", "ReserveTankFillLightValve", CSFile$, "-1"))
            ReserveTankRefillPercent = val(gpps2("Capstuff", "ReserveTankRefillPercent", CSFile$, "25"))
            ReserveTankLevelMin = val(gpps2("Capstuff", "ReserveTankLevelMin", CSFile$, "85"))
 
        End If
        
    'This is time interval to stop the BP test if the cartridge has leakage and pressure does not build.
    BPTestStopTimeInterval = val(gpps2("Capstuff", "BPTestStopTimeInterval", CSFile$, "500"))
    
    'End If
    ' To enable the chamber liquid level, set the chamber liquid level channel to an absolute channel
    ' for some analog input on the electronics board that is supported by the Rabbit programming.
    ' Be sure to use a channel that is not currently used by anything else for this instrument.
    ChamberLiquidLevelChannel(1) = val(gpps2("Capstuff", "Chamber1LiquidLevelChannel", CSFile$, "-1"))
    If ChamberLiquidLevelChannel(1) >= 0 Then
        ChamberLiquidLevelZero(1) = val(gpps2("Capstuff", "Chamber1LiquidLevelZero", CSFile$, "2000"))
        ChamberLiquidLevelSpan(1) = val(gpps2("Capstuff", "Chamber1LiquidLevelSpan", CSFile$, "62000"))
        ChamberLiquidLevelMin(1) = val(gpps2("capstuff", "Chamber1LiquidLevelMin", CSFile$, "25"))
        ChamberLiquidLevelMax(1) = val(gpps2("capstuff", "Chamber1LiquidLevelMax", CSFile$, "85"))
        
    End If
    ChamberLiquidLevelChannel(2) = val(gpps2("Capstuff", "Chamber2LiquidLevelChannel", CSFile$, "-1"))
    If ChamberLiquidLevelChannel(2) >= 0 Then
        ChamberLiquidLevelZero(2) = val(gpps2("Capstuff", "Chamber2LiquidLevelZero", CSFile$, "2000"))
        ChamberLiquidLevelSpan(2) = val(gpps2("Capstuff", "Chamber2LiquidLevelSpan", CSFile$, "62000"))
        ChamberLiquidLevelMin(2) = val(gpps2("capstuff", "Chamber2LiquidLevelMin", CSFile$, "25"))
        ChamberLiquidLevelMax(2) = val(gpps2("capstuff", "Chamber2LiquidLevelMax", CSFile$, "85"))
    End If

    'Code for the sample ejection system
    hasSampleEject = (gpps2("capstuff", "HasSampleEject", CSFile$, "N") = "Y")
    If hasSampleEject Then
        sampleEjectValve = val(gpps2("Capstuff", "SampleEjectValve", CSFile$, "21"))
    End If
    

    ' valve 23
    valve_23_exists = (gpps2("capstuff", "valve_23_exists", CSFile$, "Y") = "Y")

    ' Frazier Chamber
    If FrazierPressureGauge Then
        FrazierChamberValve = val(gpps2("capstuff", "FrazierChamberValve", CSFile$, "0"))
    Else
        FrazierPiston = False ' can't have a frazier piston if there is no frazier chamber
    End If
    
    ' Determines if the code should use the new or old single point routines.
    useNewSinglePointRoutine = (gpps2("Capstuff", "useNewSinglePointRoutine", CSFile$, "N") = "Y")

    ' Debug menu
    debugMenuVisible = (gpps2("capstuff", "debug_menu_visible", CSFile$, "N") = "Y")
    
    ' Piston delay time - gives chamber a chance to seal for slow pistons
    pistonDelayTime = val(gpps2("capstuff", "piston_delay_time", CSFile$, "0"))
    
    ' pneumaticSwitchValveForPiston - this determines if the piston is controlled by a pneumatic fast switching valve
    ' JF - added 12-30-2009
    pneumaticSwitchValveForPiston = gpps2("capstuff", "pneumaticSwitchValveForPiston", CSFile$, False)

    ' pretreat time - second for pretreatment for dual stage regulators
    pretreat_time = val(gpps2("capstuff", "pretreat_time", CSFile$, "0"))
    
    ' pretreat flow - cc/min for flowing for pretreatment
    pretreat_flow = val(gpps2("capstuff", "pretreat_flow", CSFile$, "0"))

    ' parameter to determine start point of regulator (based on flow through flow controller)
    ' 100% means use SBPP.  10% means use SHFP.
    first_flow_starting_point_percent = val(gpps2("capstuff", "first_flow_starting_point_percent", CSFile$, "100"))
    
' all done reading capstuff.ini file - now set up some things based on what
' we read in

    If AirTop And (DiffPG Or integrity Or (chambers = 1 And H2OPERM)) Then
        v20_exists = True
    Else
        v20_exists = False
    End If
    temp$ = ts$(90) + " " + str$(version) + "  "        ' "Version"
    If lvperm_exclusive Then
        temp$ = temp$ + ts$(92) + vbCrLf                ' "Liquid Vapor Permeameter."
    ElseIf CFAnal Then
        temp$ = temp$ + ts$(94) + vbCrLf                ' "Complete Filter Analyzer."
    ElseIf itester Then
        temp$ = temp$ + ts$(95) + vbCrLf                ' "Integrity Tester."
    ElseIf BPTester Then
        ' 6.71.38x begin
        If hydrohead_exclusive Then
            temp$ = temp$ + ts$(487) + vbCrLf           ' "Hydrohead Tester."
        Else
            temp$ = temp$ + ts$(96) + vbCrLf                ' "Bubble Point Tester."
        End If
        ' 6.71.38x end
    ElseIf WESA_exclusive Then
        temp$ = temp$ + ts$(97) + vbCrLf                ' "Envelope Surface Area Analyzer."
    ElseIf liqpermonly Then
        temp$ = temp$ + ts$(98) + vbCrLf                ' "Liquid Permeameter."
    ElseIf microflowporometer Then
        temp$ = temp$ + ts$(488) + vbCrLf               ' "Microflow Porometer."
    ElseIf GasPerm Then
        temp$ = temp$ + ts$(93) + vbCrLf                ' "Automated Gas Permeameter."
    Else
        If H2OPERM Then
            If Auto_fill And TopFill And version < 7 Then temp$ = temp$ + " " + ts$(99) ' "top"
            If Auto_fill Then temp$ = temp$ + " " + ts$(100)    ' "autofilling"
            temp$ = temp$ + " " + ts$(101) + vbCrLf             ' "Perm-Porometer."
        Else
            temp$ = temp$ + " " + ts$(102) + vbCrLf             ' "Capillary Flow Porometer."
        End If
    End If
    
    ' a 2 chamber system with liquid permeability and gas permeability is not really
    ' considered a multi chamber system
    If chambers > 2 Or (chambers = 2 And (H2OPERM = False Or liqpermonly)) Then
        multiChamberSystem = True
        iso_valve_string$ = gpps2("capstuff", "iso_valve_string", CSFile$, "abcdefghij")
        ' multichamber system with microflow defaults to manual
        manualMultiChamber = (UCase$(gpps2("capstuff", "manualMultiChamber", CSFile$, IIf(DiffPG, "Y", "N"))) = "Y")
    Else
        multiChamberSystem = False
        manualMultiChamber = False
        iso_valve_string$ = "abcdefghij" ' just in case
    End If
    
    If H2OPERM Then
        TitleScrn.Caption = "Automated Perm-Porometer v " + S_Version
        If Auto_fill Then TitleScrn.Caption = "Autofilling Perm-Porometer v " + S_Version
        TitleScrn.Label2.Caption = "Automated Perm-Porometer System Software for Windows"
    Else
        TitleScrn.Caption = "Automated Capillary Flow Porometer v " + S_Version
        TitleScrn.Label2.Caption = "Automated Capillary Flow Porometer System Software for Windows"
    End If
    If CFAnal Then
        TitleScrn.Caption = "Automated Complete Filter Analyzer v " + S_Version
        TitleScrn.Label2.Caption = "Automated Complete Filter Analyzer System Software for Windows"
    End If
    If GasPerm Then
        TitleScrn.Caption = "Automated Gas Permeameter v " + S_Version
        TitleScrn.Label2.Caption = "Automated Gas Permeameter System Software for Windows"
    End If
    If BPTester Then
        ' 6.71.38x begin
        If hydrohead_exclusive Then
            TitleScrn.Caption = "Automated Hydrohead Tester v " + S_Version
            TitleScrn.Label2.Caption = "Automated Hydrohead Tester System Software for Windows"
        Else
            TitleScrn.Caption = "Automated Bubble Point Tester v " + S_Version
            TitleScrn.Label2.Caption = "Automated Bubble Point Tester System Software for Windows"
        End If
        ' 6.71.38x end
    End If
    If WESA_exclusive Then
        TitleScrn.Caption = "Envelope Surface Area Analyzer v " + S_Version
        TitleScrn.Label2.Caption = "Envelope Surface Area Analyzer System Software for Windows"
    End If
    If lvperm_exclusive Then
        TitleScrn.Caption = "Liquid Vapor Permeameter v " + S_Version
        TitleScrn.Label2.Caption = "Liquid Vapor Permeameter System Software for Windows"
    End If
    If itester Then
        TitleScrn.Caption = "Automated Integrity Tester v " + S_Version
        TitleScrn.Label2.Caption = "Automated Integrity Tester System Software for Windows"
        ' disable some stuff in the main menu that can't be used on this machine
        ' cleanout
        TitleScrn.runmenu(3).Visible = False
        ' extra low flow wet data
        'TitleScrn.Extra_Low.Visible = False
        ' linear unit
   '     TitleScrn.filemenu(6).Visible = False
        ' thickness unit
   '     TitleScrn.filemenu(7).Visible = False
        ' curve fit
        TitleScrn.modifymenu(2).Visible = False
        ' data editor
        TitleScrn.modifymenu(3).Visible = False
        ' averager
        TitleScrn.modifymenu(4).Visible = False
        ' cv/ max air flow
        TitleScrn.calibmenu(3).Visible = False
        ' pressure gauge calibration
        TitleScrn.calibmenu(8).Visible = False
    End If
    If liqpermonly Then
        TitleScrn.Caption = "Automated Liquid Permeameter v " + S_Version
        TitleScrn.Label2.Caption = "Automated Liquid Permeameter System Software for Windows"
        ' disable some stuff in the main menu that can't be used on this machine
        ' cleanout
        TitleScrn.runmenu(3).Visible = False
        ' extra low flow wet data
        'TitleScrn.Extra_Low.Visible = False
        ' curve fit
        'TitleScrn.modifymenu(2).Visible = False
        ' data editor
        TitleScrn.modifymenu(3).Visible = False
        ' averager
        TitleScrn.modifymenu(4).Visible = False
        ' cv/ max air flow
        TitleScrn.calibmenu(3).Visible = False
        ' pressure gauge calibration
        TitleScrn.calibmenu(8).Visible = False
    End If
        
    If FrazierTester Then
        TitleScrn.Caption = "Automated Frazier Tester v " + S_Version
        TitleScrn.Label2.Caption = "Automated Frazier Tester System Software for Windows"
    End If

    If unitnumber <> 0 Then
        TitleScrn.Caption = TitleScrn.Caption + " - " + ts$(103) + str$(unitnumber) ' "Unit"
    End If
    
    'AJB 10-30-09 added variable to store a system wide temperature, used with temperature control system.
    safe_temperature = val(gpps2("capstuff", "safe_temperature", CSFile$, "0"))
    'AJB 10-30-09 added varaible to store the number of sample pressure gauges. This is a new feature to switch
    'between top pressure and inline pressure.
    num_sample_pressure_gauges = val(gpps2("capstuff", "num_sample_pressure_gauges", CSFile$, "0"))
    'AJB 10-30-09 added variable to determine if system is a dual sided cartridge tester
    i = GPPS("Capstuff", "cartridge_tester", "N", Ret$, 255, CSFile$)
    cartridge_tester = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    'AJB 11-01-09 added variable to read what is the current side being tested. 0 = media. 1 = cartridge.
    If cartridge_tester Then
        cartridge_tester_side = val(gpps2("capstuff", "cartridge_tester_side", CSFile$, "0"))
        current_unit% = cartridge_tester_side + 1
    End If
    
    manuallySelectedChamber = 1 ' default value
    If (Not multiChamberSystem) And (dry_chambers <= 1) Then
        TitleScrn.chselect.Visible = False
        ' it is now safe to have multiple microflow volumes
        Num_Microflow_Volumes = val(gpps2("capstuff", "Num_Microflow_Volumes", CSFile$, "0"))
'        If Num_Microflow_Volumes >= 1 Then
'            If Num_Microflow_Volumes > 3 Then Num_Microflow_Volumes = 3 ' highest currently supported
'            If Num_Microflow_Volumes = 1 Then
'                Current_Microflow_Volume_Index = 1
'                TitleScrn.volumeSelectHead.Visible = False
'            Else
'                Current_Microflow_Volume_Index = val(gpps2("capstuff", "Current_Microflow_Volume_Index", CSFile$, "1"))
'                If Current_Microflow_Volume_Index < 1 Then Current_Microflow_Volume_Index = 1
'                If Current_Microflow_Volume_Index > Num_Microflow_Volumes Then Current_Microflow_Volume_Index = Num_Microflow_Volumes
'                Microflow_Volume2_Valve = val(gpps2("capstuff", "Microflow_Volume2_Valve", CSFile$, "22"))
'                i = GPPS("Capstuff", "Diff_Volume2", "0", Ret$, 255, CSFile$)
'                Diff_Volume(2) = val(Ret$)
'                If Diff_Volume(2) <= 0 Then MsgBox "Warning:  'Diff_Volume2' parameter not set!"
'                If Num_Microflow_Volumes > 2 Then
'                    Microflow_Volume3_Valve = val(gpps2("capstuff", "Microflow_Volume3_Valve", CSFile$, "23"))
'                    i = GPPS("Capstuff", "Diff_Volume3", "0", Ret$, 255, CSFile$)
'                    Diff_Volume(3) = val(Ret$)
'                    If Diff_Volume(3) <= 0 Then MsgBox "Warning:  'Diff_Volume3' parameter not set!"
'                Else
'                    TitleScrn.selvolume(3).Visible = False
'                End If
'            End If
'            TitleScrn.update_microflow_volume_selection_menu (Current_Microflow_Volume_Index)
'        End If
        If Num_Microflow_Volumes < 1 Then Num_Microflow_Volumes = 1
        If Num_Microflow_Volumes > 3 Then Num_Microflow_Volumes = 3 ' highest currently supported
        If Num_Microflow_Volumes = 1 Then
            Current_Microflow_Volume_Index = 1
           ' TitleScrn.volumeSelectHead.Visible = False
        Else
            Current_Microflow_Volume_Index = val(gpps2("capstuff", "Current_Microflow_Volume_Index", CSFile$, "1"))
            microFlowUseAllVolumes = val(gpps2("capstuff", "microFlowUseAllVolumes", CSFile$, "1"))
            If Current_Microflow_Volume_Index < 1 Then Current_Microflow_Volume_Index = 1
            If Current_Microflow_Volume_Index > Num_Microflow_Volumes Then Current_Microflow_Volume_Index = Num_Microflow_Volumes
            Microflow_Volume2_Valve = val(gpps2("capstuff", "Microflow_Volume2_Valve", CSFile$, "22"))
            i = GPPS("Capstuff", "Diff_Volume2", "0", Ret$, 255, CSFile$)
            Diff_Volume(2) = val(Ret$)
            If Diff_Volume(2) <= 0 Then MsgBox "Warning:  'Diff_Volume2' parameter not set!"
            If Num_Microflow_Volumes > 2 Then
                Microflow_Volume3_Valve = val(gpps2("capstuff", "Microflow_Volume3_Valve", CSFile$, "23"))
                i = GPPS("Capstuff", "Diff_Volume3", "0", Ret$, 255, CSFile$)
                Diff_Volume(3) = val(Ret$)
                If Diff_Volume(3) <= 0 Then MsgBox "Warning:  'Diff_Volume3' parameter not set!"
            Else
               ' TitleScrn.selvolume(3).Visible = False
            End If
        End If
        If microFlowUseAllVolumes Then
           ' TitleScrn.update_microflow_volume_selection_menu (4)
        Else
            'TitleScrn.update_microflow_volume_selection_menu (Current_Microflow_Volume_Index)
        End If

    Else
        'TitleScrn.volumeSelectHead.Visible = False
        Num_Microflow_Volumes = 1 ' you can't have more when you have multiple chambers
        Current_Microflow_Volume_Index = 1
        If (manualMultiChamber = True) Or (dry_chambers > 1) Then
            manuallySelectedChamber = val(gpps2(Curr_U$, "manually_selected_chamber", IFile$, "1"))
            If manuallySelectedChamber < 1 Then manuallySelectedChamber = 1
            If manuallySelectedChamber > chambers Then manuallySelectedChamber = 1
            For unit% = 1 To chambers
                selchamber(unit%) = False
            Next unit%
            selchamber(manuallySelectedChamber) = True
        Else
            For unit% = 1 To chambers
                i = GPPS(Curr_U$, "chamber select" + str$(unit%), "1", Ret$, 255, IFile$)
                selchamber(unit%) = (val(Ret$) >= 1)
            Next unit%
            If chambers < 10 Then
                For unit% = chambers + 1 To 10
                    selchamber(unit%) = False
                Next unit%
            End If
        End If
        If DiffPG Then
            For unit% = 2 To chambers
                i = GPPS("Capstuff", "Diff_Volume" + Format$(unit%), "0", Ret$, 255, CSFile$)
                Diff_Volume(unit%) = val(Ret$)
                If Diff_Volume(unit%) <= 0 Then MsgBox "Warning:  'Diff_Volume" + Format$(unit%) + "' parameter not set!"
            Next unit%
        End If
    End If

    'rvw 4-23-10
    Resin_Diverter_Valve = val(gpps2("capstuff", "Resin_Diverter_Valve", CSFile$, "0"))
    If Resin_Diverter_Valve <> 0 Then
        Resin_Fill_Height = val(gpps2("capstuff", "Resin_Fill_Height", CSFile$, "-4"))
        Resin_Start_Height = val(gpps2("capstuff", "Resin_Start_Height", CSFile$, "0"))
        Resin_Drain_Seconds = val(gpps2("capstuff", "Resin_Drain_Seconds", CSFile$, "30"))
        Resin_Start_Pressure = val(gpps2("capstuff", "Resin_Start_Pressure", CSFile$, "0"))
        Resin_Increment_Pressure = val(gpps2("capstuff", "Resin_Increment_Pressure", CSFile$, "5"))
        Resin_Number_Points = val(gpps2("capstuff", "Resin_Number_Points", CSFile$, "10"))
        Resin_Stable_Seconds = val(gpps2("capstuff", "Resin_Stable_Seconds", CSFile$, "10"))
    End If
    
    'JF 12-2-10

    sampleChamberDiverterValve = val(gpps2("capstuff", "SampleChamberDiverterValve", CSFile$, "-1"))
    If sampleChamberDiverterValve >= 0 Then
        divertSampleChamber = (val(gpps2("Capstuff", "DivertSampleChamber", CSFile$, "0")) = 1)
    End If
    
    'AJB 11-04-09
    i = GPPS("Capstuff", "top_down_lp", "N", Ret$, 255, CSFile$)
    topDownLp = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    
    'AJB 11-05-09
    i = GPPS("Capstuff", "minFPT", "50", Ret$, 255, CSFile$)
    minFPT = val(Ret$)

    'AJB 11-06-09
    i = GPPS("Capstuff", "test_piston", "N", Ret$, 255, CSFile$)
    test_piston = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    
    'AJB 11-11-09
    If Not cartridge_tester Then
    'Commenting this out because the value is never written out to the ini file.
'        i = GPPS("Capstuff", "switch_lp_gauge", "N", Ret$, 255, CSFile$)
'        switchLPGauge = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    End If
    
    'AJB 12-04-09
    i = GPPS("Capstuff", "high_temp_pressure_gauge", "N", Ret$, 255, CSFile$)
    HighTempPressureGauge = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    If HighTempPressureGauge Then
        'read file info
        readNewHighTempCalibrationFile
    End If
    
    'AJB 12-13-09
    i = GPPS("Capstuff", "mv#1_index_char", "B", Ret$, 255, CSFile$)
    mv1_index_char = Left$(Trim(Ret$), 1)
    
'JF CHANGE HERE
    i = GPPS("Capstuff", "has_multiple_mvs", "N", Ret$, 255, CSFile$)
    hasMultipleMVs = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    
    numberOfMotorValves = val(gpps2("Capstuff", "number_of_motor_valves", CSFile$, "1"))
    
    If hasMultipleMVs Then
        'JF added 9-1-10
        TitleScrn.calibmenu(1).Visible = True
        
        i = GPPS("Capstuff", "mv#2_index_char", "`", Ret$, 255, CSFile$)
        mv2_index_char = Left$(Trim(Ret$), 1)
        
        mv2_start_pos = val(gpps2("Capstuff", "mv#2_start_pos", CSFile$, "0"))
        'mv2_reg_pos = val(gpps2("Capstuff", "mv#2_reg_pos", CSFile$, "0"))
        
        If numberOfMotorValves > 2 Then
            i = GPPS("Capstuff", "mv#3_index_char", "S", Ret$, 255, CSFile$)
            mv3_index_char = Left$(Trim(Ret$), 1)
            
            mv3_start_pos = val(gpps2("Capstuff", "mv#3_start_pos", CSFile$, "0"))
            'mv3_reg_pos = val(gpps2("Capstuff", "mv#3_reg_pos", CSFile$, ")"))
        End If
        
        '**valve limits
        i = GPPS("Capstuff", "CLIMIT2", "2000", Ret$, 255, CSFile$)
        CLIMIT2 = val(Ret$)
        i = GPPS("Capstuff", "OLIMIT2", "14000", Ret$, 255, CSFile$)
        olimit2 = val(Ret$)
        
        i = GPPS("Capstuff", "CLIMIT3", "2000", Ret$, 255, CSFile$)
        CLIMIT3 = val(Ret$)
        i = GPPS("Capstuff", "OLIMIT3", "14000", Ret$, 255, CSFile$)
        olimit3 = val(Ret$)
        
        'If we have the second motor valve, we must have one or two extra flow meters.
        '** extra high 1 high
        i = GPPS("Capstuff", "FX1_14", str$(DAC_zero), Ret$, 255, CSFile$)
        FX1(2, 0) = val(Ret$)
        i = GPPS("Capstuff", "FX2_14", str$(DAC_two), Ret$, 255, CSFile$)
        FX2(2, 0) = val(Ret$)
        i = GPPS("Capstuff", "FY1_14", "0", Ret$, 255, CSFile$)
        FY1(2, 0) = val(Ret$)
        i = GPPS("Capstuff", "FY2_14", "500000", Ret$, 255, CSFile$)
        motorValveSwitchFlow = FY2(1, 2) 'save the maximum flow of mv1 side
        FY2(2, 0) = val(Ret$)
    
        '** extra high 1 low
        i = GPPS("Capstuff", "FX1_15", str$(DAC_zero), Ret$, 255, CSFile$)
        FX1(2, 1) = val(Ret$)
        i = GPPS("Capstuff", "FX2_15", str$(DAC_two), Ret$, 255, CSFile$)
        FX2(2, 1) = val(Ret$)
        i = GPPS("Capstuff", "FY1_15", "0", Ret$, 255, CSFile$)
        FY1(2, 1) = val(Ret$)
        i = GPPS("Capstuff", "FY2_15", "100000", Ret$, 255, CSFile$)
        FY2(2, 1) = val(Ret$)
        
        '** high 2 high
        i = GPPS("Capstuff", "FX1_16", str$(DAC_zero), Ret$, 255, CSFile$)
        FX1(2, 2) = val(Ret$)
        i = GPPS("Capstuff", "FX2_16", str$(DAC_two), Ret$, 255, CSFile$)
        FX2(2, 2) = val(Ret$)
        i = GPPS("Capstuff", "FY1_16", "0", Ret$, 255, CSFile$)
        FY1(2, 2) = val(Ret$)
        i = GPPS("Capstuff", "FY2_16", "200000", Ret$, 255, CSFile$)
        FY2(2, 2) = val(Ret$)
    
        '** high 2 low
        i = GPPS("Capstuff", "FX1_17", str$(DAC_zero), Ret$, 255, CSFile$)
        FX1(2, 3) = val(Ret$)
        i = GPPS("Capstuff", "FX2_17", str$(DAC_two), Ret$, 255, CSFile$)
        FX2(2, 3) = val(Ret$)
        i = GPPS("Capstuff", "FY1_17", "0", Ret$, 255, CSFile$)
        FY1(2, 3) = val(Ret$)
        i = GPPS("Capstuff", "FY2_17", "80000", Ret$, 255, CSFile$)
        FY2(2, 3) = val(Ret$)
        
    Else
        motorValveSwitchFlow = 0
        motorValveIndex = 0
    End If
    
    'ajb 12-23-09
    ' 11-10-08 new multiple piston option
    number_of_pistons = val(gpps2("Capstuff", "number_of_pistons", CSFile$, "0"))
    If (number_of_pistons > 3) Then number_of_pistons = 3
    If (number_of_pistons > 0) Then
        piston_valve(1) = val(gpps2("Capstuff", "piston_valve_1", CSFile$, "15"))
    End If
    If (number_of_pistons > 1) Then
        piston_valve(2) = val(gpps2("Capstuff", "piston_valve_2", CSFile$, "26"))
    End If
    If (number_of_pistons > 2) Then
        piston_valve(3) = val(gpps2("Capstuff", "piston_valve_3", CSFile$, "27"))
    End If

    ' 11-19-08 new multiple wetting valve option
    number_of_wetting_valves = val(gpps2("Capstuff", "number_of_wetting_valves", CSFile$, "0"))
    If (number_of_wetting_valves > 3) Then number_of_wetting_valves = 3
    If (number_of_wetting_valves > 0) Then
        wetting_valve(1) = val(gpps2("Capstuff", "wetting_valve_1", CSFile$, "22"))
    End If
    If (number_of_wetting_valves > 1) Then
        wetting_valve(2) = val(gpps2("Capstuff", "wetting_valve_2", CSFile$, "23"))
    End If
    If (number_of_wetting_valves > 2) Then
        wetting_valve(3) = val(gpps2("Capstuff", "wetting_valve_3", CSFile$, "24"))
    End If
    no_chamber_bypass = (0! = val(gpps2("Capstuff", "no_chamber_bypass", CSFile$, "0")))
    
    i = GPPS("Capstuff", "wetting_valves_latch", "N", Ret$, 255, CSFile$)
    wetting_valves_latch = (Left$(UCase$(LTrim$(Ret$)), 1) = "Y")
    
    ' Valve which turn on and off filling pump for the two cartridge tester chambers.
    ' If there is no filling pump, then pump valve numver is -1.
    
    Dim fPumpValveNumber As Double
    fPumpValveNumber = val(gpps2("Capstuff", "PumpValveNumber", CSFile$, "0"))
    PumpValveNumber = CInt(fPumpValveNumber)
    
    
    If cartridge_tester Then
        ReDim Preserve TType%(2)
        ReDim Preserve OutFilename$(2)
        ReDim Preserve OutLogFileName$(2)
        
        ReDim Preserve TMode%(2)
        ReDim Preserve Line1$(2)
        ReDim Preserve Line2$(2)
        ReDim Preserve operator$(2)
        ReDim Preserve lot_number$(2)
        ReDim Preserve sid$(2)
        ReDim Preserve fluid$(2)
        ReDim Preserve surfTen(2)
        ReDim Preserve TPFDRY$(2)
        ReDim Preserve TPFWET$(2)
        ReDim Preserve Diam(2)
        ReDim Preserve innerDiam(2)
        ReDim Preserve outerDiam(2)
        ReDim Preserve cyl_len(2)
        ReDim Preserve minp_set(2)
        ReDim Preserve maxp_set(2)
        ReDim Preserve thick(2)
        ReDim Preserve Hold_Press(2)
        ReDim Preserve Hold_Time(2)
        ReDim Preserve mf_press(2)
        ReDim Preserve mf_time(2)
        ReDim Preserve Hold_Delay(2)
        ReDim Preserve Hold_Rate(2)
        ReDim Preserve Step_Time(2)
        ReDim Preserve Liquid$(2)
        ReDim Preserve LiquidID$(2)
        ReDim Preserve diffpgflow(2)
        ReDim Preserve threestagetest(2)
        ReDim Preserve density(2)
        ReDim Preserve mass(2)
        ReDim Preserve runAsPassFail(2)
        ReDim Preserve stopTestOnFail(2)
        ReDim Preserve minPassDiameter(2)
        ReDim Preserve maxPassDiameter(2)
        ReDim Preserve minMedianPass(2)
        ReDim Preserve maxMedianPass(2)
        ReDim Preserve passFailType(2)
        ReDim Preserve dryChamberTargetTemperature(2)
        ReDim Preserve wetChamberTargetTemperature(2)
        ReDim Preserve reservoirTargetTemperature(2)
        ReDim Preserve airTargetTemperature(2)
        ReDim Preserve bubblerTargetTemperature(2)
        ReDim Preserve cabinetTargetTemperature(2)
        ReDim Preserve hydroHeadTargetTemperature(2)
        ReDim Preserve mullenTargetTemperature(2)
        ReDim Preserve useTemperatureControlForAuto(2)
        ReDim Preserve setTemperatureForAuto(2, 8)
        ReDim Preserve delayTestForTemperature(2, 8)
        ReDim Preserve infoLineValues(2, numberOfAdditionalInfoLines)
        ReDim Preserve runFrazierAsPassFail(2)
        ReDim Preserve minFrazierPass(2)
        ReDim Preserve maxFrazierPass(2)
        ReDim Preserve hhRunAsMullen(2)
        ReDim Preserve hhRunAsBurst(2)
        ReDim Preserve hhRunAsHydrohead(2)
    Else
        ReDim Preserve TType%(chambers)
        ReDim Preserve OutFilename$(chambers)
        ReDim Preserve OutLogFileName$(chambers)
        ReDim Preserve TMode%(chambers)
        ReDim Preserve Line1$(chambers)
        ReDim Preserve Line2$(chambers)
        ReDim Preserve operator$(chambers)
        ReDim Preserve lot_number$(chambers)
        ReDim Preserve sid$(chambers)
        ReDim Preserve fluid$(chambers)
        ReDim Preserve surfTen(chambers)
        ReDim Preserve TPFDRY$(chambers)
        ReDim Preserve TPFWET$(chambers)
        ReDim Preserve Diam(chambers)
        ReDim Preserve innerDiam(chambers)
        ReDim Preserve outerDiam(chambers)
        ReDim Preserve cyl_len(chambers)
        ReDim Preserve minp_set(chambers)
        ReDim Preserve maxp_set(chambers)
        ReDim Preserve thick(chambers)
        ReDim Preserve Hold_Press(chambers)
        ReDim Preserve Hold_Time(chambers)
        ReDim Preserve mf_press(chambers)
        ReDim Preserve mf_time(chambers)
        ReDim Preserve Hold_Delay(chambers)
        ReDim Preserve Hold_Rate(chambers)
        ReDim Preserve Step_Time(chambers)
        ReDim Preserve Liquid$(chambers)
        ReDim Preserve LiquidID$(chambers)
        ReDim Preserve diffpgflow(chambers)
        ReDim Preserve threestagetest(chambers)
        ReDim Preserve density(chambers)
        ReDim Preserve mass(chambers)
        ReDim Preserve runAsPassFail(chambers)
        ReDim Preserve stopTestOnFail(chambers)
        ReDim Preserve minPassDiameter(chambers)
        ReDim Preserve maxPassDiameter(chambers)
        ReDim Preserve minMedianPass(chambers)
        ReDim Preserve maxMedianPass(chambers)
        ReDim Preserve passFailType(chambers)
        ReDim Preserve dryChamberTargetTemperature(chambers)
        ReDim Preserve wetChamberTargetTemperature(chambers)
        ReDim Preserve reservoirTargetTemperature(chambers)
        ReDim Preserve airTargetTemperature(chambers)
        ReDim Preserve bubblerTargetTemperature(chambers)
        ReDim Preserve cabinetTargetTemperature(chambers)
        ReDim Preserve hydroHeadTargetTemperature(chambers)
        ReDim Preserve mullenTargetTemperature(chambers)
        ReDim Preserve useTemperatureControlForAuto(chambers)
        ReDim Preserve setTemperatureForAuto(chambers, 8)
        ReDim Preserve delayTestForTemperature(chambers, 8)
        ReDim Preserve infoLineValues(chambers, numberOfAdditionalInfoLines)
        ReDim Preserve runFrazierAsPassFail(chambers)
        ReDim Preserve minFrazierPass(chambers)
        ReDim Preserve maxFrazierPass(chambers)
        ReDim Preserve hhRunAsMullen(chambers)
        ReDim Preserve hhRunAsBurst(chambers)
        ReDim Preserve hhRunAsHydrohead(chambers)
    End If
    
    update_super_mode
    
    If Not Get_First Then Exit Sub
    
    temp$ = temp$ + ts$(104) + ":" + vbCrLf + vbTab + ts$(105) + " = " + str$(FY2(0, 0) * gasflowconversionfactor) + " cc/min" + vbCrLf      '"INCLUDES"/"Low Flow meter"/"cc/min"
    
    temp$ = temp$ + vbTab + ts$(106) + " 1 = " + str$(FY2(1, 0) * gasflowconversionfactor) + " cc/min" + vbCrLf    ' "High Flow meter"/"cc/min"
    If xhflow Then
        temp$ = temp$ + vbTab + ts$(106) + " 2 = " + str$(FY2(1, 2) * gasflowconversionfactor) + " cc/min" + vbCrLf          ' "High Flow meter"/"cc/min"
        If xhflow_meters > 1 Then
            temp$ = temp$ + vbTab + ts$(106) + " 3 = " + str$(FY2(1, 4) * gasflowconversionfactor) + " cc/min" + vbCrLf          ' "High Flow meter"/"cc/min"
        End If
    End If
    
    temp$ = temp$ + vbTab + ts$(107) + " 1 = " + str$(PY2(0)) + " " + ts$(108) + vbCrLf             ' "Pressure Gauge"/"PSIA"
    If ExtraPG Then temp$ = temp$ + vbTab + ts$(107) + " 2 = " + str$(PY2(2)) + " " + ts$(108) + vbCrLf  ' "Pressure Gauge"/"PSIA"
    If DiffPG Then
        temp$ = temp$ + vbTab + ts$(109) + " = " + str$(PY2(4)) + " " + ts$(108) + vbCrLf            ' "Diff. Press. Gauge"/"PSIA"
        If Not FrazierPressureGauge Then
            temp$ = temp$ + vbTab + ts$(110) + "=" + str$(Diff_Volume(Current_Microflow_Volume_Index + Current_Microflow_Volume_Index - 1)) + " cc" + vbCrLf       ' "volume above sample chamber"/"cc"
        End If
    End If
    If integrity Then temp$ = temp$ + vbTab + ts$(112) + " = " + str$(FY2(0, 1) * gasflowconversionfactor) + "cc/min" + vbCrLf      ' "Integrity meter"/"cc/min"
    temp$ = temp$ + ts$(113) + ":" + vbCrLf + vbTab + str$(MaxAirFlow) + "cc/min " + ts$(114) + " " + vbCrLf + vbTab + str$(MaxLQFlow(penetrometer_select)) + "cc/min " + ts$(115) + vbCrLf + ts$(479) + "." ' "Calibrated flow maxima at"/"cc/min gas"/"cc/min liquid"/"Warning message at 75%"
    If newreg Then
      temp$ = temp$ + vbCrLf + ts$(116)         ' "Motorized Regulator Present"
    ElseIf ip_reg_enable Then
      temp$ = temp$ + vbCrLf + ts$(117)         ' "I/P Regulator Present"
    ElseIf reg5 Then
      temp$ = temp$ + vbCrLf + ts$(118)         ' "Optional 5:1 Regulator Present"
    Else
      temp$ = temp$ + vbCrLf + ts$(119)         ' "Standard 1:1 Regulator Present"
    End If
    MsgBox temp$, 0, ts$(120)                   ' "Machine Specifications"

End Sub

Private Function getNewTemperatureValue(a$) As Integer
Dim b$, i As Integer
b$ = gpps2("Capstuff", a$, CSFile$, "0")
If b$ = "0" Then
    getNewTemperatureValue = 0
ElseIf b$ = "G1" Then
    getNewTemperatureValue = 1
ElseIf b$ = "G2" Then
    getNewTemperatureValue = 2
ElseIf Left$(b$, 1) = "C" And Len(b$) >= 3 Then
    ' PC COMM port value
    ' base is -1 for 1, -3 for 2, etc.
    i = val(Mid$(b$, 2))
    If i < 1 Then
        MsgBox "Illegal temperature value for key " + a$
        getNewTemperatureValue = 0
    Else
        i = 1 - (i * 2)
        If Right$(b$, 1) = "A" Then
            getNewTemperatureValue = i
        ElseIf Right$(b$, 1) = "B" Then
            getNewTemperatureValue = i - 1
        Else
            MsgBox "Illegal temperature value for key " + a$
            getNewTemperatureValue = 0
        End If
    End If
ElseIf Left$(b$, 1) = "R" And Len(b$) = 3 Then
    ' Rabbit pass-through COMM port value
    ' base is 3 for 1, 5 for 2, 7 for 3
    i = val(Mid$(b$, 2))
    If (i < 1) Or (i > 3) Then
        MsgBox "Illegal temperature value for key " + a$
        getNewTemperatureValue = 0
    Else
        i = (i * 2) + 1
        If Right$(b$, 1) = "A" Then
            getNewTemperatureValue = i
        ElseIf Right$(b$, 1) = "B" Then
            getNewTemperatureValue = i + 1
        Else
            MsgBox "Illegal temperature value for key " + a$
            getNewTemperatureValue = 0
        End If
    End If
Else
    MsgBox "Illegal temperature value for key " + a$
    getNewTemperatureValue = 0
End If
End Function

Sub update_super_mode()

    Dim a$
    Dim i As Integer
        
        With TitleScrn
            For i = 2 To 4
                .fileMenu(i).Visible = supervisor
                .modemenu(i).Visible = supervisor
            Next i
            .runmenu(2).Visible = supervisor
            'If chambers < 3 Then
            '    .chselect = False
            'Else
            '    .chselect.Visible = supervisor
            'End If
            If Second_Penetrometer Then
                .penselecthead.Visible = supervisor
            Else
                .penselecthead.Visible = False
            End If
            .reportmenu(2).Visible = supervisor
            .mainmenu(3).Visible = supervisor
            .mainmenu(5).Visible = supervisor
            .modemenu(0).Checked = supervisor
            .modemenu(1).Checked = Not supervisor
            .prefs(0).Visible = supervisor
        End With
    If supervisor Then a$ = "Y" Else a$ = "N"
    WPPS "Capstuff", "supervisor", a$, CSFile$
    
End Sub
Function get_feature_number() As Integer
    
    Dim f1&, f2&
    
    f1& = RSEcho_GA("F", ver2or3, " ")
    f2& = RSEcho_GA("F", ver2or3, vbNullChar)
    If f1& = &H2020 And f2& = 0 And version < 7 Then
        ' no hardware feature number - assume the software one is correct
        get_feature_number = capwin_feature_number
    ElseIf f1& = f2& Then
        ' check high bit for version 7
        If f1& >= 32768 Then
            If version >= 7 Then
                f1& = f1& - 32768
            Else
                MsgBox ts$(122)         ' "Error - check version number of instrument - hardware=7, software=6"
                Stop
            End If
        Else
            If version >= 7 Then
                MsgBox ts$(123)         ' "Error - check version number of instrument - hardware=6, software=7"
                Stop
            End If
        End If
        get_feature_number = f1&
    Else
        MsgBox ts$(124)                 ' "Error reading feature number from instrument"
        Stop
    End If
    
End Function
Function get_filename_from_path(a$) As String
' Return a filename from a complete pathname a$

    Dim position As Integer
    Dim found As Boolean
    Dim pathname$
    
    pathname$ = a$
    If Len(pathname$) < 2 Then get_filename_from_path = 0
    
    found = False
    Do While Not found
        position = InStr(1, pathname$, "\")
        If position = 0 Then
            found = True
        Else
            pathname$ = Right$(pathname$, Len(pathname$) - position)
        End If
    Loop
        
    get_filename_from_path = pathname$
        
End Function

Function get_te_number() As Integer

    ' te number must be present in hardware version 7 and beyond
    
    Dim f1%, f2%
    
    If ComLoc% = 0 Then
        get_te_number = 255
        Exit Function
    End If
    f1% = RSEcho_GA("T", ver2or3, " ")
    f2% = RSEcho_GA("T", ver2or3, vbNullChar)
    If f1% = &H2020 And f2% = 0 And version < 7 Then
        get_te_number = 255
    ElseIf f1% = f2% Then
        get_te_number = f1%
    Else
        MsgBox ts$(125)                 ' "Error reading Test Enable number from instrument"
        If version >= 7 Then Stop
        get_te_number = 255
    End If
    
End Function

' This is done for the marketing purpose and
' and if your desired test file description is missing,
' do not panic - just add it.
Sub GetaFile(Handle As Long)

    Dim fn As Integer

F_Input:
    On Error GoTo 0
    fsel_name$ = ""
    fsel_io = True
    If GasPerm Then
        fsel_title$ = ts$(93) + " " + ts$(126)     ' "Gas Perm Data File"
    ElseIf CFAnal Then
        fsel_title$ = ts$(94) + " " + ts$(126)     ' "CFA Data File"
    ElseIf itester Then
        fsel_title$ = ts$(95) + " " + ts$(126)     ' "Integrity Tester Data File"
    ElseIf BPTester Then
        ' 6.71.38x begin
        If hydrohead_exclusive Then
            fsel_title$ = ts$(489)                  ' "Hydrohead Tester Data File"
        Else
            fsel_title$ = ts$(96) + " " + ts$(126)     ' "Bubble Point Tester Data File"
        End If
        ' 6.71.38x end
    ElseIf WESA_exclusive Then
        fsel_title$ = ts$(97) + " " + ts$(126)     ' "Envelope Surface Area Analysis Data File"
    Else
        fsel_title$ = ts$(102) + " " + ts$(126)     ' "Capillary Flow Data File"
    End If
    fsel_path$ = path(0)
    fsel Handle
    If fsel_return$ = "" Then
        Exit Sub
    End If
    path(0) = fsel_path$
    file$ = fsel_return$

    On Error GoTo Error_input
    fn = FreeFile
    Open file$ For Input As #fn
    Close #fn
    On Error GoTo 0
    Exit Sub

Error_input:
    MsgBox ts$(133), 0, ts$(134)        ' "Error in reading file.  Try another."/"File Error"
    Close #fn
    Resume F_Input
    
End Sub

Sub inc_creg(ByVal i As Integer)

    ' the i value is ignored unless ip_creg_enable is true
    If ip_creg_enable Then
        ' i must be between 0 and 255 or the counter gets messed up
        While i > 255
            Send_RS232b "U3", 255
            i = i - 255
            CREGPOS = CREGPOS + 255
        Wend
        Send_RS232b "U3", CByte(i)
        CREGPOS = CREGPOS + i
        If CREGPOS > 4000 Then CREGPOS = 4000
    Else
        Send_RS232 ("IP")
        If Not manrunning Then
            While RSEcho("VP", 1) <> Asc("S")
                tryhold
            Wend
        End If
    End If
    
End Sub
Sub ParseRemap()

    Dim i As Integer
    Dim MapCommands() As String
    Dim MapCommand() As String
    Dim positionType As String
    'Dim positionType2 As String
    Dim position1, position2 As Integer
    
    ' Initialize the default map values
    For i = 0 To 35
        ValveRemap(i) = i
    Next i
    For i = 0 To 41
        GaugeRemap(i) = i
    Next i
    
    ' Get all of the remap commands
    MapCommands() = split(Remap, ",")

    ' Parse each command seperately
    For i = 0 To UBound(MapCommands)
        
        ' Find what we are changing
        ' Divide the entry by ":"
        MapCommand() = split(MapCommands(i), ":")
        
        ' First character gives us the type of map
        positionType = Left(MapCommand(0), 1)
        
        ' Get positions
        position1 = GetPosByName(MapCommand(0))
        position2 = GetPosByName(MapCommand(1))
        
        ' Map if both positions are valid
        If position1 > -1 And position2 > -1 Then
            ' Valves
            If positionType = "V" Then ValveRemap(position1) = position2
            
            ' Gauges
            If positionType = "P" Or positionType = "F" Or positionType = "T" Then
                GaugeRemap(position1) = position2
                
                ' We also have to remap high readings for that board position
                If position1 = 1 Or position1 = 13 Or position1 = 29 Or position1 = 35 Or position1 = 37 _
                   Or position1 = 41 Or position1 = 3 Or position1 = 11 Or position1 = 5 Or position1 = 9 _
                   Or position1 = 39 Then _
                   GaugeRemap(position1 - 1) = position2
            End If
        End If
    Next i

End Sub

' Takes a 0 indexed valve board position and abuses it into the Ron mapping for that position
Function RonValvePosition(ByVal position As Integer) As Integer

    RonValvePosition = position
    If position = 17 Then RonValvePosition = 25
    If position = 18 Then RonValvePosition = 26
    If position = 22 Then RonValvePosition = 29
    If position = 23 Then RonValvePosition = 30

End Function

' Takes a 0 indexed gauge board postion and adulterates it into the Ron mapping for that position
Function RonGaugePosition(ByVal position As Integer) As Integer

    RonGaugePosition = position
    If position = 0 Then RonGaugePosition = 1     '  1
    'If position = 0 Then RonGaugePosition = 0     '  5  Mapped correctly !?!
    If position = 1 Then RonGaugePosition = 13     '  1
    'If position = 1 Then RonGaugePosition = 12     '  5
    If position = 2 Then RonGaugePosition = 29     '  1
    'If position = 2 Then RonGaugePosition = 28     '  5
    If position = 3 Then RonGaugePosition = 35     '  1
    'If position = 3 Then RonGaugePosition = 34     '  5
    If position = 4 Then RonGaugePosition = 37     '  1
    'If position = 4 Then RonGaugePosition = 36     '  5
    If position = 5 Then RonGaugePosition = 41     '  1
    'If position = 5 Then RonGaugePosition = 40     '  5
    If position = 8 Then RonGaugePosition = 3     '  2
    'If position = 8 Then RonGaugePosition = 2     '  5
    If position = 9 Then RonGaugePosition = 11     '  2
    'If position = 9 Then RonGaugePosition = 10     '  5
    If position = 10 Then RonGaugePosition = 5     '  2
    'If position = 10 Then RonGaugePosition = 4     '  5
    If position = 11 Then RonGaugePosition = 9     '  2
    'If position = 11 Then RonGaugePosition = 8     '  5
    If position = 12 Then RonGaugePosition = 39     '  1
    'If position = 12 Then RonGaugePosition = 38     '  5
    If position = 13 Then RonGaugePosition = 18     '  1
    If position = 14 Then RonGaugePosition = 19     '  2
    If position = 15 Then RonGaugePosition = 20     '  5
    If position = 16 Then RonGaugePosition = 7     '  5
    'If position = 17 Then RonGaugePosition = 17     '  5  Mapped correctly !?!
    If position = 18 Then RonGaugePosition = 16     '  5
    If position = 19 Then RonGaugePosition = 31     '  5
    If position = 20 Then RonGaugePosition = 33     '  5
    If position = 21 Then RonGaugePosition = 32     '  5
    If position = 22 Then RonGaugePosition = 21     '  5
    'If position = 23 Then RonGaugePosition = 23     '  5  Mapped correctly !?!
    If position = 24 Then RonGaugePosition = 22     '  5
    If position = 25 Then RonGaugePosition = 24     '  5
    'If position = 25 Then RonGaugePosition = 26     '  5
    If position = 26 Then RonGaugePosition = 25     '  5
    If position = 28 Then RonGaugePosition = 27     '  1
    If position = 29 Then RonGaugePosition = 6     '  1
    If position = 30 Then RonGaugePosition = 15     '  1
    If position = 31 Then RonGaugePosition = 14     '  5

End Function

' Takes a postion name, such as "F1" or "V3", and converts it to
' the position number used by Capwin
' Returns -1 if parsing fails
' - Mix
Function GetPosByName(position As String) As Integer
    
    Dim positionType As String
    Dim tempval As Integer
    
    On Error GoTo NoMap
    
    ' Special case for the penetrometer
    If position = "PEN" Then
        GetPosByName = RonGaugePosition(29)
        Exit Function
    End If
    
    'Special cases for the MV read positions
    If position = "POS1" Then
        GetPosByName = RonGaugePosition(17)
        Exit Function
    End If
    If position = "POS2" Then
        GetPosByName = RonGaugePosition(18)
        Exit Function
    End If
    If position = "POS3" Then
        GetPosByName = RonGaugePosition(19)
        Exit Function
    End If
    If position = "POS4" Then
        GetPosByName = RonGaugePosition(20)
        Exit Function
    End If
    
    ' First character gives us the type of map
    positionType = Left(position, 1)
    
    ' Valves
    If positionType = "V" Then
        'Parse numerical value
        tempval = val(Mid(position, 2)) - 1
        
        ' Ron map
        GetPosByName = RonValvePosition(tempval)
        
        Exit Function
    
    ' Gauges
    ElseIf positionType = "P" Or positionType = "F" Or positionType = "T" Then
        ' Parse numerical value
        tempval = val(Mid(position, 2)) - 1
        
        ' Shift by position type
        If positionType = "F" Then tempval = tempval + 8
        If positionType = "T" Then tempval = tempval + 16   ' "T" is also for the MV reading positions
        
        'Ron map
        GetPosByName = RonGaugePosition(tempval)
        
        Exit Function
    
    Else
NoMap:
        GetPosByName = -1
    
    End If
    
End Function

' Fires a valve designated to fire when the UseRemap value is changed - Mix
Sub FireOnRemapValve()

    Dim OpenClose As String
    Dim position As Integer

    ' Fire Remap Valve
    If UseRemap And Len(FireOnRemap) > 2 Then
        OpenClose = Left(FireOnRemap, 1)
        If Not OpenClose = "O" And Not OpenClose = "C" Then Exit Sub
        
        position = GetPosByName(Mid(FireOnRemap, 2))
        If position < 0 Then Exit Sub
        
        Move_Valve position, OpenClose
    
    ' Fire UnRemap Valve
    ElseIf Not UseRemap And Len(FireOnUnRemap) > 2 Then
        OpenClose = Left(FireOnUnRemap, 1)
        If Not OpenClose = "O" And Not OpenClose = "C" Then Exit Sub
        
        position = GetPosByName(Mid(FireOnUnRemap, 2))
        If position < 0 Then Exit Sub
        
        Move_Valve position, OpenClose
    End If

End Sub

Sub Servo_Set_Pulse_Width(ByVal PW As Byte)
    Send_RS232b "p", PW
End Sub

Sub Servo_Go(ByVal target As Long)
    Send_RS232l "P", target
End Sub

Sub inc_SlurryPumpSpeed(ByVal i As Integer) '6.71.123.10

    ' i must be between 0 and 255 or the counter gets messed up
    While i > 255
        Send_RS232b "U3", 255
        i = i - 255
        SlurryPumpSpeedPOS = SlurryPumpSpeedPOS + 255
    Wend
    Send_RS232b "U3", CByte(i)
    SlurryPumpSpeedPOS = SlurryPumpSpeedPOS + i
    If SlurryPumpSpeedPOS > 4000 Then SlurryPumpSpeedPOS = 4000

End Sub
Sub lower_SlurryPumpSpeed(ByVal i As Integer) '6.71.123.10

    ' i must be between 0 and 255 or the counter gets messed up
    While i > 255
        Send_RS232b "B3", 255
        i = i - 255
        SlurryPumpSpeedPOS = SlurryPumpSpeedPOS - 255
    Wend
    Send_RS232b "B3", CByte(i)
    SlurryPumpSpeedPOS = SlurryPumpSpeedPOS - i
    If SlurryPumpSpeedPOS < 0 Then SlurryPumpSpeedPOS = 0

End Sub

Sub inc_lfctrl(ByVal i As Integer)

    ' i must be between 0 and 255 or the counter gets messed up
    While i > 255
        Send_RS232b "U2", 255
        lfcpos = lfcpos + 255
        i = i - 255
    Wend
    Send_RS232b "U2", CByte(i)
    lfcpos = lfcpos + i
    If lfcpos > 4000 Then lfcpos = 4000
    
End Sub

Sub inc_reg(ByVal i As Integer)

    ' just in case
    If i <= 0 Then Exit Sub
    ' the i value is ignored unless ip_reg_enable is true
    last_reg_status = False
    If geoPoreValve And geoValveClosed = False Then
        geoIncrease = geoIncrease + 1
    End If
    If newreg Then
        Set_Regulator_Speed
        Send_RS232 ("IEJ" + Chr$(12))
        If Not manrunning Then
            While RSEcho("VE", 1) <> Asc("S")
              tryhold
            Wend
        End If
        Rem REGPOS doesn't have the same meaning for a motorized regulator
        Rem but it helps to keep track of how many times we
        Rem incremented the regulator for some of the auto test
        Rem routines
        
        REGPOS = REGPOS + 1
    ElseIf ip_reg_enable Then
        ' i must be between 0 and 255 or the counter gets messed up
        While i > 255
            Send_RS232b "U1", 255
            i = i - 255
            REGPOS = REGPOS + 255
        Wend
        Send_RS232b "U1", CByte(i)
        REGPOS = REGPOS + i
        If REGPOS > 4000 Then REGPOS = 4000
    Else
        ' standard QuickPulse is 21/1000 sec duration
        ' This is equal to 2.5 * 1/120 sec
        Send_RS232 ("J" + Chr$(3) + "IEIFJ" + Chr$(12))
        REGPOS = REGPOS + 1
    End If
'    increase more than 10 cts, pause for 5 seconds for stability.
    If enableHumidityControlForAutoTests And RUNNING Then
        goToTargetHumidity
    End If
    
End Sub

Sub inc_hreg(ByVal i As Integer)
    If i <= 0 Then Exit Sub
    
    If ip_reg_enable Then
        While i > 255
            Send_RS232b "U" + Trim(str$(humidityRegulatorPosition)), 255
            i = i - 255
            HREGPOS = HREGPOS + 255
        Wend
        Send_RS232b "U" + Trim(str$(humidityRegulatorPosition)), CByte(i)
        HREGPOS = HREGPOS + i
    End If
    
    If HREGPOS > 4000 Then HREGPOS = 4000
End Sub
Sub dec_hreg(ByVal i As Integer)
    If i <= 0 Then Exit Sub
    
    If ip_reg_enable Then
        While i > 255
            Send_RS232b "B" + Trim(str$(humidityRegulatorPosition)), 255
            i = i - 255
            HREGPOS = HREGPOS - 255
        Wend
        Send_RS232b "B" + Trim(str$(humidityRegulatorPosition)), CByte(i)
        HREGPOS = HREGPOS - i
    End If
    
    If HREGPOS < 0 Then HREGPOS = 0
End Sub

Sub zero_hreg()
    Send_RS232 "Z" + Trim(str$(humidityRegulatorPosition))
    HREGPOS = 0
End Sub

Sub Init_For_Ctrl(full As Boolean)

    Dim ftemp%, i As Long, Ret$, i2%
    Dim k As Single
    Dim fn As Integer, fn2 As Integer
    Dim TempFlow As Single
    
    ' full%=false during initial call, true otherwise
    ' if false it skips actual hardware stuff
    'bad_cv_correction = False
    pass = 0: HKey$ = " ": HKey2$ = " "
    holding = False
    want_to_hold = False
    ' get the version number first
    Get_Capstuff
    process_CVtable
    If full = True Then
        Set_Athena Athena2Channel, 0
        Set_Athena Athena1Channel, 0
    End If
    'Initialize Interface Board
    '  for more information on controlling this interface, see docs
    '  for 8255A-5 chip from Intel or AMD.
    '  Initialization of interface board
    Ret$ = String$(255, " ")
    i = GPPS("board.loc", "PA", "-1", Ret$, 255, CSFile$)
    PA = val(Ret$)
    If PA < 0 Then
        MsgBox ts$(135)                     ' "You must set the Comm port before running the instrument"
        PA = 0
    End If

    If TitleScrn.MainComm.PortOpen Then
        TitleScrn.MainComm.PortOpen = False
    End If
      
'    Select Case PA directly follows inserted code
' **********
' Begin COM port code entry for use of a balance entered by
' search for Tim Richards on Tuesday 04 05 25
'
' we can't make changes to the port settings while it is closed.
' close it and then reopen it after the settings are changed.
        If g_bBalanceNotPenet = True Then
            If TitleScrn.AuxComm.PortOpen Then
                TitleScrn.AuxComm.PortOpen = False
            End If
        End If
'
' End COM port code entry by Tim Richards 04 05 25
' **********
COMAGAIN:
    Select Case PA
        Case 0
            ComLoc% = 0 ' demo mode
        Case 1 To 25
            ComLoc% = -1 ' signifies this is not used
            TitleScrn.MainComm.CommPort = PA
        Case Else               'pa has direct port location
            ' this is not valid any more
            MsgBox "Direct comm port addressing not valid any more - resetting to demo mode"
            ComLoc% = 0
            'ComLoc% = PA
            'ComCheck% = ComLoc% + 5
    End Select
    'MsgBox str$(PA)
    If version >= 7 Then
        TitleScrn.MainComm.Settings = "19200,n,8,1"

'    End If directly follows inserted code
' **********
' Begin COM port code entry for use of a balance entered by
' search for Tim Richards on Tuesday 04 05 25
'
' change the settings on this closed port
' note we use com1 always unless the machine is already there
' in which case we switch to com2
        If g_bBalanceNotPenet = True Then
            If PA = 1 Then
                TitleScrn.AuxComm.CommPort = 2
            Else
                TitleScrn.AuxComm.CommPort = 1
            End If
            TitleScrn.AuxComm.Settings = "9600,n,8,1"
        End If
'
' End COM port code entry by Tim Richards 04 05 25
' **********

    End If
    If full Then
        On Error GoTo ComError
        If ComLoc% = -1 Then
            Rem initialize the MSCOM.VBX comm port
            ' it should already be initialized, so just open it
            TitleScrn.MainComm.PortOpen = True
            
'           GoTo OKCOM directly follows inserted code
' **********
' Begin COM port code entry for use of a balance entered by
' search for Tim Richards on Tuesday 04 05 25
'
' open the port to the Mettler balance
            On Error GoTo ComBalanceError

            If g_bBalanceNotPenet = True Then
                TitleScrn.AuxComm.PortOpen = True
            End If
'
' End COM port code entry by Tim Richards 04 05 25
' **********

            GoTo OKCOM
        End If
    End If
    
    GoTo OKCOM

ComError:
      MsgBox ts$(136), 0, ts$(137)          ' "Error in Communication to Instrument"/"Com Error"
      MsgBox str$(Err.Number) + " " + Err.Description
      PA = 0
      ComLoc% = 0
      GoTo COMAGAIN

      'End

' OKCOM: immediately follows inserted code
' **********
' Begin COM port code entry for use of a balance entered by
' search for Tim Richards on Tuesday 04 05 25
'
ComBalanceError:
      MsgBox "Could not establish communication with the balance. " & Chr$(13) & Chr$(10) & _
            "Defaulting to penetrometer code.", 0, ts$(137)

      g_bBalanceNotPenet = False        'we can't use the balance
      
      Resume OKCOM
'
' End COM port code entry by Tim Richards 04 05 25
' **********
           

OKCOM:

    DoEvents
    Send_RS232 ("J" + Chr(12))
    
    If full And bubbler_enable Then
        ' initialize some things if the bubbler is enabled
        Move_Valve 24, "C" ' close valve 25
        Move_Valve 2, "O" ' open both venting valves (that are both plugged in to the same spot)
    End If
    If IS_MMN() = True Then
        Call Move_Valve(5, "O")
        Call Move_Valve(20, "C")
    End If
    MaxLowFlow = (DAC_two - FX1(0, 0)) / (FX2(0, 0) - FX1(0, 0)) * (FY2(0, 0) * gasflowconversionfactor - FY1(0, 0)) + FY1(0, 0)

    load_default_parameters
    
'    If ExtraPG = True Then
'        Sync_Gauges
'    End If

    '  given bublflow, find starting REGPOS value.  Also get sv2p and SHFP
    ' note that in version 6 with motorized regulator,
    ' the value it finds is not REGPOS but position
    ' counts for the regulator.  There is no use for the REGPOS variable in version 6
    ' if you have a motorized regulator.  We were going to have only motorized regulators
    ' in version 6, but then we added back in the pneumatic regulator because it is more
    ' robust.
    On Error GoTo no_cal
    fn = FreeFile
    If liqpermonly Then GoTo cal_ok
    Open EXE_Path$ + "capcal.d8a" For Input As #fn
    If IS_ACPP Then
        Call Send_RS232(">C>M")
        Waitms 200, False
        Call Send_RS232(">O>N")
        Waitms 200, False
        Call Send_RS232(">C>O")
        Waitms 200, False
        Call Send_RS232(">O>P")
    End If
    If low_flow_controller Then
    
        Input #fn, i, f
        
        If i <> -7 Or f <> -7 Then
            MsgBox ts$(138)         ' "Error: The capcal.d8a file is not set for a flow controller instrument"
            ' initialize things for version 7
            
                SV2P = DAC_span * 0.225 ' 4500
          
            SBPP = 1000
            SHFP = 100
            For i = 0 To 40
                flow_cal(i) = i * FY2(0, 0) * gasflowconversionfactor / 40
            Next i
            GoTo cal_ok
        End If
        
        Input #fn, SHFP1 ' for regulator 1
        Input #fn, SBPP1 ' for regulator 1
        ' default is to use the first ones
        SHFP = SHFP1
        SBPP = SBPP1
        ' calibration information is in 100's of counts from 0 to 4000
        For i = 0 To 40
            Input #fn, flow_cal(i)
        Next i
        
            
        regnum = 0 ' default to primary regulator
        ' 6.71.20
        using_low_regulator = False
        If dualregulator Then
            ' dual regulator has second regulator SHFP and SBPP here
            Input #fn, SHFP2
            Input #fn, SBPP2
            If Maxpres > reg1pmax Then
                ' 6.71.20 begin
                ' 6.71.22 - don't use minp_set in this procedure because minp_set is not set until after this procedure finishes
                If second_regulator_starting_point > 0 Then
                    using_low_regulator = True
                    If full Then Move_Valve 16, "C"
                Else
                    ' use second ones
                    SHFP = SHFP2
                    SBPP = SBPP2
                    regnum = 1
                    If full Then Move_Valve 16, "O"
                End If
                ' 6.71.20 end
' we should have already loaded the regulator calibration table since we now keep
' both loaded at all times.
'                ' load second regulator calibration table, if it exists
'
'                If Dir$(EXE_Path$ + "capwinrg2.cal") <> "" Then
'                    fn2 = FreeFile
'                    Open EXE_Path$ + "capwinrg2.cal" For Input As #fn2
'                    Input #fn2, reg_table_size%
'                    ReDim reg_table_pos(reg_table_size%) As Long, reg_table_pres!(reg_table_size%)
'                    For i2% = 1 To reg_table_size%
'                        DoEvents
'                        Input #fn2, reg_table_pos(i2%), reg_table_pres!(i2%)
'                    Next i2%
'                    Close #fn2
'                End If
            Else
                If full Then Move_Valve 16, "C"
'                ' load first regulator calibration table
'                fn2 = FreeFile
'                Open EXE_Path$ + "capwinrg.cal" For Input As #fn2
'                Input #fn2, reg_table_size%
'                ReDim reg_table_pos(reg_table_size%) As Long, reg_table_pres!(reg_table_size%)
'                For i2% = 1 To reg_table_size%
'                    DoEvents
'                    Input #fn2, reg_table_pos(i2%), reg_table_pres!(i2%)
'                Next i2%
'                Close #fn2
            End If  'maxpres > reg1pmax
            
        End If  ' dualregulator
            
        Input #fn, SV2P
        GoTo cal_ok
    End If      ' low flow controller
        
    ' 6.71.20 - next line changed
    If dualregulator And Maxpres > reg1pmax And second_regulator_starting_point = 0 Then
        ' rem skip first regulator calibration information
        Do
            Input #fn, i, f
        Loop Until i = -1 And f = -1
        If full Then
            Move_Valve 16, "O"
        End If
    End If
    
    SBPP = 0: SHFP = 0
    
    If BUBLFLOW <= MaxLowFlow Then
        TempFlow = BUBLFLOW
    Else
        ' if you are running a high flow bubble point, you open the regulator
        ' to the point where you would get 2 cc/min out of the low flow meter
        ' this assumes you have a 10 cc/min low flow meter.  For a 30 cc/min
        ' flow meter this would be 6 cc/min flow
        TempFlow = 0.2 * MaxLowFlow
    End If
    
    Do
        Input #fn, i, f
        If i = -1 And f = -1 Then GoTo REGPOSX
        If f <= TempFlow Then SBPP = i
        If f <= 0.2 Then SHFP = i
    Loop
    
    Do
        DoEvents
        Input #fn, i, f
    Loop While i <> -1 Or f <> -1
    
REGPOSX:
    ' 6.71.20 next line changed
    If dualregulator And (Maxpres <= reg1pmax Or second_regulator_starting_point > 0) Then
        Do
            Input #fn, i, f
        Loop Until i = -1 And f = -1
        
        If full Then
            Move_Valve 16, "C"
        End If
    End If
    
    If SHFP < 3 Then SHFP = 3
    Input #fn, SV2P
    GoTo cal_ok
    
no_cal:

    SV2P = DAC_span * 0.225 ' 4500

    If low_flow_controller Then
        ' initialize things for version 7

            SV2P = DAC_span * 0.225 ' 4500

        SBPP = 1000
        SHFP = 100
        For i = 0 To 40
            flow_cal(i) = i * FY2(0, 0) * gasflowconversionfactor / 40
        Next i
    Else
        SBPP = 10
        SHFP = 10
        If newreg Then
            SBPP = reg_cl
            SHFP = reg_cl
        End If
    End If
    MsgBox ts$(139)         ' "Your CAPCAL.D8A file is corrupted.  Please run flow parameter calibration before any tests."
    Resume cal_ok
    
cal_ok:
    Close #fn
    On Error GoTo 0
    DoEvents
    If full Then
        If status_lights_enable Then
            setStatusLights 1 ' red for initial power up
        End If
        If version >= 7 Then
            ' send the xignore and xmult values
            Send_RS232b "i", CInt(xignore)
            Send_RS232b "m", CInt(xmult)
        End If
        Rem check low range of main pressure gauge to see if machine is turned on
        Pres% = 1
        Rem if low range is less than 10 psi, use high range
        If PY2(Pres%) < 10 Then Pres% = 0

        If PA <> 0 And Not lvperm_exclusive Then
            ReadXReturnX4 2
            ' if you can communicate, then the instrument is turned on.
            
            ' In version 6, if X5 < 10 then there is probably a problem with the pressure gauge
            ' calibration or settings
            If x5 < 10 Or x5 > 20 Then
                MsgBox ts$(141)          ' "Warning:  Check your pressure gauge settings"
            End If
        End If
        ' if valve 12 is a bottom drain valve, we want it open
        ' at all times except when doing liquid permeability
        If Drain12 Then


' **********
' Begin Balance Not Penet code by search for Tim Richards on Thursday 6/17/04 10:16AM
' make sure the iso valve is closed when using a Mettler balance
'
' Tim Richards, 1PM Thursday 6/17/04 AutoTest
' This is the first hit of Valve 12 after you hit the AutoTest menu item. There is no visual feedback first.
' Then after this the testscreen form comes up. There are only 4 hits against valve 12 on the balance
' while there are 7 on the penetrometer.
'
            ' 6.71.81 recirculation needs to keep valve 12 closed normally
            If g_bBalanceNotPenet = True Or recirculation Then
                Move_Valve 11, "C"  'TAR note 040617 'BD 1/4
            Else
                Move_Valve 11, "O"  'TAR note 040617 'not changed '1293 1/7
            End If
'
' End code entered by Tim Richards 6/17/04
' **********
     
        Else
            Move_Valve 11, "C"
        End If
        
        ' close autofill valve if it is present
        Move_Valve 12, "C"
        
        If lvperm_enable Then
            Move_Valve -1, "C"
            Move_Valve -2, "C"
            Move_Valve -3, "C"
            Move_Valve -4, "C"
            Move_Valve -5, "C"
        End If
        If H2OPERM Then
            ' close the penetrometer venting valve
            Move_Valve 8, "C"
            ' if there is a second penetrometer, make sure you close
            ' the other penetrometer venting valve
            ' and other special valves if they exist
            If Second_Penetrometer Then
                penetrometer_select = 3 - penetrometer_select
                If Second_Penetrometer_V9 <> 9 Then Move_Valve 8, "C"
                If Second_Penetrometer_V12 <> 12 Then Move_Valve 11, "C"
                If Second_Penetrometer_V13 <> 13 Then Move_Valve 12, "C"
                penetrometer_select = 3 - penetrometer_select
'                special_ambient = False
'                If Second_Penetrometer And penetrometer_select = 2 Then
'                    If P2PEN20500 < 0 Then special_ambient = True
'                Else
'                    If PEN20500 < 0 Then special_ambient = True
'                End If
            End If
            If valve_23_exists Then
                ' close liquid drain valve
                Move_Valve 22, "C"
            End If
            Dry_Chamber_Control "O"
        End If
        If DiffPG Then
            If FrazierPressureGauge Then
                If FrazierChamberValve > 0 Then
                    Move_Valve FrazierChamberValve - 1, "C"
                End If
            Else
                Move_Valve 13, "O"
            End If
        End If
        If newreg Then
            If PA = 0 Then
                reg_cl = DAC_zero
                reg_ol = DAC_two
            Else
                reg_cl = raw_reading(19)
                reg_ol = raw_reading(20)
            End If
        ElseIf ip_reg_enable Then
            reg_cl = 0
            reg_ol = 4000
        End If
        If autocompress Then
            If ip_creg_enable Then
                creg_cl = 0
                creg_ol = 4000
            ElseIf PA = 0 Then
                creg_cl = DAC_zero
                creg_ol = DAC_two
            Else
                creg_cl = raw_reading(32)
                creg_ol = raw_reading(33)
            End If
            If creg_table_size% = 0 And PA <> 0 Then
                MsgBox ts$(142)     '  "You must calibrate your compression regulator before running a test."
            End If
        End If
        te_number% = get_te_number
        
        ' check the feature number
        If PA <> 0 Then
            ftemp% = get_feature_number()
            If ftemp% <> capwin_feature_number Then
                MsgBox ts$(143) + "  " + "Capstuff=" + str$(capwin_feature_number) + ", " + ts$(144) + "=" + str$(ftemp%) ' "Feature number mismatch."/"hardware"
            End If
        End If
        ' reset the valve 2 limits since it is so easy
        SetV2Limits

        If v20_exists Then
            ' open valve 20
            ' except on recirculation system
            If recirculation Then
                Move_Valve 19, "C"
                ' also make sure that valves 21 and 22 are closed
                Move_Valve 20, "C"
                If v22_exists Then
                    Move_Valve 21, "C"
                End If
            Else
                Move_Valve 19, "O"
            End If
            Move_Valve 19, "O"
        End If
        If dualregulator Then Move_Valve 17, "C" ' close the valve 1 we are not using
        If manualMultiChamber Then
            For i = 1 To chambers
                Move_Valve -i, "C"
            Next i
            Move_Valve -manuallySelectedChamber, "O"
        End If
        If air_inlets > 1 Then
            current_air_inlet = 1
            Move_Valve 15, "C"
        End If
    End If ' if full
    
End Sub


Sub Init_System()

    Dim ZZ As Single, response As Integer
    elev_lqperm_ck = False
    manrunning = False
    If TType%(current_unit%) = 6 And lvperm_enable Then
        Exit Sub
    End If
    Zero_Reg
    If low_flow_controller Then
        zero_lfctrl
    End If
    ' pres% initializing has been moved to later because with i/p converter
    ' the pressure inside the system sometimes won't drop low enough to
    ' legally open valve 11 until some time has passed.
'    If ExtraPG Then
'        Move_Valve 10, "O"
'        Pres% = 2
'    Else
'        Pres% = 1
'    End If
    FUSE% = 0
    'If ExtraPG Then pres% = 2 Else pres% = 1
    Rem special case of MAXFLOW=1 to signify diffpg
    Rem this isn't used any more
    'If MAXFLOW = 1 And DiffPG Then
    '    diffpgflow(current_unit%) = True
    '    Move_Valve 13, "O"
    '    MAXFLOW = MaxHighFlow + 1
    'Else
    '    diffpgflow(current_unit%) = False
    'End If
    Rem open valve 14 anyway if it is there
    If DiffPG Then
      Move_Valve 13, "O"
    End If
    skipincrease = False
    ' 6.71.20 begin
    lflow% = 0: HFLOW% = 1 ' use high range of low flow meter and low range of hflow1
    hflow1_max_index = 0 ' we haven't recorded any secondary flow data yet
    suspend_v10 = False ' move v10 normally
    ' the following is duplicated at the beginning of the high flow section of the test
    ' but it can't hurt to have it here as well
    If xhflow And MAXFLOW > MaxHighFlow Then
        ' there are two high flow meters
        If switch_high_flow_enabled Then
            ' New dual flow meter system stays using hflow1 low range, but sets up some
            ' other things so we can switch to hflow2 when we need it and record hflow2
            ' as we run the test.
            using_hflow1 = True
        Else
            ' this previously only set it to use the low range of hflow1
            ' and set hfmin% to 2 so it wouldn't try to go below 2 and into the
            ' space of hflow1.
            hfmin% = 2: HFLOW% = 3            'set flow to hi meter 1, low range
            using_hflow1 = False
        End If
    Else
        using_hflow1 = False
    End If
    ' 6.71.20 end
    If integrity And MAXFLOW <= FY2(0, 1) * gasflowconversionfactor Then
        integrity_porometry = True
    Else
        integrity_porometry = False
    End If
    Rem read the high flow meter simply to set the flow meter selector valve correctly
    ReadXReturnX4 1
    DoEvents
'    If FrazierPressureGauge And Maxpres <= PY2(4) Then
'        FrazierRunning = True
'        MsgBox "Using External Sample Chamber"
'    Else
'        FrazierRunning = False
'    End If


    If TType%(current_unit%) = 3 And TMode%(current_unit%) = 20 Then
        If FrazierPressureGauge Then
            If FrazierChamberValve = 0 Then
                ' manual selection of frazier chamber
                response = MsgBox(ts$(145), 4)          ' "Do you want to use External Pressure Transducer?"
                If response = vbYes Then
                    FrazierRunning = True
                Else
                    FrazierRunning = False
                End If
            ElseIf Maxpres <= (PY2(4) - PY1(4)) Then
                Move_Valve FrazierChamberValve - 1, "O"
                FrazierRunning = True
            Else
                Move_Valve FrazierChamberValve - 1, "C"
            End If
        Else
            FrazierRunning = False
        End If
    ElseIf FrazierPressureGauge And Not FrazierChamberValve = 0 Then
        Move_Valve FrazierChamberValve - 1, "C"
    End If
    
    Move_Valve 0, "C"               'close valve 1
    Move_Valve 2, "O"               'open valve 3
    If Drain12 Then

' **********
' Begin Balance Not Penet code by search for Tim Richards on Thursday 6/17/04 10:16AM
' make sure the iso valve is closed when using a Mettler balance
'
' Tim Richards, 1PM Thursday 6/17/04 AutoTest
' The yellow "test initializing--please wait" is up but there is still no valve clicking, no machine noise yet
' on the 1293 penetrometer. On the BD with the Mettler there is a click first.
' This is after the user clicked "start test". The penetrometer code inserts an extra step after this
' one which the balance code does not.
'
    If g_bBalanceNotPenet = True Or recirculation Then
            Move_Valve 11, "C"  'TAR note 040617 'BD 2/4
    Else
            Move_Valve 11, "O"  'TAR note 040617 'not changed '1293 2/7
    End If
'
' End code entered by Tim Richards 6/17/04
' **********

    End If
    If bubbler_enable Then
        ' leave valve 25 closed for now.  We will open valve 25 right before we actually start applying pressure.
        Move_Valve 24, "C"
    End If
    Dry_Chamber_Control "O"               'close valve 4
    DoEvents
    If slurry_tube_exists Then '6.71.123.19
        Move_Valve Slurry_tube_vent_valve, "C" 'slurry tube vent valve V29
    End If
    If H2OPERM Then
        Move_Valve 8, "C"
    End If
    If hfmin% = 0 Then
        Move_Valve 9, "C"
        vflow% = 0
    End If
    If hfmin% = 2 Then
        Move_Valve 9, "O"
        vflow% = 1
    End If
    ' 6.71.20
    suspend_v10 = False

    excercize_valve_2
    ' it should now be safe enough to open valve 11
    If ExtraPG Then
        Move_Valve 10, "O"
        Pres% = 2
    Else
        Pres% = 1
    End If
    If Aborted Then Exit Sub                        '5/26/93 JP, v6.52.04
    
    ' This 3 second delay has been commented out on 11-14-01 to see if it is
    ' necessary or not.  If there are problems, it may be put back in
    ' This delay was added in the QuickBasic code and was probably there just
    ' so that the display telling that the system was working properly would
    ' have time to be read.  This display was not converted to VB1, but the
    ' delay was!
'    ZZ = Timer
'    While (Timer - ZZ) < 3
'    DoEvents
'    Wend
    V2FACTR = 1: PWFACTR = 1
    ' v2factr is multiple of v2incr that we use to open
    ' valve 2 facter as the test goes on
    ' pwfactr is the multiplier for the pulsewidth of the motor

End Sub

' f is flow, fm% is currently selected flowmeter, j% is high/low pressure gauge
Function intermediate_CV(fm%, j%, f)

    Dim i%
    
    Rem note we have to pass raw standard flow, not Qvol with the new Lohm Equation
    Rem This is the interpolation routine for CV values - new as of 4/96
    Rem Added by jsd
    Rem we also pass a 0 or 1 - 0 for high pressure gauge, 1 for low pressure gauge

    If cv_table_size%(fm%) <= 0 Then
      intermediate_CV = 0 ' the only case where the lohm table has no entries is for a system with no pressure drop
      Exit Function
    End If
    
    If cv_table_size%(fm%) = 1 Then
        intermediate_CV = intermediate_CV_Value!(fm%, j%, 1)
        Exit Function
    End If

    Rem find the point just below the flow rate of interest.
    
    i% = 1
    While CV_flow!(fm%, i%) <= f And i% < cv_table_size%(fm%)
          i% = i% + 1
    Wend
    ' either CV_flow!(i%) is > QVol or i% > cv_table_size%
    Rem if below the minimum calibrated flow rate, and below
    Rem the flow rate corresponding to the max CV calibrated
    Rem assume CV is simply the max CV value

    If i% <= First_Good_CV_Index%(j%) Then
      intermediate_CV = intermediate_CV_Value!(fm%, j%, First_Good_CV_Index%(j%))
      Exit Function
    End If
    
    If i% = cv_table_size%(fm%) Then
        intermediate_CV = intermediate_CV_Value!(fm%, j%, cv_table_size%(fm%))
        Exit Function
    End If
    
    Rem Line below performs linear interpolation and returns estimated CV
    intermediate_CV = (((f - CV_flow!(fm%, i% - 1)) / (CV_flow!(fm%, i%) - CV_flow!(fm%, i% - 1))) * (intermediate_CV_Value!(fm%, j%, i%) - intermediate_CV_Value!(fm%, j%, i% - 1))) + intermediate_CV_Value!(fm%, j%, i% - 1)

End Function

Sub LeakTest()

    Dim T As Single
    Dim Top_P As Single
    Dim t121t$
    Dim n121 As Single
    Dim tstart As Single
    Dim k As Single
    Dim Step_P As Single
    Dim Wait_T As Single
    Dim p_index%, i%, temp$
    Dim b As Single
    Dim E As Single
    Dim passed As Single
    Dim Atm_P As Single
    Dim NCLIMIT As Long
    Dim retval As Double
    Dim fn As Integer
    Static Leak(2, 50)
    Static Target_P
    Dim leaktestfile As String
    Dim L As Long
    Dim leak_test_aborted As Boolean

    Dim pressure_ramp_counter As Integer 'AJB 10-21-09
    Dim ramp_start_pressure As Single 'AJB 10-21-09
    Dim intResponse As Integer
    
    'AJB 12-22-09
    motorValveIndex = 0
    Zero_Reg
    Move_Valve 2, "O"                   'open drain valve
    'T = Timer
    'While Timer - T < 5: DoEvents: Wend
    waitseconds 5
    If multiChamberSystem = False Or manualMultiChamber = True Then
        MsgBox ts$(44), 0, ts$(148)     ' "Place Non-porous Insert in Chamber and Seal."/"Leak Test Setup"
    Else
        For current_unit% = 1 To chambers
            If selchamber(current_unit%) Then
                MsgBox ts$(149) + str$(current_unit%) + " " + ts$(150), 0, ts$(148)     ' "Place Non-porous Insert in Chamber"/"and seal"/"Leak Test Setup"
                Move_Valve -current_unit%, "O"
            Else
                Move_Valve -current_unit%, "C"
            End If
        Next current_unit%
        current_unit% = 1
    End If
    ' 6.71.47 use piston if it is there and they have set a compression pressure
    If autopiston Or (autocompress And compression_pressure <> 0 And (current_unit% = 1 Or current_unit% <= number_of_pistons)) Then
        If safetydown Then
            If safetydowndoor Then
                ' do auto door switch thing instead of key press thing
                check_safety_door True
            Else
                safetykeypress.mainlabel.Caption = ts$(206) ' "Piston About To Lower"
                safetykeypress.Show 1
            End If
            If safety_canceled Then
                Exit Sub
            End If
        ElseIf autopiston Then
            check_safety_door True
            If safety_canceled Then
                Exit Sub
            End If
        End If
        move_piston "O"
        ' 6.71.61 Give piston time to close
'        T = Timer
'        While (Timer - T <= pistonDelayTime): DoEvents: Wend
'        waitseconds pistonDelayTime
        '****
    End If
    
    If FrazierPressureGauge And Not FrazierChamberValve = 0 Then
        Move_Valve FrazierChamberValve - 1, "C"
    End If
    
    If status_lights_enable Then setStatusLights 2
    ' from here on, if they abort the test we need to raise the piston
    ' so we can't just exit the sub
    leak_test_aborted = False
    If ExtraPG Then                     'do not use extra pres. gauge
        Move_Valve 10, "C"              'close extra pres. gauge valve
    End If
    Pres% = 0                           'read pressures from pressure gauge 1, high range
    ReadXReturnX4 2                     'read atm. pressure
    Atm_P = x5              ' changed:  now store Atm_P in internal PSI units
    Move_Valve 0, "C"                   'close BP valve
    Move_Valve 2, "C"                   'close drain valve

    Rem new code which takes 5:1 regulator into account and will not let the user enter
    Rem a pressure greater than the maximum pressure of the machine
    GetValue.Label1.Caption = ts$(151) + ": " + PU$     ' "Enter Maximum Pressure (differential)"
    If leak_max_p > 0 Then
        GetValue.Text1.Text = str$(leak_max_p * PCNV)
    ElseIf reg5 Then
        GetValue.Text1.Text = str$(30 * PCNV)
    Else
        GetValue.Text1.Text = str$(Int((PY2(0) - Atm_P) * PCNV))
    End If
    GetValue.Text1.SelStart = 0
    GetValue.Text1.SelLength = 10
    GetValue.Continue.default = True
    GetValue.Show 1
    If Got_Value <> -9 And reg5 And ((Got_Value / PCNV) + Atm_P) <= (Atm_P + (30 * PCNV)) Then
      Top_P = Got_Value / PCNV
    ElseIf Got_Value <> -9 And (Not reg5) And Int((Got_Value / PCNV) + Atm_P) <= PY2(0) Then
      Top_P = Got_Value / PCNV
    ElseIf Got_Value = -9 Then
        leak_test_aborted = True
        'Exit Sub
    ElseIf reg5 Then
      MsgBox (ts$(152) + " 30 PSIG" + vbCrLf + "    " + ts$(153) + " 30 PSIG") ' Pressure Exceeds Maximum Differential Pressure of"+" "+"30 PSIG"/"Rerun and Enter Pressure (Differential) Lower Than"+" "+"30 PSIG"
      leak_test_aborted = True
      'Exit Sub
    Else
      MsgBox (ts$(152) + str$((PY2(0) - Atm_P) * PCNV) + vbCrLf + "    " + ts$(153) + str$((PY2(0) - Atm_P) * PCNV))   ' "Pressure Exceeds Maximum Differential Pressure of"/"Rerun and Enter Pressure (Differential) Lower Than"
      leak_test_aborted = True
      'Exit Sub
    End If
    
    ' MsgBox ("Pressure Exceeds Maximum Differential Pressure of" + Str$(PY2(0) - Atm_P) + vbcrlf + "    Rerun and Enter Pressure (Differential) Lower Than" + Str$(PY2(0) - Atm_P))
    
    If Not leak_test_aborted Then
        GetValue.Label1.Caption = ts$(155) + ": " + PU$     ' "Enter Step Pressure"
        If leak_step_p <= 0 Then leak_step_p = 10
        GetValue.Text1.Text = str$(leak_step_p * PCNV)
        GetValue.Text1.SelStart = 0
        GetValue.Text1.SelLength = 10
        GetValue.Continue.default = True
        GetValue.Show 1
        If Got_Value <> -9 Then
            Step_P = Got_Value / PCNV
        Else
            leak_test_aborted = True
            'Exit Sub
        End If
        If Step_P > Top_P And Not leak_test_aborted Then
            MsgBox ts$(156)             ' "Step pressure too high - setting step pressure to equal maximum pressure"
            Step_P = Top_P
        End If
    End If
    If Not leak_test_aborted Then
        GetValue.Label1.Caption = ts$(157) + ":"        ' "Enter Wait Time (min)"
        If leak_wait <= 0 Then leak_wait = 5
        GetValue.Text1.Text = str$(leak_wait)
        GetValue.Text1.SelStart = 0
        GetValue.Text1.SelLength = 10
        GetValue.Continue.default = True
        GetValue.Show 1
        If Got_Value <> -9 Then
            Wait_T = Got_Value
        Else
            leak_test_aborted = True
            'Exit Sub
        End If
    End If
    If Not leak_test_aborted Then
        temp$ = ts$(158) + str$((Step_P) * PCNV) + " " + ts$(159)   ' "The program will acquire readings from"/"to"
        temp$ = temp$ + str$((Top_P) * PCNV) + " " + PU$ + " " + ts$(160) + ", " + ts$(161) + str$(Step_P * PCNV) + " " + PU$      ' "(Gauge)"/"in"
        temp$ = temp$ + " " + ts$(162) + str$(Wait_T) + " " + ts$(163)    ' "increments, waiting"/"minutes between each point."
        reply% = MsgBox(temp$, 1, ts$(148))         ' "Leak Test Setup"
        If reply% = 2 Then leak_test_aborted = True
    End If
    If Not leak_test_aborted Then
        leak_max_p = Top_P
        leak_step_p = Step_P
        leak_wait = Wait_T
        save_user_global_stuff
    End If
    
    If PA = 0 Then
        'If Not nowait_at_end Then
        MsgBox ts$(164), 0, ts$(165)        ' "This is as far as you can go with the demo program"/"Auto Test Demo"
        'End If
        'leak_test_aborted = True 'AJB to test
    End If
    
    If leak_test_aborted Then
        If autocompress Or autopiston Then
            If safetyup And Vpos(15) = 1 Then
                If safetyupdoor Then
                    ' do auto door switch thing instead of key press thing
                    check_safety_door False
                Else
                    safetykeypress.mainlabel.Caption = ts$(166)     ' "Piston About To Raise"
                    safetykeypress.cancelbutton.Visible = False
                    safetykeypress.Show 1, progress
                End If
            End If
            move_piston "C"
        End If
        If status_lights_enable Then setStatusLights 1
        Exit Sub
    End If
    
    ' 6.71.50 switch regulators if necessary to read the maximum pressure
    If dualregulator Then
        If Top_P > reg1pmax Or use_second_regulator_only Then
            Move_Valve 16, "O"
            regnum = 1
            If (air_inlets = 2) Then
                Move_Valve 15, "O"
                current_air_inlet = 2
            End If

        Else
            Move_Valve 16, "C"
            regnum = 0
            If (air_inlets = 2) Then
                Move_Valve 15, "C"
                current_air_inlet = 1
            End If

        End If
    End If
    ' 6.71.50 end
    ' 6.71.102 switch air inlets if necessary
    If air_inlets > 1 And Top_P > air_inlet_1_max_p Then
        Move_Valve 15, "O"
        current_air_inlet = 2
    End If
    
    Wait_T = Wait_T * 60            'convert min. to sec.
    Target_P = Atm_P                'initialize target pressure to atm. pressure
    p_index% = 0                     'index for points taken
    Msgform.ok.Visible = False
    Msgform.Label1.Visible = False
    Msgform.lb.Visible = False
    Msgform.Show 0
    Msgform.Caption = "CapWin - " + ts$(167)        ' "LeakTest"

    fn = FreeFile
    leaktestfile = EXE_Path$ + "leaktest_" + Format(str$(now), "mmddyy_hhmm") + ".asc"
    Open leaktestfile For Output As #fn
    Print #fn, ts$(168) + " "; PU$              ' "Note: All Pressures Are Absolute"
    Print #fn, "PI", "PF", ts$(169)             ' "Rate(%/Hr)"

    While Target_P < (Top_P + Atm_P) - 0.05 And Not leak_test_aborted
        p_index% = p_index% + 1
        Target_P = Target_P + Step_P
        If Target_P > (Top_P + Atm_P) Then Target_P = (Top_P + Atm_P)
        Msgform.Show 0
        Msgform.Label.Caption = ts$(170) + str$((Target_P) * PCNV) + " " + PU$ + " (" + ts$(171) + ")"  ' "Raising Pressure to"/"(Absolute)"
        Msgform.Refresh
        OPENV2MOSTLY
        Move_Valve 0, "O"
        If low_flow_controller Then
            set_lfctrl 4000
        End If
        Cancel_Aborted = False
        Rem Added By JSD To improve version 6 leak test.  Now goes immediately to regpos from cal
        Rem IF leak test p > than calibrated pressure, simply hunts for pressure as before
        If newreg And reg_table_size(regnum) > 0 Then
            If regnum = 0 Then
                If reg_table_pres!(reg_table_size%(0)) >= (Target_P - Atm_P) Then
                    openv2completely
                    move_motorized_regulator_to_pressure (Target_P - Atm_P)
                    ' just go to pdiff since reg cal table is in terms of pdiff.
                    ReadXReturnX4 2             'read pressure
                    Msgform.Show 0
                    Msgform.Label.Caption = ts$(172) + str$((Int(x5 * PCNV * 100)) / 100) + " " + PU$ + " (" + ts$(171) + ")"   ' "Pressure at"/"Absolute
                    Msgform.Refresh
                End If
            Else
                If reg_table_pres2!(reg_table_size%(1)) >= (Target_P - Atm_P) Then
                    openv2completely
                    move_motorized_regulator_to_pressure (Target_P - Atm_P)
                    ' just go to pdiff since reg cal table is in terms of pdiff.
                    ReadXReturnX4 2             'read pressure
                    Msgform.Show 0
                    Msgform.Label.Caption = ts$(172) + str$((Int(x5 * PCNV * 100)) / 100) + " " + PU$ + " (" + ts$(171) + ")"   ' "Pressure at"/"Absolute
                    Msgform.Refresh
                End If
            End If
        End If
        pressure_ramp_counter = 0 'AJB 10-21-09
        ReadXReturnX4 2 'AJB 10-21-09
        ramp_start_pressure = x5 'AJB 10-21-09
        While ((Int(x5 * 100)) / 100) <= Target_P And Not leak_test_aborted
            pressure_ramp_counter = pressure_ramp_counter + 1 'AJB 10-21-09
            inc_reg 10
            ReadXReturnX4 2             'read pressure
            Msgform.Show 0
            Msgform.Label.Caption = ts$(172) + str$((Int(x5 * PCNV * 100)) / 100) + " " + PU$ + " (" + ts$(171) + ")"   ' "Pressure at"/"absolute"
            Msgform.Refresh
            DoEvents
            If Cancel_Aborted Then
                Target_P = x5 - 0.1
                Top_P = x5 - Atm_P - 0.1
                Cancel_Aborted = False
            End If
            
            'AJB 10-21-09 - Updated 10-29-09 - was (pressure_ramp_counter > 200 And x5 <= Target_P)
            If pressure_ramp_counter > 400 And x5 <= Target_P / 5 Then
                intResponse = MsgBox("The pressure is not rising, please ensure the gas is turned on. Press Ok to continue or Cancel to quit", vbOKCancel, "System Error")
                
                If intResponse = vbCancel Then
                    MsgBox "Turning off regulator and quiting leak test"
                    Zero_Reg
                    Cancel_Aborted = True
                    leak_test_aborted = True
                Else
                    pressure_ramp_counter = pressure_ramp_counter - 100
                End If
            End If
            
        Wend
        ' cancel_aborted = False

        DoEvents
        
        If Not leak_test_aborted Then
            'JF 8-31-2010
            'Made changes to the leak test so it would close all motor valves completely before continueing
            'with the leak test.
            If Not hasMultipleMVs Then
                Send_RS232 "C" + mv1_index_char
                While RSEcho("V" + mv1_index_char, 1) <> Asc("S")
                Wend
            Else
                Send_RS232 "C" + mv1_index_char
                While RSEcho("V" + mv1_index_char, 1) <> Asc("S")
                Wend
                
                Send_RS232 "C" + mv2_index_char
                While RSEcho("V" + mv2_index_char, 1) <> Asc("S")
                Wend
                
                If numberOfMotorValves > 2 Then
                    Send_RS232 "C" + mv3_index_char
                    While RSEcho("V" + mv3_index_char, 1) <> Asc("S")
                    Wend
                End If
            End If
        
'            Send_RS232 ("CB")
'            Debug.Print "Close MV#1"
'            If hasMultipleMVs Then
'                Send_RS232 ("C`")
'                Debug.Print "Close MV#2"
'
'                If numberOfMotorValves > 2 Then
'                    Send_RS232 ("C" + mv3_index_char)
'                    Debug.Print "Close MV#3"
'                End If
'            End If
            
            NCLIMIT = DAC_over + 1
            T = Timer

            Do
                ReadXReturnX4 3
                If x4 < NCLIMIT Then NCLIMIT = x4: T = Timer
                If Timer + 0.1 < T Then T = T - 86400!
                DoEvents
            Loop While Timer - T < 1
            NCLIMIT = NCLIMIT + 1

            Send_RS232 ("S" + mv1_index_char)

            Move_Valve 0, "C"                   'close BP valve
            If low_flow_controller Then zero_lfctrl
            'k = Timer
        
            If leak_test_delay = -1 Then leak_test_delay = 0.3                  ' 0.3 was a fixed delay previously
            waitseconds leak_test_delay
            'While (Timer - k < leak_test_delay) And (Timer >= k): DoEvents: Wend
    
            ReadXReturnX4 2                 'read start pressure
            Leak(1, p_index%) = x5           'save to array

            Msgform.Show 0
            Msgform.Label1.Visible = True
            Msgform.Label1.Caption = ts$(173) + " " + str$(Wait_T / 60) + " " + ts$(75)      ' "Waiting for"/"min."
            Msgform.Refresh
            'If Cancel_Aborted Then Exit Sub
            tstart = Timer: t121t$ = time$
            Msgform.lb.Visible = -1
            ' 6.71.25
            ' this one is trickier - we want to delay wait_t seconds, but we also want to
            ' update the status bar and allow them to cancel the time delay
            ' If we make the button that sets Cancel_Aborted also set the global abort_timer,
            ' then we can use the new waitms command to wait the amount of time between the times
            ' when we need to update the display, or some reasonable amount if that would be too
            ' short a delay
            ' We aren't making the cancel_aborted button cancel the time delay because it is used
            ' in other things where we don't want it to cancel the timeout of the serial port
            ' Instead, we give a maximum delay time of 3 seconds.  Anyone should be able to wait
            ' 3 seconds for the cancel to take effect (you rarely use it) and it won't slow things
            ' down if we take control every 3 seconds even if we don't need to.
            ' 3 seconds was chosen because a wait of longer than that may cause the user to
            ' think that something is wrong.
            ' The width of the display is msgform.lb.width twips
            ' The width in pixels is msgform.lb.width / twipsperpixelx
            ' The amount of time we are waiting is wait_t
            ' so the wait per pixel is wait_t / number of pixels
            L = Wait_T * 1000 / (Msgform.lb.Width / Screen.TwipsPerPixelX)
            ' In the case of a really short wait, we don't want our delay shorter than 0.1 seconds
            If L < 100 Then L = 100
            ' make delay no longer than 3 seconds
            If L > 3000 Then L = 3000
            Do
                If Timer + 0.1 < tstart Then tstart = tstart - 86400!       'check for changed day
                n121 = ((Timer - tstart) * Msgform.lb.Width) / Wait_T   'set status bar position
                Msgform.lb.Line (0, 0)-(n121, 135), &HFF0000, BF        'update status bar
                Waitms L, False
                'DoEvents
                ReadXReturnX4 2
                Msgform.Label.Caption = ts$(172) + str$((Int(x5 * PCNV * 100)) / 100) + " " + PU$ + " (" + ts$(171) + ")"   ' "Pressure at"/"absolute"
                Msgform.Refresh
            Loop While (Timer - tstart) < Wait_T And Not Cancel_Aborted
            Msgform.lb.Visible = 0
            DoEvents
            'If Cancel_Aborted Then Exit Sub
            ReadXReturnX4 2                     'read end pressure
            Leak(2, p_index%) = x5               'save to array
            b = Leak(1, p_index%)
            E = Leak(2, p_index%)
            If b > 0 Then
                Print #fn, b * PCNV, E * PCNV, Format$((3600 / Wait_T) * (b - E) / b, "#0.##%")
            End If
        End If
    Wend
    
    Close #fn
    
    Move_Valve 2, "O"                       'leaktest complete, release pressure
    Msgform.Caption = "CapWin"
    Unload Msgform
    Zero_Reg
    'Move_Valve 2, "C"
    Rem leave valve 3 open.  Also excercize valve 2 to drain pressure out of regulator
    excercize_valve_2
    If ExtraPG Then
        Move_Valve 10, "O"
        Pres% = 2
    End If
    ' 6.71.102 switch back to air inlet 1, if necessary
    If air_inlets > 1 And current_air_inlet = 2 Then
        Move_Valve 15, "C"
        current_air_inlet = 1
    End If
    ' 6.71.47 unload compression piston at the end
    If autocompress Or autopiston Then
        If safetyup And Vpos(15) = 1 Then
            If safetyupdoor Then
                ' do auto door switch thing instead of key press thing
                check_safety_door False
            Else
                safetykeypress.mainlabel.Caption = ts$(166)     ' "Piston About To Raise"
                safetykeypress.cancelbutton.Visible = False
                safetykeypress.Show 1, progress
            End If
        End If
        move_piston "C"
    End If
    If status_lights_enable Then setStatusLights 1
    'AJB 10-21-09
    'This whole section was reworked to differentiate between an aborted test and pass/fail test.
    If Not leak_test_aborted Then
        temp$ = ""
        passed = True
        For i% = 1 To p_index%
            b = Leak(1, i%)
            E = Leak(2, i%)
            If ((3600 / Wait_T) * (b - E) / b) > leakTestPassPercent Then passed = False 'fail if leak > 5%/hr
        Next i%
        If passed Then
            temp$ = " " + ts$(174) + " "        ' "passed"
        Else
            temp$ = " " + ts$(175) + " "        ' "failed"
        End If
        temp$ = ts$(176) + temp$ + ts$(177) + " " + vbCrLf + ts$(178) + str$(Step_P * PCNV) + " " + ts$(159) + str$(Top_P * PCNV) + " " + PU$ + " (" + ts$(179) + ")." + vbCrLf + ts$(180) ' "The instrument"/"the leak test"/"over the range of"/"to"/"differential"/ "Do you wish to see the collected data?"
        reply% = MsgBox(temp$, 4, ts$(167))     ' "LeakTest"
        MsgBox ts$(181), 0, ts$(77)              ' "Leak Test finished. Remove non-porous insert."/"Done"
        If reply% = 6 Then retval = Shell("notepad.exe " + leaktestfile, 3)
    Else
        MsgBox "User Aborted Leak Test", vbOKOnly
        MsgBox ts$(181), 0, ts$(77)              ' "Leak Test finished. Remove non-porous insert."/"Done"
        
    End If
    
End Sub

Sub load_default_parameters()

    Dim fn As Integer
    
    On Error GoTo no_def
    fn = FreeFile
    Open EXE_Path$ + "users\" + Curr_U$ + "\default.tpf" For Input As #fn
        Input #fn, PULSEWIDTH: Input #fn, V2INCR
        Input #fn, BUBLTIME: Input #fn, BUBLFLOW
        Input #fn, ZEROTIME: Input #fn, Maxpres
        Input #fn, MAXFLOW: Input #fn, mineqtime
        Input #fn, PRESSLEW: Input #fn, flowslew
        Input #fn, EQITER: Input #fn, AVEITER
        Input #fn, MAXPDIF: Input #fn, MAXFDIF
        Input #fn, STARTP: Input #fn, STARTF
        Input #fn, PulseDelay: Input #fn, preginc
        On Error Resume Next
        minbppres = 0
        Input #fn, minbppres
        Input #fn, leak_test_delay
        Input #fn, temperatureSetPoint
        Debug.Print "Load TemperatureSetPoint:"; temperatureSetPoint
    GoTo def_OK

no_def:
    ' all parms that are count based have to be modified for version 7
    ' Now they don't since we have new ver multipliers to help
    PULSEWIDTH = 0.2: V2INCR = 10
    BUBLTIME = 5: BUBLFLOW = 2
    ZEROTIME = 1: Maxpres = 10
    MAXFLOW = 10000: mineqtime = 30
    PRESSLEW = 10
    flowslew = 50
    EQITER = 3: AVEITER = 20
    MAXPDIF = 0.1: MAXFDIF = 50
    STARTP = 1: STARTF = 500
    PulseDelay = 0: preginc = 1.25
    minbppres = 0
    temperatureSetPoint = 0
    Resume def_OK
def_OK:
    Close #fn
    
End Sub


Sub Load_Sample(x_array As dat_array)

    Dim lowest0 As Long, lowest1 As Long, highest0 As Long, highest1 As Long
    Dim readtimes%
    Dim sum#, x_temp As Long, has_been_above_750 As Boolean, temp$
    Dim ok_should_be_used As Boolean
    Dim best_so_far As Long
    Dim last_bad_time As Single
    Dim T As Single
    Dim t2 As Single
    Dim k As Single
    Dim pen_tested As Boolean
    Dim boxtitle As String
    Dim i As Integer
    Dim compression_delayed As Boolean
    Dim L As Long
    Dim autoFillWaitTime As Integer
    ' 6.71.48 maximum count value you can use on the regulator when
    ' you are pushing the liquid up through the sample on bottom-up
    ' porometer so you don't overpressurize the compression piston
    Dim max_push_reg As Long
    
' **********
' Begin code inserted by search for Tim Richards on Monday 6/14/04
' change     Msgform.Label.Caption = Format$(x5, "#0.00 \c\m   ") + Format$(x4, "####0 " + ts$(432))  ' "\c\m"/"\c\o\u\n\t\s"
'
    Dim s_local_BalanceNotPenet_gm_cm As String
  
    If g_bBalanceNotPenet = True Then
        s_local_BalanceNotPenet_gm_cm = ts$(484)
    Else
        s_local_BalanceNotPenet_gm_cm = ts$(485)
    End If

' End code inserted by Tim Richards 6/14/04
' **********
    
    ' 6.71.102 switch back to air inlet 1, if necessary
    If air_inlets > 1 And current_air_inlet = 2 Then
        Move_Valve 15, "C"
        current_air_inlet = 1
    End If
    
    ' This has been added to fix the problem when test ends middle of the second pass.
    If dualregulator Then
        Move_Valve 16, "C"
        regnum = 0
    End If
    
    boxtitle = ts$(182)         ' "Insert Sample"
    If multiChamberSystem And (manualMultiChamber = False) Then
        If nowait_at_end Then
            ' there is more than one chamber being loaded now
            boxtitle = ts$(183) + str$(current_unit%)           ' "Insert Samples in Chambers"
            For i = current_unit% + 1 To chambers
                If selchamber(i) Then
                    boxtitle = boxtitle + "," + str$(i)
                End If
            Next i
        Else
            ' there is only one chamber being loaded now
            boxtitle = ts$(184) + str$(current_unit%)       ' "Insert Sample in Chamber"
        End If
    End If
    Rem TType%=-1 for max liq flow setup
    Rem added by jsd to get rid of cv correction file
    On Error GoTo no_file
    'Kill EXE_Path$ + "cv correction.log"
    'Kill EXE_Path$ + "Cv error.log"
    Kill EXE_Path$ + "Lohm Correction File.dat"
no_file:
    On Error GoTo 0
    ' recirculation has its own piston handling routine, so we can skip this
    ' also, if they don't have the load prompts, no reason to unload
    ' since we would just load again.
    ' Also, if they just did a vacuum purge, don't unload because we want it to remain
    ' sealed for now.
    If (autocompress Or autopiston Or (FrazierRunning And FrazierPiston)) And (Not recirculation) And (Not nowait_at_beginning) And (Not just_did_vacuum_purge) Then
        safety_canceled = False
        If safetyup And Vpos(15) = 1 Then
            If safetyupdoor Then
                ' do auto door switch thing instead of key press thing
                check_safety_door True ' we can cancel this
            Else
                safetykeypress.mainlabel.Caption = ts$(166)     ' "Piston About To Raise"
                safetykeypress.Show 1
            End If
        End If
        If Not safety_canceled And (Not auto_wet_enable Or Not auto_wet_used) Then
            move_piston "C"
        End If
    End If
    If TType%(current_unit%) = 4 And TMode%(current_unit%) = 2 Then
        Aborted = False ' just in case
        Pre_Elev_LqPerm              'run elevated liquid perm.
        If Aborted Then Exit Sub
        If Auto_fill Then
            OPENV2MOSTLY
        End If
    End If
    
    ' must do recirculation setup for liquid permeability (4) and max liquid flow calibration (-1)
    If recirculation And (TType%(current_unit%) = 4 Or TType%(current_unit%) = -1) Then
        run_recirculation_setup 1 ' final run before start of test
        If flow_status <> 4 Then
            ' they canceled the test
            Aborted = True
            Exit Sub
        End If
    End If
    If autocompress And compression_pressure <> 0 And (current_unit% = 1 Or current_unit% <= number_of_pistons) Then
      temp$ = ts$(185)          ' "seal chamber and prepare for automatic compression"
    ElseIf compression And Not autocompress And (current_unit% = 1 Or current_unit% <= number_of_pistons) Then
      temp$ = ts$(186)          ' "engage compression"
    ElseIf autopiston Or (FrazierRunning And FrazierPiston) Then
      temp$ = ts$(187)          ' "close cover and prepare for automatic clamping"
    Else
      temp$ = ts$(188)          ' "seal chamber"
    End If
    If TType%(current_unit%) = -1 Then
        reply% = 0  ' no message box for max liq flow setup
    ElseIf TType%(current_unit%) = 1 And TMode%(current_unit%) = 2 And pass = 2 And nowait_for_du Then
        reply% = 0
        Rem we may need a wait in here for the meters to stabilize
    ElseIf TType%(current_unit%) = 2 And TMode%(current_unit%) = 3 Then
        ' hydrohead test loading
        If externalhydrohead Then
            ' open external vent valve
            Move_Valve 13, "O"
            Move_Valve 12, "O" ' also do the "fill" valve since it is miswired
            ' close external pressure valve
            Move_Valve 11, "C" '1293
            reply% = MsgBox(ts$(189) + vbCrLf + vbCrLf + ts$(190), 1, boxtitle$)    ' "Make sure fluid level is at bottom of sample, load sample, seal chamber, attach pressure tube."/"Press OK to start Test"
        ElseIf AirTop Then
            If nowait_at_beginning Then
                reply% = vbOK
            Else
                reply% = MsgBox(ts$(191) + ", " + temp$ + ", " + ts$(192) + "." + vbCrLf + vbCrLf + ts$(190), 1, boxtitle$) ' "Load sample with fluid on top"/"attach the air pressure tube"/"Press OK to start Test"
            End If
        Else
            ' use normal sample chamber through penetrometer
            ' can't be done auto with multiple chambers because they need to move
            ' the tube from the penetrometer
            ' (Not that we have made any air bottom multi-chamber penetrometer systems)
            reply% = MsgBox(ts$(191) + ", " + temp$ + ", " + ts$(193) + "." + vbCrLf + vbCrLf + ts$(190), 1, boxtitle$) ' "Load sample with fluid on top"/"attach penetrometer tube"/"Press OK to start Test"
        End If
    ElseIf TType%(current_unit%) = 2 And TMode%(current_unit%) = 2 Then
        ' integrity test
        If AirTop Then
            ' no need to attach the integrity hose for an airtop machine
            If nowait_at_beginning Then
                reply% = vbOK
            Else
                reply% = MsgBox(ts$(194) + ", " + temp$ + ", " + ts$(192) + "." + vbCrLf + vbCrLf + ts$(190), 1, boxtitle$) ' "Load saturated sample"/"attach the air pressure tube"/"Press OK to start Test"
            End If
        Else
            ' can't do auto on multi-chamber because of attachment of integrity hose
            reply% = MsgBox(ts$(194) + ", " + temp$ + ", " + ts$(195) + "." + vbCrLf + vbCrLf + ts$(190), 1, boxtitle$) ' "Load saturated sample"/"attach integrity tube"/"Press OK to start"
        End If
    ElseIf TType%(current_unit%) < 3 And pass < 2 Then 'WUDD & WUDU Test
      If use_fluid_sensor Then
        reply% = MsgBox(ts$(196), 1, ts$(197))       ' "Place empty fluid cup on sensor plate."/"Load Cell Calibration"
        ReadXReturnX4 27
        sum# = x5
        ReadXReturnX4 27
        sum# = sum# + x5
        ReadXReturnX4 27
        sum# = sum# + x5
        ReadXReturnX4 27
        sum# = sum# + x5
        ReadXReturnX4 27
        sum# = sum# + x5
        fluid_sensor_0 = sum# / 5
      End If
      If nowait_at_beginning Then
        reply% = 1
      ElseIf diffpgflow(current_unit%) And Not AirTop Then
        reply% = MsgBox(ts$(194) + ", " + temp$ + ", " + ts$(198) + "." + vbCrLf + vbCrLf + "         " + ts$(190), 1, boxtitle$)  ' "Load saturated sample"/"attach diff. pg tube"/"Press OK to start test"
      Else
        If Not auto_wet_enable Or Not auto_wet_used Then
            If geoPoreValve Then
                Move_GeoValves "C"
                geoValveClosed = True
            End If
            reply% = MsgBox(ts$(194) + ", " + temp$ + "." + vbCrLf + vbCrLf + "            " + ts$(190), 1, boxtitle$)   ' "Load saturated sample"/"Press OK to start Test"
        Else
            reply% = 1
        End If
      End If
    ElseIf TType%(current_unit%) = 6 Then
        If lvperm_enable Then
            Move_Valve -4, "C"
            Move_Valve -1, "C"
            Move_Valve -2, "O"
            Move_Valve -3, "O"
            reply% = MsgBox(ts$(199))             ' ("Load and seal Sample in liq. vapor sample chamber")
        Else
            If nowait_at_beginning Then
                reply% = 1
            ElseIf AirTop Then
                reply% = MsgBox(ts$(200) + ", " + temp$ + vbCrLf + ts$(190), 1, boxtitle$)     ' "Load sample"/"Press OK to start test"
            Else
                reply% = MsgBox(ts$(200) + ", " + temp$ + "," + vbCrLf + ts$(201) + vbCrLf + ts$(190), 1, boxtitle$)         ' "Load sample"/"connect tube to microflow port on instrument"/"Press OK to start test"
            End If
        End If
    Else 'DUWU test
        '6.71.123.24 If (Not Auto_fill) And (TType%(current_unit%) = 4) Then
        If (Not Auto_fill) And ((TType%(current_unit%) = 4) And ((TMode%(current_unit%) = 1) Or (TMode%(current_unit%) = 2))) Then
            If Drain12 Then

' Tim Richards, 1PM Thursday 6/17/04 AutoTest
' For the penetrometer, for the 1293, this is after it asks you for starting, step, maximum pressures,
' number of sample points. Back at the "Test initializing---please wait" yellow box.

                Move_Valve 11, "C" '1293 3/7
                If v20_exists Then Move_Valve 19, "C"
            Else
                Move_Valve 2, "C"
            End If
            reply% = MsgBox(ts$(202) + vbCrLf + ts$(200) + vbCrLf + ts$(203) + vbCrLf + temp$ + vbCrLf + ts$(190), 65, boxtitle$)      ' "Prefill sample-chamber with fluid."/"Load sample"/"Completely fill sample chamber with fluid."/"Press OK to start Test"
        ElseIf TType%(current_unit%) = 4 Then
          If nowait_at_beginning Then
            reply% = 1
          Else
            reply% = MsgBox(ts$(200) + ", " + temp$ + ", " + ts$(204) + "." + vbCrLf + "     " + ts$(190), 1, boxtitle$) ' "Load sample"/"attach hose(s) to top of chamber"/"Press OK to start test"
          End If
        Else
          If diffpgflow(current_unit%) And Not AirTop Then
            reply% = MsgBox(ts$(200) + ", " + temp$ + ", " + ts$(198) + "." + vbCrLf + vbCrLf + "         " + ts$(190), 1, boxtitle$)      ' "Load sample"/"attach diff. pg tube"/"Press OK to start test"
          Else
            If use_fluid_sensor Then
              reply% = MsgBox(ts$(200) + ", " + temp$ + "." + vbCrLf + ts$(205) + vbCrLf + "  " + ts$(190), 1, boxtitle$)       ' "Load sample"/"Make sure empty fluid cup is on sensor plate."/"Press OK to start test"
              ReadXReturnX4 27
              sum# = x5
              ReadXReturnX4 27
              sum# = sum# + x5
              ReadXReturnX4 27
              sum# = sum# + x5
              ReadXReturnX4 27
              sum# = sum# + x5
              ReadXReturnX4 27
              sum# = sum# + x5
              fluid_sensor_0 = sum# / 5
            Else
              If nowait_at_beginning Then
                reply% = 1
              Else
                reply% = MsgBox(ts$(200) + ", " + temp$ + "." + vbCrLf + vbCrLf + "    " + ts$(190), 1, boxtitle$)  ' "Load sample"/"Press OK to start Test"
              End If
            End If
          End If
        End If
    End If
    If reply% = 2 Then
        Aborted = True
        Exit Sub
    End If
    If TType%(current_unit%) = 6 And lvperm_enable Then
        Exit Sub
    End If
    If AirTop And (diffpgflow(current_unit%) Or TType%(current_unit%) = 6) Then
        Move_Valve 19, "C" ' close valve 20 in preparation for diffpg test
        If microflow_extraChamber Then Dry_Chamber_Control "C" ' special case - second microflow chamber
                ' requires that valve 4 is set as if it is for the liquid permeability to shut off
                ' the primary air chamber.
    End If
    ' don't compress yet if this is a bottom-up liquid test
    If PEN20500 < 0 And TType%(current_unit%) = 4 And delaycompressionliquid And recirculation = False Then
      compression_delayed = True
    Else
      compression_delayed = False
      If autocompress And compression_pressure <> 0 And (current_unit% = 1 Or current_unit% <= number_of_pistons) Then
        ' don't move piston if not on the first chamber
        ' if recirculation and the piston is up, we need to activate the piston
        If (Not recirculation) Or (Vpos(15) = 0) Then
            If safetydown Then
                If safetydowndoor Then
                    ' do auto door switch thing instead of key press thing
                    check_safety_door True
                Else
                    safetykeypress.mainlabel.Caption = ts$(206)         ' "Piston About To Lower"
                    safetykeypress.Show 1
                End If
                If safety_canceled Then
                    Aborted = True
                    Exit Sub
                End If
            End If
            move_piston "O", (TType%(current_unit%) <> 4) ' do pretreatment, when enabled, but not for liquid tests
            '6.71.61 Give piston time to close
            'T = Timer
            'While (Timer - T <= pistonDelayTime): DoEvents: Wend
'            waitseconds pistonDelayTime
            '****
        End If
      End If
      ' do the autopiston for everything but liquid permeameters
      If (autopiston Or (FrazierRunning And FrazierPiston)) And (current_unit% = 1 Or manuallySelectedChamber = 2) And liqpermonly = False And recirculation = False Then
        ' safetydown overrides the door switch
        If safetydown Then
            If safetydowndoor Then
                ' do auto door switch thing instead of key press thing
                check_safety_door True
            Else
                safetykeypress.mainlabel.Caption = ts$(206)         ' "Piston About To Lower"
                safetykeypress.Show 1
            End If
            If safety_canceled Then
                Aborted = True
                Exit Sub
            End If
        Else
            ' only allow piston to move if the door switch is correct
            While (RSEcho("R@", ver1or2) And 1) = 1
                If MsgBox(ts$(207), vbOKCancel) = vbCancel Then         ' "Close cover so that chamber may safely clamp"
                    Aborted = True
                    Exit Sub
                End If
            Wend
        End If
        
        'added on 12-17-07 --Denis
        'closes piston 2 if thats the one that is selected and not sequentialTesting
        'will add sequentialtesting later when 2nd sample chamber can work indepentently
        If sequentialTesting = False And manuallySelectedChamber = 2 Then
'            Move_Valve SecondPiston, "O"
          '  move_piston "O"     'Delete needed
        ElseIf sequentialTesting = True Then
            If manuallySelectedChamber = 1 Then
                move_piston "O"
            Else
'                Move_Valve SecondPiston, "O"
            End If
        Else
            move_piston "O"
        End If
'Before above if edit        move_piston "O" ' autopiston machine doesn't have pretreatment option
        
        
        '6.71.61 Give piston time to close
        'T = Timer
        'While (Timer - T <= pistonDelayTime): DoEvents: Wend
'        waitseconds pistonDelayTime
        '****
      End If
    End If
    
    ' wait for stable readings on low flow meter (0)
    ' and high flow meter (1)
    ' This is not needed for the pressure hold test, so we can skip this section.
    ' 6.71.61 also not needed for liquid perm
    ' also not needed for resin test
    If TType%(current_unit%) <> 4 And TType%(current_unit%) <> 5 And TType%(current_unit%) <> 7 Then          ' not pressure hold or liquid perm
        ' 6.71.20 new comment next line
        ' always use hflow2 for stability if it is there
        If xhflow Then
            hfmin% = 2
        Else
            hfmin% = 0
        End If
        HFLOW% = hfmin%
        readtimes% = 0
        lowest0 = DAC_over + 1
        lowest1 = DAC_over + 1
        highest0 = 0
        highest1 = 0
        info_form.Caption = ts$(208)            ' "Waiting for stable values"
        info_form.Label1.Caption = ""
        info_form.Label2.Caption = ""
        info_form.Show 0, pleasewait
        T = Timer
        ' 6.71.20
        suspend_v10 = True ' don't move v10 for this
        While readtimes% < 5 'AJB 10-05-09 WAS 15
          readtimes% = readtimes% + 1
          If Not GasPerm Then
            ' only do low flow meter if it is there!
            ReadXReturnX4 0
            info_form.Label1.Caption = ts$(209) + "=" + str$(x5)        ' "Low Flow"
            If x4 < lowest0 Then
              lowest0 = x4
              readtimes% = 0
            End If
            ' allow extended wait if counts is 0 (negative off scale) for first 30 seconds
            If x4 = 0 Then
                t2 = Timer
                If t2 + 0.1 < T Then T = T - 86400
                If (t2 - T) < 30 Then
                    readtimes% = 0
                    ' also reset highest and lowest so that when it does come back in scale
                    ' it will start checking for a stable reading
                    lowest0 = 0
                    highest0 = 0
                End If
            End If
            If x4 > highest0 Then
              highest0 = x4
              readtimes% = 0
            End If
          End If
          
          ReadXReturnX4 1
          info_form.Label2.Caption = ts$(210) + "=" + str$(x5)          ' "High Flow"
          info_form.Refresh
          If x4 < lowest1 Then
            lowest1 = x4
            readtimes% = 0
          End If
          If x4 > highest1 Then
            highest1 = x4
            readtimes% = 0
          End If
        Wend
        ' 6.71.20
        suspend_v10 = False
    End If  ' not pressure hold
    
    Unload info_form
    If Not GasPerm Then
        Rem zero high range of low flow meter
        Rem (low range of low flow meter isn't used in auto test)
        ReadXReturnX4 0
        If x4 < 3 Then
            MsgBox ts$(211) + vbCrLf$ + ts$(19)      '"Warning: The low flow"/"is not calibrated correctly"
        End If
        FX1(0, 0) = x4
        Rem reset x2 value
        FX2(0, 0) = x4 + DAC_span
        
        WPPS "Capstuff", "FX1_00", Trim$(str$(FX1(0, 0))), CSFile$
        WPPS "Capstuff", "FX2_00", Trim$(str$(FX2(0, 0))), CSFile$
    End If
    Rem use low range of main pressure gauge for starters
    Pres% = 1

    Rem zero low and high range of high flow meter being used
    ' Again, not needed for pressure hold
    ' or resin test
    If TType%(current_unit%) <> 5 And TType%(current_unit%) <> 7 Then      ' not pressure hold
        ' 6.71.20
        suspend_v10 = True ' don't move v10 for this
        ReadXReturnX4 1
        If x4 < 3 Then
            MsgBox ts$(212) + vbCrLf$ + ts$(19)          ' "Warning: The High Flow"/"is not calibrated correctly"
        End If
        FX1(1, hfmin%) = x4
        FY1(1, hfmin%) = 0
        FX2(1, hfmin%) = x4 + DAC_span
        
        WPPS "Capstuff", "FX1_1" + Trim$(str$(hfmin%)), Trim$(str$(FX1(1, hfmin%))), CSFile$
        WPPS "Capstuff", "FX2_1" + Trim$(str$(hfmin%)), Trim$(str$(FX2(1, hfmin%))), CSFile$
        
        Rem zero high range of high flow meter being used
        HFLOW% = hfmin% + 1
        'K = Timer
        'While (Timer - K < 0.3) And (Timer >= K)
        'DoEvents
        'Wend
        ReadXReturnX4 1
        If x4 < 3 Then
            MsgBox ts$(212) + vbCrLf$ + ts$(19)          ' "Warning: The High Flow"/"is not calibrated correctly"
        End If
        FX1(1, HFLOW%) = x4
        FY1(1, HFLOW%) = 0
        FX2(1, HFLOW%) = x4 + DAC_span
        
        WPPS "Capstuff", "FX1_1" + Trim$(str$(HFLOW%)), Trim$(str$(FX1(1, HFLOW%))), CSFile$
        WPPS "Capstuff", "FX2_1" + Trim$(str$(HFLOW%)), Trim$(str$(FX2(1, HFLOW%))), CSFile$
        
        ' 6.71.20 begin
        If xhflow And hfmin% <> 0 Then
            ' also zero the low and high range of hflow1
            HFLOW% = 0
            ReadXReturnX4 1
            If x4 < 3 Then
                MsgBox ts$(212) + vbCrLf$ + ts$(19)                    ' "Warning: The High Flow"/"is not calibrated correctly"
            End If
            FX1(1, 0) = x4
            FY1(1, 0) = 0
            FX2(1, 0) = x4 + DAC_span
            
            WPPS "Capstuff", "FX1_10", Trim$(str$(FX1(1, 0))), CSFile$
            WPPS "Capstuff", "FX2_10", Trim$(str$(FX2(1, 0))), CSFile$
            
            Rem now for high range
            HFLOW% = 1
            ReadXReturnX4 1
            If x4 < 3 Then
                MsgBox ts$(212) + vbCrLf$ + ts$(19)          ' "Warning: The High Flow"/"is not calibrated correctly"
            End If
            FX1(1, 1) = x4
            FY1(1, 1) = 0
            FX2(1, 1) = x4 + DAC_span
            
            WPPS "Capstuff", "FX1_11", Trim$(str$(FX1(1, 1))), CSFile$
            WPPS "Capstuff", "FX2_11", Trim$(str$(FX2(1, 1))), CSFile$
            
            If xhflow_meters = 2 Then
                CalibrateFlowMeter 1, 4, 0
                CalibrateFlowMeter 1, 5, 0
            End If
        End If
        
        If hasMultipleMVs Then
            CalibrateFlowMeter 1, 2, 0
            CalibrateFlowMeter 1, 3, 0
            CalibrateFlowMeter 2, 0, 1
            CalibrateFlowMeter 2, 1, 1
            CalibrateFlowMeter 2, 2, 1
            CalibrateFlowMeter 2, 3, 1
        End If
        
        suspend_v10 = False ' allow v10 to move again
        ' 6.71.20 end
    End If      ' not pressure hold
    
    Rem read zero pressure value of pressure gauge
    Pres% = 0
    ReadXReturnX4 2
    atm_x4(0) = x4
    'MsgBox "Initial atm(0)=" + Str$(X4)
    Pres% = 1
    If num_sample_pressure_gauges = 1 Then
        ReadXReturnX4 28
    Else
        ReadXReturnX4 2
    End If
    
    If x4 < 3 Then
        MsgBox ts$(213) + vbCrLf$ + ts$(19)          ' "Warning: The Pressure Gauge"/"is not calibrated correctly"
    End If
    P0 = x5
    real_atm = P0
    'MsgBox "Atmospheric pressure set to " + Str$(real_atm)
    atm_x4(1) = x4
    'MsgBox "Initial atm(1)=" + Str$(X4)
    Rem use this p0 value to zero the extra pressure gauge
    ' don't use the low pressure gauge if running elev pres liq perm and you have an external hydrohead
    If ExtraPG And (Not (externalhydrohead And TType%(current_unit%) = 4 And TMode%(current_unit%) = 2)) Then
    MsgBox (PY1(0))
    MsgBox (PY1(2))
      If PY1(2) > 0 Then
      
        Rem since py1(2)>0 then this must be a differential gauge,
        Rem so read the current reading, which should be at atmospheric
        Rem pressure and therefore around 500 counts, and use the pressure
        Rem reading of the main pressure gauge to set the current atmospheric
        Rem pressure value
        Pres% = 2
        ReadXReturnX4 2
        If x4 < 3 Then
            MsgBox ts$(434) + vbCrLf$ + ts$(19)          ' "Warning: The Low Pressure"/"is not calibrated correctly"
        End If
        PX1(2) = x4
        PY2(2) = PY2(2) - PY1(2) + P0
        PY1(2) = P0
        atm_x4(2) = x4
        'MsgBox "Initial atm(2)=" + Str$(X4)
        Pres% = 3
        ReadXReturnX4 2
        If x4 < 3 Then MsgBox ts$(434) + vbCrLf$ + ts$(19)          ' "Warning: The Low Pressure"/"is not calibrated correctly"
        PX1(3) = x4
        PY2(3) = PY2(3) - PY1(3) + P0
        PY1(3) = P0
        atm_x4(3) = x4
        'MsgBox "Initial atm(3)=" + Str$(X4)
        Rem leave Pres% at the lowest range of the extra pressure gauge

'         New means of re-ranging P2
'         This is done a second time during a bubble point to catch a few oddball reading differences (after BLOOP)
'         - Mix
        ReRangeP2 (P0)
'        NeedP20 = True

      Else
        Rem the second pressure gauge is an absolute pressure gauge, and
        Rem it must be more accurate than the main pressure gauge, so read
        Rem the second pressure gauge and use it's value to re-calibrate
        Rem the main pressure gauge.
        Pres% = 2
        ReadXReturnX4 2
        P0 = x5 ' actual atmospheric pressure
        real_atm = P0
        'MsgBox "Atmospheric pressure reset to " + Str$(real_atm)
        atm_x4(2) = x4
        'MsgBox "Initial atm(2)=" + Str$(X4)
        If PY1(0) = 0 Then
            x_temp = atm_x4(0) - (P0 / PY2(0) * (PX2(0) - PX1(0)) + PX1(0))
            PX1(0) = PX1(0) + x_temp
            PX2(0) = PX2(0) + x_temp
        End If
        If PY1(1) = 0 Then
            x_temp = atm_x4(1) - (P0 / PY2(1) * (PX2(1) - PX1(1)) + PX1(1))
            PX1(1) = PX1(1) + x_temp
            PX2(1) = PX2(1) + x_temp
        End If
        atm_x4(3) = 0  ' mark this range as being unusable
        'MsgBox "Initial atm(0)=0"
        Rem leave Pres% at the highest range of the extra pressure gauge
        Rem since the lowest range of an absolute gauge will always be off
        Rem scale
        Pres% = 2
      End If
      ' make sure that valve 11 is open since we will be using the low pressure gauge
      Move_Valve 10, "O"
    End If
    If pass < 2 Then
        points = points + 1
        dat_size_check x_array, points
        x_array.a(points).fl = 0
        x_array.a(points).pr = P0
        x_array.a(points).eqd = 0
        x_array.a(points).time = Timer
        
        'AJB 10-20-09 6.71.130
        If dryChamberTemperature <> 0 Then
            x_array.a(points).temp1 = 0
        End If
        
        If airTemperature <> 0 Then
            x_array.a(points).temp2 = 0
        End If
        'AJB 10-20-09 6.71.130
        
        If use_fluid_sensor Then
          ReadXReturnX4 27
          sum# = x5
          ReadXReturnX4 27
          sum# = sum# + x5
          ReadXReturnX4 27
          sum# = sum# + x5
          ReadXReturnX4 27
          sum# = sum# + x5
          ReadXReturnX4 27
          sum# = sum# + x5
          x_array.a(points).fluid = (sum# / 5) - fluid_sensor_0
        End If
        took_point_time = Timer
    End If
    DoEvents
    Move_Valve 2, "C"
    If slurry_tube_exists Then '6.71.123.19
        Move_Valve Slurry_tube_vent_valve, "C" 'slurry tube vent valve V29
    End If
    If H2OPERM Then
      Move_Valve 8, "C"
    End If
    'JF Test Value
    'PA = 1
    '6.71.123.21 If (TType%(current_unit%) = 4 Or TType%(current_unit%) = -1) And PA <> 0 Then
    If (((TType%(current_unit%) = 4) And ((TMode%(current_unit%) = 1) Or (TMode%(current_unit%) = 2))) Or TType%(current_unit%) = -1) And PA <> 0 Then
        Dry_Chamber_Control "C"
        Rem initial penetrometer bias set to zero
        pen_bias = 0
        Rem mark penetrometer as having been already tested
        pen_tested = True
        If Auto_fill Then
            Rem for autofill machines, mark penetrometer as not having been tested yet
            pen_tested = False
            If TopFill Or version >= 7 Then pen_tested = True
            Rem topfilling machines don't need testing of the penetrometer
            Rem neither do version 7 autofill
            If version < 7 Then
                ' only version 6 and 5 autofill have a fill valve adjustment
                MsgBox ts$(214), 0, ""              ' "Adjust penetrometer fill valve for a slow fill rate."
            End If
            
            Msgform.cancel.Visible = False
            Msgform.lb.Visible = False
            Msgform.Label.Caption = ts$(215)        ' "Fluid Level"
            Msgform.ok.Visible = False
            ok_should_be_used = False
            Msgform.Label1.Visible = False
            Msgform.Show 0
            Msgform.Refresh
        Else
            Msgform.cancel.Visible = False
            Msgform.lb.Visible = False
            Msgform.Label1.Visible = True
            Msgform.Label1.Caption = ts$(216) + str$(DAC_zero - DAC_span / 50) + " " + ts$(217) + str$(DAC_zero)      ' "Fill until counts are between"/"and"
            Msgform.ok.Visible = False
            ok_should_be_used = True
            Msgform.Label.Caption = ts$(218)                ' "Begin filling penetrometer"
            Msgform.Show 0
            Msgform.Refresh
        End If
        ReadXReturnX4 4                                 'read penetrometer
        ' if bottom liquid drain valve, don't open it
        
' Tim Richards, 1PM Thursday 6/17/04 AutoTest
' On the 1293 with the penetrometer, this is after it asks you to fill the sample chamber with fluid,
' after it waits for stable values. At this point, for the 1293, it is asking you to fill the
' penetrometer. There were two clicks, some gas released.
' On the BD Mettler, prior to this there were several clicks. The BD Mettler is giving you the fluid
' level screen, but it is not asking you to fill the penetrometer.

        If Not Drain12 Then
            ' don't open 12 if recirculation
            If Not recirculation Then Move_Valve 11, "O"
        Else
            Move_Valve 11, "C"                              'close drain  'TAR note 040617 '1293 4/7
        End If

'   040714 TAR
    If g_bBalanceNotPenet = True Then
'        SendMettlerCommand "Resetting Mettler Balance"
'        SendMettlerCommand "Zero Immediately"
'        SendMettlerCommand "Tare Immediately"

        g_bBalanceNotPenet_ZeroPoint = 0    ' TAR 040809 reset the zero point so that ReadBalanceNotPenet doesn't screw up the reading
        ReadXReturnX4 4                     ' TAR 040809
        g_bBalanceNotPenet_ZeroPoint = x5   ' TAR 040809
    End If
'
        ' check initial penetrometer position - if in range, we are already filled
        ReadXReturnX4 4
        ' 2 counts is 2.49% of span below zero
        ' JF 8-22-10 Changing the penetrometer filling code so it works off of user defined values
        If x4 > pen_min_counts - pen_span * 0.0249 And x4 <= pen_max_counts Then
        'If x4 > DAC_zero - DAC_span * 0.0249 And x4 <= DAC_two Then
            has_been_above_750 = True
        Else
            has_been_above_750 = False
        End If
        ' don't open the autofill valve if we have done recirculation
        
        'AJB 11-05-09
        If tank_level_exists Then
            ReadXReturnX4 tank_level_location
            If x5 < min_tank_fill_level Then
                TankFillDialog.Show 1
            End If
        End If
        
        If Not recirculation Then Move_Valve 12, "O" 'open autofill if exists
        If Not Auto_fill Then
            ' new: replace OK button with a "Prefilled" button
            Msgform.ok.Caption = ts$(219)               ' "Prefilled"
            Msgform.ok.Visible = True
            Msgform.cancel.Visible = False
            Msgform.lb.Visible = False
            Msgform.Label.Caption = ts$(218)            ' "Begin filling penetrometer"
            Msgform.Label1.Visible = True
            Msgform.Label1.Caption = ts$(216) + str$(DAC_zero - DAC_span / 50) + " " + ts$(217) + str$(DAC_zero + DAC_span / 50)      ' "Fill until counts are between"/"and"
            Msgform.Show 0
            Msgform.Refresh
            ok_should_be_used = True
            
            'JF 8-22-10 Changed to use user-defined limits
            While ((x4 < pen_min_counts) Or (x4 > pen_max_counts)) And Msgform.ok.Visible
            'While ((x4 < DAC_zero) Or (x4 > DAC_two)) And Msgform.ok.Visible
                ' non-autofill stays in this loop until penetrometer value comes into range
                ReadXReturnX4 4
                DoEvents
            Wend
            Msgform.ok.Visible = False
            Msgform.ok.Caption = ts$(220)           ' "OK"
        End If
        If has_been_above_750 Then GoTo Ret_Pen
Ret_Pen2:
        has_been_above_750 = False
        best_so_far = pen_max_counts
        last_bad_time = Timer
        T = Timer
        ReadXReturnX4 4
        
'JF 2/10/2010 - added code for recirculation to skip a long wait time for filling the penetrometer
'               also added a check to see if the reserve tank is getting low and to let the user
'               know so they can fill it.

        If recirculation Then
            x5 = readReserveTankLevel
            If x5 < 10# Then
                MsgBox "The Reserve Tank is less than 10% full.  Please fill before your next test.", vbInformation
            End If
        End If
        
        If Auto_fill And recirculation Then
            ReadXReturnX4 4
            If x4 < 2000 Then
                'Skip the following While loop
                'The penetrometer is full and we don't need to wait for it to fill
                GoTo Ret_Pen
            End If
            autoFillWaitTime = 60
        Else
            autoFillWaitTime = 300
        End If
        
        'JF 8-22-10 Changed to use user-defined limit variables
        While ((x4 - pen_bias <= pen_min_counts + pen_span * 0.0125) Or (x4 > pen_min_counts + pen_span / 2)) And ((Timer - T) <= IIf(Auto_fill, autoFillWaitTime, 120))
        'While ((x4 - pen_bias <= DAC_zero + DAC_span * 0.0125) Or (x4 > DAC_zero + DAC_span / 2)) And ((Timer - T) <= IIf(Auto_fill, autoFillWaitTime, 120))

        'read penetrometer while values are between 23000 and 10500 or below 750 cts.
        ' this loop continues until penetrometer goes above 10500
        ' or over 2 minutes (was 1 minute)
        ' Set to 5 minutes for an autofill machine because it has to fill the sample chamber as well
        ' value can't validly go below 750 without first being between 23000 and 10500
        ' unless the value is incorrect
        ' this is assuming that the penetrometer starts out empty.
        ' If the penetrometer starts out filled, then it doesn't need
        ' to be between 23000 and 10500 before it can go above 750
            ReadXReturnX4 4
            
            'JF 8-22-10
            If (x4 > pen_max_counts Or x4 < 3) And (Not has_been_above_750) Then
            'If (x4 > DAC_two Or x4 < 3) And (Not has_been_above_750) Then
                last_bad_time = Timer
            End If
            t2 = Timer
            If t2 + 0.1 < last_bad_time Then last_bad_time = last_bad_time - 86400
            
            'JF 8-22-10
            If x4 > pen_min_counts + pen_span * 0.0125 And x4 < best_so_far And t2 - last_bad_time > 2 Then
            'If x4 > DAC_zero + DAC_span * 0.0125 And x4 < best_so_far And t2 - last_bad_time > 2 Then
                ' when value hasn't reached 750 yet, and we
                ' haven't been off scale for 2 seconds
                ' (because it can give false readings when
                ' going from off scale to in scale)
                ' and the magnet has moved up at least a
                ' little (best_so_far), reset the timer
                ' so we keep waiting.  This timer will cause
                ' the fill routine to end after 120 seconds
                ' of not getting better and is also used to
                ' let the user call the air purge routine
                ' if the value doesn't get better
                has_been_above_750 = True
                best_so_far = x4
                T = Timer
                
                If (Not pen_tested) And x4 < pen_min_counts + pen_span * 0.75 Then
                'If (Not pen_tested) And x4 < DAC_zero + DAC_span * 0.75 Then
                    ' this is only for autofill bottom fillers
                    ' it checks to see how far penetrometer will
                    ' coast after we shut off the water.
                    ' This is only called once.
                    Rem best_so_far records current penetrometer value
                    Rem close water inlet and pulse drain
                    Move_Valve 12, "C"  'close autofill
                    Move_Valve 2, "O"   ' open drain
                    Move_Valve 2, "C"   ' close drain
                    Rem wait until value hasn't gone up in 5 seconds
                    pen_bias = x4
                    T = Timer
                    While (Timer - T) < 5
                        ReadXReturnX4 4
                        Msgform.Label.Caption = Format$(x5, "#0.00 \c\m   ") + Format$(x4, "####0 " + ts$(432))  ' "\c\m"/"\c\o\u\n\t\s"
                        Msgform.Refresh
                        If x4 < pen_bias Then
                            pen_bias = x4
                            T = Timer
                        End If
                    Wend
                    pen_bias = best_so_far - pen_bias
                    If pen_bias < 0 Then pen_bias = 0
                    pen_tested = True
                    T = Timer
                    Rem only open the autofill valve if this wouldn't cause overflow
                    
                    If x4 - pen_bias > pen_min_counts Then
                    'If x4 - pen_bias > DAC_zero Then
                        Move_Valve 12, "O"
                    End If
                End If
            End If
            
' **********
' Begin code inserted by search for Tim Richards on Monday 6/14/04
' change     Msgform.Label.Caption = Format$(x5, "#0.00 \c\m   ") + Format$(x4, "####0 " + ts$(432))  ' "\c\m"/"\c\o\u\n\t\s"
'
            Msgform.Label.Caption = Format$(x5, "#0.00 ") + s_local_BalanceNotPenet_gm_cm + Format$(x4, "####0 " + ts$(432)) ' "\g\m"/"\c\o\u\n\t\s"
'
' End code inserted by Tim Richards 6/14/04
' **********

            Msgform.Refresh
            DoEvents
            Rem T is the time when we last had an improved reading
            If T > Timer + 0.1 Then T = T - 86400 ' handle midnight
            ' don't allow purge button on bottom-up machines
            If PEN20500 >= 0 Then
                If Msgform.ok.Caption = ts$(220) And x4 < pen_max_counts And x4 > DAC_zero + DAC_span * 0.0125 And ok_should_be_used And (Timer - T > 10) Then     ' "OK"/
                  Msgform.ok.Caption = ts$(7) '"Purge"
                  Msgform.ok.Visible = True
                  Msgform.ok.SetFocus
                End If
                If Msgform.ok.Caption <> ts$(7) And Not ok_should_be_used And (Timer - T > 20) Then
                  Msgform.ok.Caption = ts$(7)
                  Msgform.ok.Visible = True
                  Msgform.ok.SetFocus
                End If
                    
                If Not ok_should_be_used And Msgform.ok.Caption = ts$(7) And Msgform.ok.Visible = False Then
                  bubble_purge True
                  T = Timer
                  best_so_far = pen_max_counts
                  Msgform.ok.Caption = ts$(220)           ' "OK"
                End If
                If ok_should_be_used And Msgform.ok.Caption = ts$(7) And Msgform.ok.Visible = False Then
                  bubble_purge False
                  Msgform.ok.Caption = ts$(220)           ' "OK"
                  T = Timer
                  best_so_far = pen_max_counts
                End If

            End If
'            If TMode%(current_unit%) = 1 And special_ambient Then
'                T = Timer - 200 ' force loop to end
'            End If
        Wend
        'T = Timer
        'While Timer - T <= 3: Wend                      '3 second wait (why?)
Ret_Pen:
        ReadXReturnX4 4
        T = Timer
        Rem now that penetrometer is within the valid range
        Rem (it is between 750 and 10500)
        Rem we can safely wait for it to get below 500
        best_so_far = x4
        
        'JF 8-22-10
        While (x4 - pen_bias >= (pen_min_counts + pen_span / 50)) And ((Timer - T) <= 120) And x5 < max_fill_point
        'While (x4 - pen_bias >= (DAC_zero + DAC_span / 50)) And ((Timer - T) <= 120) And x5 < max_fill_point
            ReadXReturnX4 4
            If x4 < best_so_far Then
                best_so_far = x4
                T = Timer
            End If
            Msgform.Label.Caption = Format$(x5, "#0.00 ") + s_local_BalanceNotPenet_gm_cm + Format$(x4, "####0 " + ts$(432)) ' "\c\m"/"\c\o\u\n\t\s" TAR040616
            Msgform.Refresh
            DoEvents
            Rem T is the time when we last had an improved reading
            If T > Timer + 0.1 Then T = T - 86400 ' handle midnight
            
            If PEN20500 >= 0 Then ' don't do purge on bottom-up machines
                If Msgform.ok.Caption = ts$(220) And ok_should_be_used And (Timer - T > 10) Then
                  Msgform.ok.Caption = ts$(7)             ' "Purge"
                  Msgform.ok.Visible = True
                  Msgform.ok.SetFocus
                End If
                If Msgform.ok.Caption <> ts$(7) And Not ok_should_be_used And (Timer - T > 20) Then
                  Msgform.ok.Caption = ts$(7)                 ' "Purge" TAR040616
                  Msgform.ok.Visible = True
                  Msgform.ok.SetFocus
                End If
                If Not ok_should_be_used And Msgform.ok.Caption = ts$(7) And Msgform.ok.Visible = False Then
                  bubble_purge True
                  T = Timer
                  best_so_far = pen_max_counts
                  Msgform.ok.Caption = ts$(220)               ' "OK"
                End If
                If ok_should_be_used And Msgform.ok.Caption = ts$(7) And Msgform.ok.Visible = False Then
                  bubble_purge False
                  Msgform.ok.Caption = ts$(220)               ' "OK"
                  T = Timer
                  best_so_far = pen_max_counts
                End If
            End If
'            If TMode%(current_unit%) = 1 And special_ambient Then
'                T = Timer - 200 ' force loop to end
'            End If
            ' since we are in range, check to see if we are above the bottom_fill_point for bottom fill
            ' autofill machines.  If we are, we want to close the sample isolation valve to let the penetrometer
            ' fill up more on its own
            If PEN20500 < 0 And Auto_fill And x5 > bottom_fill_point And Vpos(20) = 1 Then
                ' close valve 20 to stop sample from filling any more
                Move_Valve 19, "C"
            End If
        Wend
        If ok_should_be_used Then
            Msgform.ok.Caption = ts$(220)                   ' "OK"
            Msgform.ok.Visible = True
            Msgform.ok.SetFocus
            While Msgform.ok.Visible
                ReadXReturnX4 4
                Msgform.Label.Caption = Format$(x5, "#0.00 ") + s_local_BalanceNotPenet_gm_cm + Format$(x4, "####0 " + ts$(432)) ' "\c\m"/"\c\o\u\n\t\s" TAR040616
                Msgform.Refresh
                DoEvents
            Wend
        End If

        Move_Valve 12, "C"  'close autofill
        If Auto_fill And (Not TopFill) And version < 7 Then
            Move_Valve 11, "O"   'pulse drain valve
            Move_Valve 11, "C"
        End If
        ReadXReturnX4 4
        ' don't ask them about full penetrometer if using bottom-up machine
        ' or if they're using a Mettler balance 'TAR040615
        If PEN20500 >= 0 And Not g_bBalanceNotPenet Then 'TAR040615
          If Auto_fill Then
            reply% = MsgBox(ts$(221) + vbCrLf + ts$(222), vbYesNo + vbDefaultButton1, ts$(223))            ' "Is the Penetrometer full?"/"YES to continue, NO to try adding more."/"Test Setup"
            If reply% = vbNo Then
                Move_Valve 12, "O"
                If has_been_above_750 Then
                    best_so_far = pen_max_counts
                    GoTo Ret_Pen
                Else
                    GoTo Ret_Pen2
                End If
            End If
          Else
            reply% = MsgBox(ts$(221) + vbCrLf + ts$(224), 0, ts$(223))        ' "Is the Penetrometer full?"/"If NOT, finish filling and press OK to continue."/"Test Setup"
          End If
        End If
        ' do the autopiston for liquid permeameters
        If compression_delayed = True Then
          If autocompress And compression_pressure <> 0 And (current_unit% = 1 Or current_unit% <= number_of_pistons) Then
            ' don't move piston if not on the first chamber
            If safetydown Then
                safety_canceled = False
                If safetydowndoor Then
                    ' do auto door switch thing instead of key press thing
                    check_safety_door True
                Else
                    safetykeypress.mainlabel.Caption = ts$(206)         ' "Piston About To Lower"
                    safetykeypress.Show 1
                End If
                If safety_canceled Then
                    Aborted = True
                    Exit Sub
                End If
            End If
            move_piston "O" ' no pretreatment for liquid perm tests
            '6.71.61 Give piston time to close
            'T = Timer
            'While (Timer - T <= pistonDelayTime): DoEvents: Wend
'            waitseconds pistonDelayTime
            '****
          End If
          'If autopiston And current_unit% = 1 And liqpermonly = True Then
          If autopiston And current_unit% = 1 Then
            ' only allow piston to move if the door switch is correct
            ' so far, we haven't used the safetydown feature for liquid permeameters
            ' if we do, we will have to put something in here
            While (RSEcho("R@", ver1or2) And 1) = 1
                If MsgBox(ts$(207), vbOKCancel) = vbCancel Then     ' "Close cover so that chamber may safely clamp"
                    Aborted = True
                    Exit Sub
                End If
            Wend
            move_piston "O" ' no pretreatment for liquid perm only machines
          End If
        End If
        If PEN20500 < 0 And Auto_fill And (Vpos(20) = 0 Or valve_23_exists) Then
            ' we now need to open valve 20 again and wait for penetrometer to stabilize
            ' we will increase pressure if necessary to cause the penetrometer to go down to the
            ' penetrometer_start_test_point
            ' 6.71.48 set new variable so we don't overpressurize
            If autocompress And Compression_Increase_Factor <> 0 And compression_pressure <> 0 And ip_reg_enable Then
                max_push_reg = regpos_from_p(compression_pressure / Abs(Compression_Increase_Factor))
                If max_push_reg > 4000 Then max_push_reg = 4000
            Else
                max_push_reg = 4000 ' allow any pressure
            End If
            Move_Valve 19, "O"
            If valve_23_exists Then
                ' much simpler with valve 23
                ' first, check to see if we need to drain out anything
                ReadXReturnX4 4
                Msgform.Label.Caption = Format$(x5, "#0.00 ") + s_local_BalanceNotPenet_gm_cm + Format$(x4, "####0 " + ts$(432))   ' "\c\m"/"\c\o\u\n\t\s"
                Msgform.Refresh
                If x5 > penetrometer_start_test_point Then
                    ' no need to pressurize, just open valve 23 to drain the excess liquid out the bottom
                    Move_Valve 8, "C"
                    Move_Valve 20, "O"
                    Move_Valve 11, "O"
                    waitseconds 4 ' make sure all valves have moved before opening 23
                    Move_Valve 22, "O"
                    Do
                        ReadXReturnX4 4
                        Msgform.Label.Caption = Format$(x5, "#0.00 ") + s_local_BalanceNotPenet_gm_cm + Format$(x4, "####0 " + ts$(432))   ' "\c\m"/"\c\o\u\n\t\s"
                        Msgform.Refresh
                        If x5 <= penetrometer_start_test_point Then Exit Do
                    Loop
                    Move_Valve 22, "C"
                End If
            Else
                ' minimum 2 second wait for valve to finish moving
                waitseconds 2
                ' penetrometer must go down by .05 cm every second or we increase the pressure
                T = Timer
                ReadXReturnX4 4
                k = x5
                pen_tested = False ' reused variable - false means we haven't started pressurizing yet
                Do
                    ReadXReturnX4 4
                    Msgform.Label.Caption = Format$(x5, "#0.00 ") + s_local_BalanceNotPenet_gm_cm + Format$(x4, "####0 " + ts$(432))   ' "\c\m"/"\c\o\u\n\t\s"
                    Msgform.Refresh
                    If x5 <= penetrometer_start_test_point Then Exit Do
                    If T > Timer + 0.1 Then T = T - 86400 ' handle midnight
                    If Timer - T >= 1 Then
                        ' 1 second elapsed - check for movement
                        If k - x5 < 0.05 Then
                            ' increase pressure
                            If Not pen_tested Then
                                OPENV2MOSTLY
                                Move_Valve 8, "O"
                                pen_tested = True
                                ' set regulator to pressure for half of the height we want to go to
                                ' height is at x5.  We want it to be at penetrometer_start_test_point
                                If ip_reg_enable Then
                                    L = regpos_from_p(x5 - penetrometer_start_test_point) / 2 * PSIPERCM
                                    If L > max_push_reg Then L = max_push_reg
                                    If REGPOS < L Then
                                        inc_reg L - REGPOS
                                    End If
                                End If
                            End If
                            If ip_reg_enable Then
                                If REGPOS + 5 <= max_push_reg Then
                                    inc_reg 5
                                ElseIf REGPOS < max_push_reg Then
                                    inc_reg max_push_reg - REGPOS
                                End If
                            Else
                                ' no safety on older systems
                                inc_reg 5
                            End If
                        End If
                        ' reset everything
                        k = x5
                        T = Timer
                    End If
                Loop
                ' zero regulator, vent system
                Zero_Reg
                Move_Valve 2, "O"
            End If
        End If
        ' moved outside if block so valve 3 always gets closed
        Move_Valve 2, "C"
        Unload Msgform
        If TType%(current_unit%) = 4 And TMode%(current_unit%) = 2 And (Not Auto_fill) Then
            OPENV2MOSTLY
        End If
    Else ' we are not doing liquid permeability
        ' this is ok for bubbler systems as well
        If microflow_extraChamber = False Then Dry_Chamber_Control "O" 'close v4 to let flow go out sample chamber
    End If
    ' 6.71.102 switch air inlets if necessary
    ' If air_inlets > 1 And Maxpres > air_inlet_1_max_p Then
    ' I coomented above condition because we need to compre minimum pressure
    ' with air_inlet_1_max_p to decide which inlet to start use at the begining.
    ' 05-24-12 sm
    If air_inlets > 1 Then
        If (minp_set(current_unit%) < air_inlet_1_max_p) Then
            Move_Valve 15, "C"
            current_air_inlet = 1
        Else
            Move_Valve 15, "O"
            current_air_inlet = 2
            
        End If
        
    End If
    
    If hasMultipleMVs Then
        motorValveIndex = 0
        HFLOW% = 0
        vflow% = 1
        using_hflow1 = True
    ElseIf xhflow Then
        motorValveIndex = 0
        HFLOW% = 0
        vflow% = 1
        using_hflow1 = True
        If xhflow_meters = 1 Then
            Move_Valve 9, "C"
        ElseIf xhflow_meters = 2 Then
            Move_Valve 9, "C"
            Move_Valve 19, "C"
        End If
    End If
End Sub
Sub log_append(a$)

    Dim fn As Integer, i As Integer, j As Integer

    fn = FreeFile
    Open EXE_Path$ + "debuglog.txt" For Append As #fn
    Print #fn, time$; " "; date$; " "; a$
    For i = 0 To 99
        j = i + cel_i
        If j > 100 Then j = j - 100
        If cel2(j) <> 0 Then
            Print #fn, cel1(j); " ";
            Select Case cel2(j)
                Case 1:
                    Print #fn, "Send Character ";
                Case 2:
                    Print #fn, "Got Echo Character ";
                Case 3:
                    Print #fn, "Got Extra Character ";
                Case 4:
                    Print #fn, "Send Resync Space ";
                Case 5:
                    Print #fn, "Get Read Val Character ";
                Case 6:
                    Print #fn, "Send GA Character ";
                Case Else
                    Print #fn, "Unknown command "; cel2(j); " ";
            End Select
            Print #fn, cel3(j)
        End If
    Next i
    
    Close #fn
    
End Sub

Sub low_over_error(ByVal errorVal As Integer)

    Move_Valve 11, "O"
    Move_Valve 2, "O"
    Zero_Reg
    V2POS = cLimit
    Move2V2Pos
    Move_Valve 10, "O"
    Zero_Reg
    Move_Valve 10, "C"
    MsgBox ts$(225) + vbCrLf + "DAC_OVER: " + DAC_over + vbTab + "Counts: " + errorVal
    ' "Error:  Your low pressure gauge was off scale - possible leak in valve - test aborted." + _
            vbCrLf "DAC_OVER: " + dacover
   
    Aborted = True

End Sub

Sub lower_lfctrl(ByVal i As Integer)

    ' i must be between 0 and 255 or the counter gets messed up
    While i > 255
        Send_RS232b "B2", 255
        i = i - 255
        lfcpos = lfcpos - 255
    Wend
    Send_RS232b "B2", CByte(i)
    lfcpos = lfcpos - i
    If lfcpos < 0 Then lfcpos = 0

End Sub

Sub lower_creg(ByVal i As Integer)

    ' the i value is ignored unless ip_creg_enable is true
    If ip_creg_enable Then
        ' i must be between 0 and 255 or the counter gets messed up
        While i > 255
            Send_RS232b "B3", 255
            i = i - 255
            CREGPOS = CREGPOS - 255
        Wend
        Send_RS232b "B3", CByte(i)
        CREGPOS = CREGPOS - i
        If CREGPOS < 0 Then CREGPOS = 0
    Else
        Send_RS232 ("DP")
        If Not manrunning Then
            While RSEcho("VP", 1) <> Asc("S")
                tryhold
            Wend
        End If
    End If
    
End Sub

Sub lower_reg(ByVal i As Integer)

    ' i is only used if ip_reg_enable is true
    Dim k As Single
    
    last_reg_status = False

    If newreg Then
        Set_Regulator_Speed
        Send_RS232 ("DEJ" + Chr$(12))
        If Not manrunning Then
            While RSEcho("VE", 1) <> Asc("S")
              tryhold
            Wend
        End If
        REGPOS = REGPOS - 1
    ElseIf ip_reg_enable Then
        While i > 255
            Send_RS232b "B1", 255
            i = i - 255
            REGPOS = REGPOS - 255
        Wend
        Send_RS232b "B1", CByte(i)
        REGPOS = REGPOS - i
        If REGPOS < 0 Then REGPOS = 0
    Else
        Send_RS232 ("J" + Chr$(3) + "IGOHCHJ" + Chr$(12))
        REGPOS = REGPOS - 1
    End If
    
End Sub

Sub lvperm_test()

    Dim T As Single
    Dim p1 As Single
    Dim p2 As Single
    Dim P0 As Single
    Dim tstart As Single
    Dim tcurr As Single
    Dim tlast As Single
    Dim tnext As Single
    Dim curtime As Single
    Dim x1 As Single
    Dim x2 As Single
    Dim fn As Integer
    Dim p_scale As Single

    RunTimer = Timer
    progress.Timer1.Interval = 2000
    progress.Timer1.Enabled = True
    progress.Label2.Caption = ts$(74) + " - " + ts$(75)     ' "Time - min."
    ' scale the screen to 120% of the current liquid vapor pressure
    p_scale = read_gauge(2) * 1.2
    ' set to some reasonable even value
    p_scale = 10 * (Int(p_scale / 10 + 0.5))
    If p_scale < 10 Then p_scale = 10
    progress.Picture1.ScaleHeight = p_scale
    progress.Picture1.ScaleWidth = mf_time(current_unit%)
    progress.Picture1.ScaleTop = 0
    progress.Picture1.ScaleLeft = 0
    progress.X_Max.Caption = str$(mf_time(current_unit%))
    progress.Y_Max.Caption = Format$(p_scale, "###0")
    If status_lights_enable Then setStatusLights 2

    Move_Valve -3, "C"
    Do
        progress.Line25.Caption = ts$(69)       ' "Evacuating - please wait."
        Move_Valve -4, "O"
        ' wait for good vac
        ' standard 30 second thing
        T = Timer
        p1 = read_gauge(3)
        Do
            curtime = Timer
            If curtime + 0.1 < T Then T = T - 86400
            p2 = read_gauge(3)
            If p2 < p1 Then
                p1 = p2
                T = curtime
            End If
            progress.Line25.Caption = ts$(226) + ": P=" + Format$(p1, "###0.0000") + " Torr, T=" + Format$(30 - (curtime - T), "#0.0")  ' "Evacuating"/"Torr"
        Loop Until curtime - T >= 30
        ' leak test
        progress.Line25.Caption = ts$(167) + " - " + ts$(228) ' "Leak Test - please wait."
        p1 = read_gauge(3)
        ' close vacuum
        Move_Valve -4, "C"
        ' wait for good vac
        T = Timer
        Do
            curtime = Timer
            If curtime + 0.1 < T Then T = T - 86400
            p2 = read_gauge(3)
            progress.Line25.Caption = ts$(167) + ": P=" + Format$(p2, "###0.0000") + " Torr, T=" + Format$(10 - (curtime - T), "#0.0")  ' "Leak Test"/"Torr"
        Loop Until (curtime - T >= 10) Or (p2 - p1 > 0.1)
    Loop Until (p2 - p1 < 0.1) Or (HKey$ = "A")
    If HKey$ = "A" Then GoTo abort_test
    ' re-evacuate
    Move_Valve -4, "O"
    Do
        p2 = read_gauge(3)
        progress.Line25.Caption = ts$(226) + ": P=" + Format$(p2, "###0.0000") + " Torr"    ' "Evacuating"/"Torr"
    Loop Until p2 <= p1
    ' record zero point
    P0 = read_gauge(3)
    p2 = P0
    plast = P0
    ' close bypass
    Move_Valve -2, "C"
    ' close vacuum
    Move_Valve -4, "C"
    ' open inlet
    Move_Valve -1, "O"
    ' start timer
    fn = FreeFile
    'Open OutFilename$(current_unit%) For Append As #fn
    Open EXE_Path$ + "lastdata.cft" For Append As #fn
    Print #fn, Diff_Volume(1)   ' lvperm only uses first diff_volume (for now)
    p1 = read_gauge(2)
    ' convert results from internal Torr to data file PSI
    Print #fn, "0,"; str$(p1 * 14.7 / 760); ",0"
    tstart = Timer
    tnext = tstart
    curtime = tstart
    tlast = 0
    While ((curtime - tstart) < mf_time(current_unit%) * 60) And (HKey$ <> "A")
        While (curtime - tnext < Step_Time(current_unit%) * 60) And HKey$ <> "A"
            Rem read and update graph
            p2 = read_gauge(3)
            If p2 > aux_p2_span Then HKey$ = "A"
            If tstart > curtime + 0.1 Then tstart = tstart - 86400
            tcurr = (curtime - tstart) / 60
            p1 = read_gauge(2)
            progress.Line25.Caption = ts$(72) + ": " + Xformat$(p1, "###0.000  ") + "  " + ts$(73) + ": " + Xformat$(p2 - P0, "###0.000  ") + "  " + ts$(74) + ": " + Format$(tcurr, "#####0.00 ") + ts$(75) '"Internal Pressure"/"External Pressure"/"Time"/"min."
            progress.Line25.Refresh
            x1 = p_scale - (plast - P0)
            x2 = p_scale - (p2 - P0)
            If x1 < 0 Then x1 = 0
            If x2 < 0 Then x2 = 0
            If x2 < x1 And tcurr > tlast Then
                progress.Picture1.Line (tlast, x1)-(tcurr, x2), RGB(255, 0, 255)
                plast = p2
                tlast = tcurr
            End If
            DoEvents
            curtime = Timer
            If tnext > curtime + 0.1 Then tnext = tnext - 86400
        Wend
        Rem store data point
        Print #fn, str$(tcurr); ","; str$(p1 * 14.7 / 760); ","; str$((p2 - P0) * 14.7 / 760)
        tnext = tnext + Step_Time(current_unit%) * 60
        curtime = Timer
        If tstart > curtime + 0.1 Then tstart = tstart - 86400
    Wend
    Rem all done

    Print #fn, "0,0"
    Close #fn
abort_test:
    Move_Valve -1, "C" ' close inlet
    Move_Valve -2, "O" ' open bypass
    Move_Valve -3, "O" ' open vent
    If status_lights_enable Then setStatusLights 1
    MsgBox ts$(76), 0, ts$(77)           ' "Test Finished, Remove Sample"/"done"
    do_final_copy
    'FileCopy EXE_Path$ + "lastdata.cft", OutFilename$(current_unit%)

End Sub

Sub Manual_BP()

    Dim F_Atm As Single
    Dim p_atm As Single
    Dim T As Single
    Dim B_Flow As Single
    Dim b_pres As Single
    Dim i%
    Dim fn As Integer
    
    RunTimer = Timer
    progress.Timer1.Interval = 2000
    progress.Timer1.Enabled = True
    Zero_Reg
    If ExtraPG Then
        Move_Valve 10, "O"
        Pres% = 2
    End If
    F_Atm = 0
    p_atm = 0
    lflow% = 0
    waitseconds 10
    'T = Timer
    'While Timer - T < 10: DoEvents: Wend
    For i% = 1 To 20
        ReadXReturnX4 2
        p_atm = p_atm + x5
        ReadXReturnX4 0
        F_Atm = F_Atm + x5
    Next i%
    p_atm = p_atm / 20
    F_Atm = F_Atm / 20

    Move_Valve 0, "O"
    If low_flow_controller Then set_low_flow_rate BUBLFLOW
    While (HKey$ <> "B") And (HKey$ <> "A")
        waitseconds 2
        'T = Timer
        'While Timer - T < 2: DoEvents: Wend
        DoEvents
        ReadXReturnX4 0
        B_Flow = x5
        ReadXReturnX4 2
        b_pres = x5
        progress.Line25.Caption = ts$(229) + ": " + Xformat$((b_pres - p_atm) * PCNV, "###0.000  ") + PU$ + "   " + ts$(30) + ": " + Xformat$(B_Flow, "######0.00") + " cc/min" + str$(lflow%) + "  " + str$(F_Atm) ' "Pressure"/"Flow"/"cc/min"
        progress.Line25.Refresh
        inc_reg 10
    Wend

    If low_flow_controller Then zero_lfctrl
    B_Flow = B_Flow - F_Atm
    fn = FreeFile
    'Open OutFilename$(current_unit%) For Append As #fn
    Open EXE_Path$ + "lastdata.cft" For Append As #fn
        Print #fn, "0,"; str$(p_atm)
        Print #fn, str$(B_Flow); ","; str$(b_pres)
        Print #fn, "0,0"
    Close #fn

    MsgBox ts$(76), 0, ts$(77)           ' "Test Finished Remove Sample"/"done"
    Zero_Reg
    do_final_copy
    'FileCopy EXE_Path$ + "lastdata.cft", OutFilename$(current_unit%)

End Sub

Sub move_compression_regulator_to_pressure(P As Single)

    Dim i As Long
    
    If ip_creg_enable Then
        If creg_table_size% = 0 Then
            ' use a percentage of the range (4000/100)
            ' assuming that P is 0 to 100 i/p range is 0 to 4000
            i = P * 40
        Else
            i = cregpos_from_p(P)
        End If
        zero_creg
        If i > 4000 Then i = 4000
        If CREGPOS < i Then
            inc_creg i - CREGPOS
        End If
        Exit Sub
    End If
    i = 1
    While creg_table_pres!(i) <= P And i < creg_table_size%
        i = i + 1
    Wend
    If i = 1 Then
        i = DAC_zero
    Else
        i = (P - creg_table_pres!(i - 1)) / (creg_table_pres!(i) - creg_table_pres!(i - 1)) * (creg_table_pos(i) - creg_table_pos(i - 1)) + creg_table_pos(i - 1)
    End If
    If i < DAC_zero Then i = DAC_zero ' just in case
    ' bring the regulator to 200 less than the desired value
    ' this will assure that we are below the desired value
    ' so that we can approach it from the bottom
    i = i - DAC_span / 100
    Send_RS232l "GP", i
    While RSEcho("VP", 1) <> Asc("S")
      tryhold
    Wend
    ' now bring the regulator to the final position
    i = i + DAC_span / 100
    Send_RS232l "GP", i
    While RSEcho("VP", 1) <> Asc("S")
      tryhold
    Wend
    
End Sub
Sub set_slurry_wash_pump_aout_by_flow(target_flow As Single) '6.71.123.23

Dim targetSlurryPumpSpeedPOS As Long

    If target_flow > slurry_wash_pump_max_flow_cc Then
        target_flow = slurry_wash_pump_max_flow_cc
    End If
    'directly setting the slurry pump speed was not working
    'now trying to zero it and increase it because the increase was working on the manual conrol screen
    zero_SlurryPumpSpeed
    targetSlurryPumpSpeedPOS = 4000 * (target_flow / slurry_wash_pump_max_flow_cc)
    inc_SlurryPumpSpeed (targetSlurryPumpSpeedPOS)
    
End Sub
Sub move_motorized_regulator_to_pressure(P As Single)

    Dim i As Long
    
    If ip_reg_enable Then
        If reg_table_size%(regnum) = 0 Then
            ' use a percentage of the range (4000/100)
            ' assuming that P is 0 to 100 i/p range is 0 to 4000
            i = P * 40
        Else
            i = regpos_from_p(P)
        End If
        If i > 4000 Then i = 4000
        If REGPOS < i Then
            inc_reg i - REGPOS
        End If
        Exit Sub
    End If
    i = 1
    If regnum = 0 Then
        While reg_table_pres!(i) <= P And i < reg_table_size%(0)
            i = i + 1
        Wend
    Else
        While reg_table_pres2!(i) <= P And i < reg_table_size%(1)
            i = i + 1
        Wend
    End If
    If i = 1 Then Exit Sub
    Rem REGPOS counts roughly how many times we have incremented
    Rem the regulator.  Since we are skipping ahead, we set REGPOS
    Rem to the table index that roughly is the number of increments
    Rem that were used during calibration.
    REGPOS = i
    i = (P - reg_table_pres!(i - 1)) / (reg_table_pres!(i) - reg_table_pres!(i - 1)) * (reg_table_pos(i) - reg_table_pos(i - 1)) + reg_table_pos(i - 1)
    ' assume that regulator will overshoot by 200 counts
    i = i - DAC_span / 100
    'MsgBox "Opening regulator by pressure " + Str$(p) + " to " + Str$(ii%)
    Send_RS232l "G+E", i
    While RSEcho("VE", 1) <> Asc("S")
      tryhold
    Wend
    
End Sub
Sub Move_Valve(VNUM%, oorc$)

 'If VNUM% = 17 Then Exit Sub
'If VNUM% = 12 And oorc$ = "O" Then MsgBox "BAHHHHHHHHHHHHHHH"

Dim jfTest As Boolean, latch As Boolean
Dim k As Single, a$, vnumdebug%

If UseRemap Then
    Debug.Print "Move Valve: "; ValveRemap(VNUM)
Else
    Debug.Print "Move Valve: "; VNUM
End If
  
If LatchValves Then
    If LatchingValves(VNUM%) = True Then
        If oorc$ = "O" Then
            oorc$ = "C"
        Else
            oorc$ = "O"
        End If
        latch = True
    End If
End If

'MsgBox "Valve: " + str$(ValveRemap(VNUM%)) + " Direction: " + oorc$

' now allows -1 through -8 for valves "a" through "h"
' special things for multi chamber systems (which are usually bubble point testers)
If multiChamberSystem Then
    ' if valve "a" is used by a chamber select, we don't want to allow control of valve 4
    ' if valve "b" is used by a chamber select, we don't want to allow control of valve 20
    ' if valve "c" is used by a chamber select, we don't want to allow control of valve 19
    ' if valve "d" is used by a chamber select, we don't want to allow control of valve 21
    ' if valve "e" is used by a chamber select, we don't want to allow control of valve 22
    ' so far, these are the only ones that can interfere.  There may be more in the future
    a$ = Left$(iso_valve_string, chambers)
    If (VNUM% = 3 And InStr(a$, "a") <> 0) Or _
       (VNUM% = 19 And InStr(a$, "b") <> 0) Or _
       (VNUM% = 18 And InStr(a$, "c") <> 0) Or _
       (VNUM% = 20 And InStr(a$, "d") <> 0) Or _
       (VNUM% = 21 And InStr(a$, "e") <> 0) Then
        If UseRemap Then
            If oorc$ = "C" Then Vpos(ValveRemap(VNUM) + 1) = 0 Else Vpos(ValveRemap(VNUM) + 1) = 1 '
        Else
            If oorc$ = "C" Then Vpos(VNUM% + 1) = 0 Else Vpos(VNUM% + 1) = 1
        End If
        Exit Sub
    End If
End If



' special things for dual regulator system
Rem special case when second penetrometer
If Second_Penetrometer And penetrometer_select = 2 Then
    If VNUM% = 8 And Second_Penetrometer_V9 <> 9 Then
        Move_Valve Second_Penetrometer_V9 - 1, oorc$
        Exit Sub
    ElseIf VNUM% = 11 And Second_Penetrometer_V12 <> 12 Then
        Move_Valve Second_Penetrometer_V12 - 1, oorc$
        Exit Sub
    ElseIf VNUM% = 12 And Second_Penetrometer_V13 <> 13 Then
        Move_Valve Second_Penetrometer_V13 - 1, oorc$
        Exit Sub
    ElseIf VNUM% = 22 And Second_Penetrometer_V23 <> 23 Then
        Move_Valve Second_Penetrometer_V23 - 1, oorc$
        Exit Sub
    End If
End If

If dualregulator Then
    If VNUM% = 0 Then
        ' trying to move valve 1.
        ' This is remapped to valve 18 if valve 17 is open
        If Vpos(17) = 1 Then
            VNUM% = 17
        End If
    ElseIf VNUM% = 17 Then
        ' trying to move valve 18
        ' this is remapped to valve 1 if valve 17 is open
        If Vpos(17) = 1 Then
            VNUM% = 0
        End If
    ElseIf VNUM% = 16 Then
        ' trying to move valve 17
        ' if you close valve 17 you are switching from reg2 to
        ' reg1 and you need to switch from valve 18 to 1
        If oorc$ = "C" Then
            Rem preset vpos(17) to close so that valve 1 will work
            Vpos(17) = 0
            If Vpos(18) = 1 Then
                Move_Valve 17, "C"
                Move_Valve 0, "O"
                If Not RUNNING Then
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_open 1
                    Else
                        ManualControl.show_valve_open 1
                    End If
                End If
            End If
        ElseIf oorc$ = "O" Then
            ' if you open valve 17, you are switching from
            ' reg1 to reg2 and you need to switch from valve
            ' 1 to 18
            Vpos(17) = 0
            If Vpos(1) = 1 Then
                Move_Valve 0, "C"
                If Not RUNNING Then
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_closed 1
                    Else
                        ManualControl.show_valve_closed 1
                    End If
                End If
                Move_Valve 17, "O"
            End If
        End If
    End If
End If
    
'If VNUM% = 2 Then
'    jfTest = True
'End If

If PA <> 0 Then
    Rem now for special case where you can't have the drain valve
    Rem and the auto-fill valve open at the same time
    Rem note that Vpos is indexed by the valve number while Move_Valve
    Rem is called with one less than the valve number - confusing?
    ' if you have external hydrohead, then there is no limitation
    ' also, in version 7 there is no limitation because the autofill
    ' valve is not part of the drain valve system any more
    If (Not externalhydrohead) And (version < 7) Then
        If VNUM% = 2 And Vpos(13) = 1 Then Move_Valve 12, "C"
        If VNUM% = 12 And Vpos(3) = 1 Then Move_Valve 2, "C"
    End If
    Rem now for special case of calling with valve 2, which should result
    Rem in the valve pulsing rather than opening
    If VNUM% = 1 Then
        If oorc$ = "O" Then
            Send_RS232 ("I" + mv1_index_char)
        Else
            Send_RS232 ("D" + mv1_index_char)
        End If
    Else
        Rem normal valve open or close
        If VNUM% >= 0 Then
            If UseRemap And VNUM% >= LBound(ValveRemap) And VNUM% <= UBound(ValveRemap) Then
                Send_RS232 (oorc$ + Chr$(Asc("A") + ValveRemap(VNUM%)))
            Else
                Send_RS232 (oorc$ + Chr$(Asc("A") + VNUM%))
            End If
        Else
            'Send_RS232 (oorc$ + Chr$(Asc("a") - VNUM% - 1))
            Send_RS232 (oorc$ + Mid$(iso_valve_string$, -VNUM%, 1))
        End If
    End If
    Rem now wait for the valve to stop
    If VNUM% >= 0 Then ' negative valve numbers are always solenoid
        While RSEcho("V" + Chr$(Asc("A") + VNUM%), 1) <> Asc("S")
            tryhold
        Wend
    End If

    'k = Timer
    'While (Timer - k < 0.1) And (Timer >= k)
    waitseconds 0.1
    'DoEvents
    'Wend
End If

' second penetrometer valves uses first valve's status variables
If Second_Penetrometer And penetrometer_select = 2 Then
    If VNUM% = Second_Penetrometer_V9 - 1 Then
        VNUM% = 8
    ElseIf VNUM% = Second_Penetrometer_V12 - 1 Then
        VNUM% = 11
    ElseIf VNUM% = Second_Penetrometer_V13 - 1 Then
        VNUM% = 12
    ElseIf VNUM% = Second_Penetrometer_V23 - 1 Then
        VNUM% = 22
    End If
End If

If pneumaticSwitchValveForPiston And (VNUM% = 14 Or VNUM% = 15) Then
    If VNUM% = 14 Then
        Vpos(15) = 1
        piston_status = 1
    ElseIf VNUM% = 15 Then
        Vpos(15) = 0
        piston_status = 2
    End If
Else
    'If UseRemap And Not latch Then
        'If oorc$ = "C" Then Vpos(VNUM + 1) = 0 Else Vpos(VNUM + 1) = 1
    If latch = True Then
        If oorc$ = "C" Then Vpos(VNUM + 1) = 1 Else Vpos(VNUM + 1) = 0
    Else
        If oorc$ = "C" Then Vpos(VNUM% + 1) = 0 Else Vpos(VNUM% + 1) = 1
    End If
    
    If VNUM% = 14 Then
        ' remember last piston status, which is slightly different from vpos(15) in that
        ' it can have an "unknown" value of 0, a "known open" value of 1, and a
        ' "known closed" value of 2
        ' the "unknown value is default when you start the program
        ' Note that the piston is "open" when the valve is closed
        If oorc$ = "C" Then piston_status = 1 Else piston_status = 2
    End If
End If


End Sub

Function Move2_Error(dx$, i As Integer, ITER As Integer) As Integer
    
    Dim T As Single
    Dim Index As Integer
    Dim VStop As Boolean
    ' this is only called by valvetest
    Static XTime As Single
    Static LIndex As Integer
    
    If dx$ = "C" Then Index = 0
    If dx$ = "O" Then Index = 1
    
    VStop = True
    LIndex = Index
        
    If Index = 1 And v2 < oLimit Then
        Send_RS232 ("O" + mv1_index_char)
    ElseIf Index = 0 And v2 > cLimit Then
        Send_RS232 ("C" + mv1_index_char)
    End If
    
    'T = Timer: While Timer - T <= 2#: DoEvents: Wend
    waitseconds 2
    XTime = Timer
    Do
        DoEvents
        ReadXReturnX4 3
        If oLimit = cLimit Then
            x5 = 0.5
        Else
            x5 = (x4 - cLimit) / (oLimit - cLimit)
        End If
        If x5 > 1 Then x5 = 1
        If x5 < 0 Then x5 = 0
        If hasMultipleMVs Then
            ManualControl1.Valve_Pos(2).Caption = ts$(230) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Format$(x5, "##0.00%") + " " + ts$(232) ' "Valve 2"/"Counts"/"Open"
        Else
            ManualControl.Valve_Pos(2).Caption = ts$(230) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Format$(x5, "##0.00%") + " " + ts$(232) ' "Valve 2"/"Counts"/"Open"
        End If
        
        If LIndex = 1 Then
            If hasMultipleMVs Then
                ManualControl1.Valve_Pos(2).Caption = ts$(230) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Format$(x5, "##0.00%") + " " + ts$(233) + str$(i) + " " + ts$(235) + str$(ITER) ' "Valve 2"/"Counts"/"Opening"/"of"
            Else
                ManualControl.Valve_Pos(2).Caption = ts$(230) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Format$(x5, "##0.00%") + " " + ts$(233) + str$(i) + " " + ts$(235) + str$(ITER) ' "Valve 2"/"Counts"/"Opening"/"of"
            End If
        End If
        
        If LIndex = 0 Then
            If hasMultipleMVs Then
                ManualControl1.Valve_Pos(2).Caption = ts$(230) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Format$(x5, "##0.00%") + " " + ts$(234) + str$(i) + " " + ts$(235) + str$(ITER) ' "Valve 2"/"Counts"/"Closing"/"of"
            Else
                ManualControl.Valve_Pos(2).Caption = ts$(230) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Format$(x5, "##0.00%") + " " + ts$(234) + str$(i) + " " + ts$(235) + str$(ITER) ' "Valve 2"/"Counts"/"Closing"/"of"
            End If
        End If
        
        If (x4 > oLimit) Then x4 = oLimit
        If (x4 < cLimit) Then x4 = cLimit
        v2 = x4
        If (x4 >= oLimit And LIndex = 1) Or (x4 <= cLimit And LIndex = 0) Or (Cancel_Aborted = True) Then
            VStop = False
            Move2_Error = -1
            Send_RS232 ("S" + mv1_index_char)
        End If
        If (Timer - XTime > 180) Then
            Move2_Error = Index
            VStop = False
            Send_RS232 ("S" + mv1_index_char)
        End If
    Loop While VStop
    
End Function

Sub Move2V2Pos()
' Move valve 2 closed until it hits position on V2POS
' only moves in the close direction
' AJB 12-20-09 added support for second motor valve

    If Not hasMultipleMVs Then
        ReadXReturnX4 3
        If x4 <= V2POS Then Exit Sub
    
        Rem real easy this one!
        Send_RS232l "G-" + mv1_index_char, IIf(V2POS < 0, 0, V2POS)
        While RSEcho("V" + mv1_index_char, 1) <> Asc("S")

            tryhold
        Wend
    Else
        ReadXReturnX4 3
        If motorValveIndex = 0 Then
            
            If x4 <= V2POS Then Exit Sub
    
            Rem real easy this one!
            Send_RS232l "G-" + mv1_index_char, IIf(V2POS < 0, 0, V2POS)
            While RSEcho("V" + mv1_index_char, 1) <> Asc("S")

                tryhold
            Wend
        Else
            If x4 <= V2POS Then Exit Sub
    
            Rem real easy this one!
            Send_RS232l "G-" + mv2_index_char, IIf(V2POS < 0, 0, V2POS)
            While RSEcho("V" + mv2_index_char, 1) <> Asc("S")
                tryhold
            Wend
        End If
    End If
End Sub

Sub openv2completely()
    'AJB 12-20-09 added support for second motor valve
    
    If nov2 Then Exit Sub
    If v2solenoid Then
        Move_Valve 1, "O"
        
        Exit Sub
    End If
    ReadXReturnX4 3
    If Not hasMultipleMVs Then
        If x4 >= oLimit Then Exit Sub
        Send_RS232 ("O" + mv1_index_char)
        Do While RSEcho("V" + mv1_index_char, 1) <> Asc("S")
            ReadXReturnX4 3
            If x4 >= oLimit Then
                Send_RS232 ("S" + mv1_index_char)
                Exit Do
            End If
            tryhold
        Loop
    Else
        If motorValveIndex = 0 Then
            If x4 >= oLimit Then Exit Sub
            Send_RS232 ("O" + mv1_index_char)
            Do While RSEcho("V" + mv1_index_char, 1) <> Asc("S")
                ReadXReturnX4 3
                If x4 >= oLimit Then
                    Send_RS232 ("S" + mv1_index_char)
                    Exit Do
                End If
                tryhold
            Loop
        ElseIf motorValveIndex = 1 Then
            If x4 >= olimit2 Then Exit Sub
            Send_RS232 ("O" + mv2_index_char)
            Do While RSEcho("V" + mv2_index_char, 1) <> Asc("S")
                ReadXReturnX4 3
                If x4 >= olimit2 Then
                    Send_RS232 ("S" + mv2_index_char)
                    Exit Do
                End If
                tryhold
            Loop
        ElseIf motorValveIndex = 2 Then
            If x4 >= olimit3 Then Exit Sub
            Send_RS232 ("O" + mv3_index_char)
            Do While RSEcho("V" + mv3_index_char, 1) <> Asc("S")
                ReadXReturnX4 3
                If x4 >= olimit3 Then
                    Send_RS232 ("S" + mv3_index_char)
                    Exit Do
                End If
                tryhold
            Loop
        End If
    End If
    
    
'    Do While RSEcho("VB", 1) <> Asc("S")
'        ReadXReturnX4 3
'        If x4 >= olimit Then
'            Send_RS232 ("SB")
'            Exit Do
'        End If
'        tryhold
'    Loop
'
End Sub

Sub OPENV2MOSTLY()
    'AJB 12-20-09 added support for second motor valve
    
    Dim vtarg As Long
    
    If nov2 Then Exit Sub
    If v2solenoid Then
        Move_Valve 1, "O"
        Exit Sub
    End If
    ReadXReturnX4 3
    vtarg = V2Percent * (oLimit - cLimit) / 100 + cLimit
    If x4 >= vtarg Then Exit Sub

    Send_RS232l "G+" + mv1_index_char, vtarg
    While RSEcho("V" + mv1_index_char, 1) <> Asc("S")
        tryhold
    Wend
    
End Sub

Sub OpenV2Pos()
    
    ReadXReturnX4 3
    If x4 >= V2POS Then Exit Sub

    If v2solenoid Then
        Move_Valve 1, "O"
        Exit Sub
    End If
    
    Rem real easy this one! 'AJB 12-20-09 added support for second mv2 control
    If Not hasMultipleMVs Then
        Send_RS232l "G+" + mv1_index_char, V2POS
        While RSEcho("V" + mv1_index_char, 1) <> Asc("S")

            tryhold
        Wend
        ReadXReturnX4 3
    Else
        If motorValveIndex = 0 Then
            Send_RS232l "G+" + mv1_index_char, V2POS
            While RSEcho("V" + mv1_index_char, 1) <> Asc("S")

                tryhold
            Wend
            ReadXReturnX4 3
        ElseIf motorValveIndex = 1 Then
            Send_RS232l "G+" + mv2_index_char, V2POS
            While RSEcho("V" + mv2_index_char, 1) <> Asc("S")
                tryhold
            Wend
            ReadXReturnX4 3
        ElseIf motorValveIndex = 2 Then
            Send_RS232l "G+" + mv3_index_char, V2POS
            While RSEcho("V" + mv3_index_char, 1) <> Asc("S")
                tryhold
            Wend
            ReadXReturnX4 3
        End If
    End If
    
    If hasHumidityControls And enableHumidityControlForAutoTests Then
        goToTargetHumidity
    End If
    
    If cv_withmulti_v2 Then Done_with_v2 = True

End Sub

Function p_from_regpos(r As Long) As Single
' return the current pressure that should be coming out
' of the regulator based on the reg_table

Dim i As Integer

If reg_table_size%(regnum) <= 1 Then
    ' estimate based on reg_ol and reg_cl and 0 to 100 PSI
    If r <= reg_cl Then
        p_from_regpos = 0
    ElseIf r >= reg_ol Then
        p_from_regpos = 100
    Else
        p_from_regpos = (r - reg_cl) * 100# / (reg_ol - reg_cl)
    End If
Else
    i = 2
    If regnum = 0 Then
        While i < reg_table_size%(0) And r > reg_table_pos(i)
            i = i + 1
        Wend
        p_from_regpos = (r - reg_table_pos(i - 1)) * (reg_table_pres!(i) - reg_table_pres!(i - 1)) / (reg_table_pos(i) - reg_table_pos(i - 1)) + reg_table_pres!(i - 1)
    Else
        While i < reg_table_size%(1) And r > reg_table_pos2(i)
            i = i + 1
        Wend
        p_from_regpos = (r - reg_table_pos2(i - 1)) * (reg_table_pres2!(i) - reg_table_pres2!(i - 1)) / (reg_table_pos2(i) - reg_table_pos2(i - 1)) + reg_table_pres2!(i - 1)
    End If
End If

End Function

Sub Pre_Elev_LqPerm()
    
    Dim fn As Integer, i As Integer
    Dim ptemp$
    
' **********
' Begin code inserted by search for Tim Richards on Monday 6/14/04
' change     Msgform.Label.Caption = Format$(x5, "#0.00 \c\m   ") + Format$(x4, "####0 " + ts$(432))  ' "\c\m"/"\c\o\u\n\t\s"
'
    Dim s_local_BalanceNotPenet_gm_cm As String
    Dim s_local_BalanceNotPenet_Height_Mass As String
  
    If g_bBalanceNotPenet = True Then
        s_local_BalanceNotPenet_gm_cm = ts$(484)
        s_local_BalanceNotPenet_Height_Mass = ts$(486)
    Else
        s_local_BalanceNotPenet_gm_cm = ts$(485)
        s_local_BalanceNotPenet_Height_Mass = ts$(243)
    End If
'
' End code inserted by Tim Richards 6/14/04
' **********
    elev_lqperm_ck = True
    Zero_Reg
    ReadXReturnX4 2
' don't zero the temperature on recirculation systems
    'If temperature% > 0 And recirculation = False Then
' 6.71.87 - don't zero the temperature.  They can always zero it from the front panel
' or from manual control if they need to.  Modern liquid perm machines want to maintain
' temperature all the time because they take so long to heat up.  The elevated test
' did not set the temperature back to testing temperature, so this didn't work anyway.
'    If wetChamberTemperature <> 0 And recirculation = False Then
'        ' set temperature to 0 to let it cool off
'        'Send_RS232 ";" + vbNullChar + vbNullChar
'        setNewTemperature wetChamberTemperature, 0
'    End If
    DoEvents
    'PTARG = X5
    FillDone = True

    ' Certain values do not have to be queried if we are using a pressure step list
    If PS_usingList Then
        
        ' Load in the list here -- temporarily
        If (PS_path$ = "") Then
            ' Open a file box for the user
            fsel_path$ = EXE_Path$ + "\parms\*.psl"
            fsel_title$ = ts$(497)      ' "Choose pressure list"
            fsel_name$ = ""
            fsel_io = True
            fsel TitleScrn.hwnd
                
            If fsel_return = "" Then Aborted = True: Exit Sub
            PS_path$ = fsel_return
        End If
        
        ' Pathname should be valid now, so load all the steps into our step structure
        fn = FreeFile
        Open PS_path$ For Input As #fn
        Input #fn, ptemp$
        With pressure_steps
            .count = val(Right$(ptemp$, Len(ptemp$) - 1))
            ReDim .values(.count)
            For i = 1 To .count
                Input #fn, ptemp$
                .values(i) = val(ptemp$) / PCNV
            Next i
        End With
        Close #fn
        
        ' Set the initial pressure to our first step list value, and the max pressure to the last
        ptarg = pressure_steps.values(1)
        MaxP = pressure_steps.values(pressure_steps.count)
        ' if num > 1 then set deltap to some nonzero value, because 0 is a flag for some extra funky junk we don't want.
        If pressure_steps.count > 1 Then
            DELTAP = 1
        Else
            DELTAP = 0
        End If
        
        ' Perform the checks that would normally be done as validation of user input below
        If autocompress And Compression_Increase_Factor < 0 And compression_pressure <> 0 And ptarg * Abs(Compression_Increase_Factor) > compression_pressure Then
            MsgBox ts$(448)     ' "The starting pressure is too high for the current compression pressure setting"
            Aborted = True
            Exit Sub
        End If
        
        If autocompress And Compression_Increase_Factor < 0 And compression_pressure <> 0 And MaxP * Abs(Compression_Increase_Factor) > compression_pressure Then
            MsgBox ts$(448)         ' "Maximum pressure too high with current compression pressure setting"
            Aborted = True
            Exit Sub
        End If
    
    Else
        If qcshow(16) = Null Or qcshow(16) = 0 Then
            elev_lqperm_startPres = False
        Else
            elev_lqperm_startPres = True
        End If
        If qcshow(17) = Null Or qcshow(17) = 0 Then
            elev_lqperm_steppres = False
        Else
            elev_lqperm_steppres = True
        End If
        If qcshow(18) = Null Or qcshow(18) = 0 Then
            elev_lqperm_maxpres = False
        Else
            elev_lqperm_maxpres = True
        End If
        If qcshow(19) = Null Or qcshow(19) = 0 Then
            elev_LqPerm_wait_sec = False
        Else
            elev_LqPerm_wait_sec = True
        End If
        If qcshow(20) = Null Or qcshow(20) = 0 Then
            elev_lqperm_maxpoints = False
        Else
            elev_lqperm_maxpoints = True
        End If
        If qcshow(21) = Null Or qcshow(21) = 0 Then
            elev_lqperm_startPres = False
        Else
            elev_lqperm_startPres = True
        End If
        
        lpParameters.Show 1
        If lperm_user_cancelled Then Aborted = True
redo_sp:
'        If supervisor = True Or elev_lqperm_startPres = True Then
'            GetValue.Label1.Caption = ts$(236) + " (" + PU$ + " " + ts$(179) + "):"            ' "Enter starting pressure"/"Differential"
'            GetValue.Continue.default = True
'            If lperm_startp > max_liq_pres Then lperm_startp = max_liq_pres
'            GetValue.Text1.Text = LTrim$(str$(lperm_startp * PCNV))
'            GetValue.Text1.SelStart = 0
'            GetValue.Text1.SelLength = Len(GetValue.Text1.Text)
'            If elev_lqperm_startPres = True Then
'                GetValue.Check1.value = 1
'            Else
'                GetValue.Check1.value = 0
'            End If
'            GetValue.Show 1
'            If Got_Value = -9 Then
'                Aborted = True
'                Exit Sub
'            End If
'            ptarg = Got_Value / PCNV
'            If Got_Value_Check = 0 Then
'                elev_lqperm_startPres = False
'            Else
'                elev_lqperm_startPres = True
'            End If
'            If ptarg > max_liq_pres Then
'                MsgBox (ts$(237) + " " + str$(max_liq_pres * PCNV))     ' "Maximum pressure is"
'                GoTo redo_sp
'            End If
'
'            ' 6.71.22a begin
'            If autocompress And Compression_Increase_Factor < 0 And compression_pressure <> 0 And ptarg * Abs(Compression_Increase_Factor) > compression_pressure Then
'                MsgBox ts$(448)     ' "The starting pressure is too high for the current compression pressure setting"
'                GoTo redo_sp
'            End If
'            ' 6.71.22a end
'
'            ' for now, ptarg remains in differential pressure
'            'ptarg = ptarg + X5
'        Else
'              ptarg = lperm_startp
'        End If
        
'        If supervisor = True Or elev_lqperm_steppres = True Then
'            GetValue.Label1.Caption = ts$(240) + " (" + PU$ + "):"      ' "Enter point step pressure"
'            GetValue.Continue.default = True
'            GetValue.Text1.Text = LTrim$(str$(lperm_stepp * PCNV))
'            GetValue.Text1.SelStart = 0
'            GetValue.Text1.SelLength = Len(GetValue.Text1.Text)
'            If elev_lqperm_steppres = True Then
'                GetValue.Check1.value = 1
'            Else
'                GetValue.Check1.value = 0
'            End If
'            GetValue.Show 1
'            If Got_Value = -9 Then
'                Aborted = True
'                Exit Sub
'            End If
'            If Got_Value_Check = 0 Then
'                elev_lqperm_steppres = False
'            Else
'                elev_lqperm_steppres = True
'            End If
'            If Got_Value < 0 Then Got_Value = 0
'            DELTAP = Got_Value / PCNV
'        Else
'            DELTAP = lperm_stepp
'        End If
        DELTAP = lperm_stepp
        ' skip the maximum pressure prompt if deltap=0
'        If DELTAP = 0 Then
'            MaxP = ptarg
'        Else
'redo_mp:
'            If supervisor = True Or elev_lqperm_maxpres = True Then
'                GetValue.Label1.Caption = ts$(238) + " (" + PU$ + " " + ts$(179) + "):" ' "Enter maximum pressure"/"Differential"
'                GetValue.Continue.default = True
'                If lperm_maxp > max_liq_pres Then lperm_maxp = max_liq_pres
'                GetValue.Text1.Text = LTrim$(str$(lperm_maxp * PCNV))
'                GetValue.Text1.SelStart = 0
'                GetValue.Text1.SelLength = Len(GetValue.Text1.Text)
'                If elev_lqperm_maxpres = True Then
'                    GetValue.Check1.value = 1
'                Else
'                    GetValue.Check1.value = 0
'                End If
'                GetValue.Show 1
'                If Got_Value = -9 Then
'                    Aborted = True
'                    Exit Sub
'                End If
'                If Got_Value_Check = 0 Then
'                    elev_lqperm_maxpres = False
'                Else
'                    elev_lqperm_maxpres = True
'                End If
'                MaxP = Got_Value / PCNV
'                If MaxP > max_liq_pres Then
'                    MsgBox (ts$(237) + " " + str$(max_liq_pres * PCNV))     ' "Maximum pressure is"
'                    GoTo redo_mp
'                End If
'                If MaxP < ptarg Then
'                    MsgBox (ts$(239))       ' "Maximum pressure can not be less than starting pressure"
'                    GoTo redo_mp
'                End If
'                ' 6.71.22a begin
'                If autocompress And Compression_Increase_Factor < 0 And compression_pressure <> 0 And MaxP * Abs(Compression_Increase_Factor) > compression_pressure Then
'                    MsgBox ts$(448)         ' "Maximum pressure too high with current compression pressure setting"
'                    GoTo redo_mp
'                End If
'                ' 6.71.22a end
'            Else
'                MaxP = lperm_maxp
'            End If
'        End If
'
     End If          ' not PS_UsingList Closes if block started ln 10259 else on ln 10311
    
    ' for now, MaxP remains in differential pressure
    'MaxP = MaxP + X5
    ' set global maxpress to the current maximum pressure
    Maxpres = lperm_maxp
    ' switch regulators, if necessary
    ' 6.71.20
    using_low_regulator = False
    If dualregulator Then
        If use_second_regulator_only Then
            Move_Valve 16, "O"
            regnum = 1
            If (air_inlets = 2) Then
                Move_Valve 15, "O"
                current_air_inlet = 2
            End If

        ElseIf Maxpres >= reg1pmax Then
            ' 6.71.20 begin - this has not been checked yet
            If second_regulator_starting_point = 0 Then
                Move_Valve 16, "O"
                regnum = 1
                If (air_inlets = 2) Then
                    Move_Valve 15, "O"
                    current_air_inlet = 2
                End If

            Else
                using_low_regulator = True
                Move_Valve 16, "C"
                regnum = 0
                If (air_inlets = 2) Then
                    Move_Valve 15, "C"
                    current_air_inlet = 1

                End If

            End If
            ' 6.71.20 end
        Else
            using_low_regulator = True
            Move_Valve 16, "C"
            regnum = 0
            If (air_inlets = 2) Then
                Move_Valve 15, "C"
                current_air_inlet = 1
            End If

        End If
    End If

    initp = 0: inrange = False
'If supervisor = True Or elev_LqPerm_wait_sec = True Then
'    GetValue.Label1.Caption = ts$(241) + ":"                    ' "Enter maximum wait between points (sec)"
'    GetValue.Continue.default = True
'    GetValue.Text1.Text = LTrim$(str$(lperm_maxwait))
'    GetValue.Text1.SelStart = 0
'    GetValue.Text1.SelLength = Len(GetValue.Text1.Text)
'    If elev_LqPerm_wait_sec = True Then
'        GetValue.Check1.value = 1
'    Else
'        GetValue.Check1.value = 0
'    End If
'    GetValue.Show 1
'    If Got_Value = -9 Then
'        Aborted = True
'        Exit Sub
'    End If
'    If Got_Value_Check = 0 Then
'        elev_LqPerm_wait_sec = False
'    Else
'        elev_LqPerm_wait_sec = True
'    End If
'    maxWait = Got_Value
'    If maxWait = 0 Then maxWait = 9.999999E+35
'Else
'    maxWait = lperm_maxwait
'End If

' **********
' Begin balance not penetrometer code entered by Tim Richards on Wednesday 8/04/04 12:49 PM
' add another user input for initial settling time before taking readings
'
    If g_bBalanceNotPenet = True Then
        Dim iSettlingTime As Single
    
        GetValue.Label1.Caption = ts$(483) + ":"                    ' "Enter settling time once target pressure is attained:") 'TAR 040804
        GetValue.Continue.default = True
        GetValue.Text1.Text = LTrim$(str$(g_iBalanceNotPenet_SettlingTime))
        GetValue.Text1.SelStart = 0
        GetValue.Text1.SelLength = Len(GetValue.Text1.Text)
        GetValue.Show 1
        If Got_Value = -9 Then
            Aborted = True
            Exit Sub
        End If
            iSettlingTime = Got_Value
        If iSettlingTime < 0 Then iSettlingTime = 0

        g_iBalanceNotPenet_SettlingTime = iSettlingTime 'TAR 040804
    End If
'
' end code entered by Tim Richards 8/04/04
' **********
'If supervisor = True Or elev_lqperm_maxpoints = True Then
'    GetValue.Label1.Caption = ts$(242) + ":"    ' "Enter maximum number of points"
'    GetValue.Continue.default = True
'    GetValue.Text1.Text = LTrim$(str$(lperm_maxpoints))
'    GetValue.Text1.SelStart = 0
'    GetValue.Text1.SelLength = Len(GetValue.Text1.Text)
'    If elev_lqperm_maxpoints = True Then
'        GetValue.Check1.value = 1
'    Else
'        GetValue.Check1.value = 0
'    End If
'    GetValue.Show 1
'    If Got_Value <> -9 Then maxPoints = Got_Value
'    If Got_Value_Check = 0 Then
'        elev_lqperm_maxpoints = False
'    Else
'        elev_lqperm_maxpoints = True
'    End If
'    If maxPoints = 0 Then maxPoints = 100
'Else
'    maxPoints = lperm_maxpoints
'End If
    DoEvents
    
    progress.List1.clear

' **********
' Begin balance not penetrometer code change by Tim Richards Sunday 6/20/04 5:27PM
' change progress.List1.AddItem s_local_BalanceNotPenet_Height_Mass + " (" + s_local_BalanceNotPenet_gm_cm + ")     " + ts$(229) + " (" + Left$(PU$ + "    ", 4) + ")       " + ts$(30) + " (cc/min)      " + ts$(74) + " (" + ts$(75) + ")" ' "Height"/"cm"/"Pressure"/"Flow"/"cc/min"/"Time"/"min"
'
    If g_bBalanceNotPenet = True Then
        progress.List1.AddItem ts$(229) + " (" + Left$(PU$ + "    ", 4) + ")      " + s_local_BalanceNotPenet_Height_Mass + " (" + s_local_BalanceNotPenet_gm_cm + ")     " + ts$(74) + " (" + ts$(75) + ")      " + ts$(30) + " (cc/min)" ' "Pressure"/"Height"/"cm"/"Time"/"min"/"Flow"/"cc/min"
    Else
        progress.List1.AddItem s_local_BalanceNotPenet_Height_Mass + " (" + s_local_BalanceNotPenet_gm_cm + ")     " + ts$(229) + " (" + Left$(PU$ + "    ", 4) + ")       " + ts$(30) + " (cc/min)      " + ts$(74) + " (" + ts$(75) + ")" ' "Height"/"cm"/"Pressure"/"Flow"/"cc/min"/"Time"/"min"
    End If
'
' End code entered by Tim Richards 6/20/04
' **********

    progress.List1.AddItem " "
'    lperm_startp = ptarg
'    lperm_maxp = MaxP
'    lperm_stepp = DELTAP
'    lperm_maxwait = maxWait
'    lperm_maxpoints = maxPoints

    ptarg = lperm_startp
    MaxP = lperm_maxp
    DELTAP = lperm_stepp
    maxWait = lperm_maxwait
    maxPoints = lperm_maxpoints

    If elev_lqperm_startPres = False Then
        qcshow(16) = 0
    Else
        qcshow(16) = 1
    End If
    If elev_lqperm_steppres = False Then
        qcshow(17) = 0
    Else
        qcshow(17) = 1
    End If
    If elev_lqperm_maxpres = False Then
        qcshow(18) = 0
    Else
        qcshow(18) = 1
    End If
    If elev_LqPerm_wait_sec = False Then
        qcshow(19) = 0
    Else
        qcshow(19) = 1
    End If
    If elev_lqperm_maxpoints = False Then
        qcshow(20) = 0
    Else
        qcshow(20) = 1
    End If
    elev_lqperm_ck = False
    save_user_global_stuff

End Sub

Sub Pressure_Hold()
' Runs a pressure hold test from start to finish. Does not use run_c_pass.
' The count step decreased from 10 to 2
    Dim i As Long
    Dim best_pressure_seen As Single        ' vars for stabilizing pressure at start of test
    Dim times_since_better As Integer       ' likewise
    Dim p_atm As Single                     ' atmospheric pressure
    Dim T As Single                         ' Timer reading
    Dim tlast As Single                     ' previous averaged time reading
    Dim tstart As Single                    ' initial time reading
    Dim b_pres As Single                    ' current raw pressure reading
    Dim b_time As Single                    ' current time reading
    Dim fn As Integer                       ' file number
    Dim initial_pressure As Single          ' initial raw pressure reading
    Dim failed As Boolean                   ' did pressure decay too quickly?
    Dim tempstring$, addendum$
    Dim temp1$, temp2$
    Dim volume As Single                    ' Chamber volume, if available
    Dim CCs As Single                       ' volume of delta P
    Dim nStep As Integer                    ' will control counter step increament
    ' For data averaging
    Dim tempReadings As Single              ' pressure readings to average together
    Dim readingCount As Integer             ' Don't start averaging until there are enough points
    
    Dim HPress As Single                    ' got tired of typing "Hold_Press(current_unit%)"
    Dim HRate As Single                     ' Ditto
    
    ' For graphing
    Dim lastymax As Single, lastymin As Single
    Dim newymin As Single, newymax As Single
    Dim first_reading As Single
    
    ' For data collection
    Dim numdatapoints As Long               ' Number of points in the array
    Dim numseconds As Long                  ' Time counter: added 6.71.62 to allow for multiple-day tests
    Dim data_array() As Single
    Dim array_limit As Long                 ' Current length of data_array
    Dim stat_array As xy_data               ' Container for regression calculation
    Dim result As stat_return
    Dim time_added As Long
    
    Dim finalfail As Single                 ' average pressure decay rate
    Dim fail_check As Single                ' dp/dt or dp for pass/fail comparison
    
    If (m_bBPCreateLogFile) Then
'        Dim filenameBase$
'        filenameBase$ = Left$(OutFilename$(current_unit%), Len(OutFilename$(current_unit%)) - 4)


        Dim fnLog As Integer
        fnLog = FreeFile
        Open OutLogFileName$(current_unit%) For Output As #fnLog
        Dim strHead As String
        strHead = "Time(sec)  Pressure(Psi) "
        Print #fnLog, strHead
    End If

    If status_lights_enable Then setStatusLights 2
    HPress = Hold_Press(current_unit%)
    HRate = Hold_Rate(current_unit%)
    If (pressHoldUnit = "M") And (PH_fail_method$ = "dpdt") Then HRate = HRate / 60 ' We want hold_rate to be PSI/sec, not PSI/min
    If HRate = 0 Then HRate = 0.00001
    'If manualMultiChamber = False Or manuallySelectedChamber = 1 Then
    If manuallySelectedChamber = 1 Then
        volume = val(gpps2("Capstuff", "Chamber_Volume", CSFile$, "-1"))
    Else
        volume = val(gpps2("Capstuff", "Chamber_Volume" + Format$(manuallySelectedChamber), CSFile$, "-1"))
    End If
    CCs = -1
    ' use smaller step for the smaller pressure values ( less than 1 Psi)
    If HPress < 1 Then
        nStep = 2
    Else
        nStep = 10
    End If
           
    RunTimer = Timer
    progress.Timer1.Interval = 2000
    progress.Timer1.Enabled = True
    progress.Label2.Caption = ts$(74) + " - " + ts$(245) ' "Time - sec."
    Zero_Reg
    Pres% = 1
    ReadXReturnX4 2
    p_atm = x5
    If (m_bBPCreateLogFile) Then
        Print #fnLog, Xformat$(Timer - RunTimer, "###0.00") + "   " + Xformat$(p_atm, "##0.000")
    End If
    If ExtraPG Then
      'If Hold_Pres + P_Atm < PY2(2) Then
      '  Move_Valve 10, "O"
      '  pres% = 2
      'Else
        Move_Valve 10, "C"
      '  pres% = 1
      'End If
    End If
    OPENV2MOSTLY
    Move_Valve 0, "C"
    If dualregulator Then Move_Valve 17, "C" ' just in case

    'progress.Picture1.ScaleHeight = 1.75 * Hold_Press(current_unit%)
    'progress.Picture1.ScaleWidth = Hold_Time(current_unit%)
   ' firstymax = 1.75 * HPress
   ' firstymin = 0
    progress.X_Max.Caption = str$(Hold_Time(current_unit%))

    times_since_better = 0
    best_pressure_seen = -100
    
    If ip_reg_enable Then
        'MsgBox "Calling regpos_from_p with " + str$(HPress)
        i = regpos_from_p(HPress)
        'MsgBox "Return valus is " + str$(i)
        If i > 20 Then inc_reg i - 20
    End If
    Do
'       inc_reg 10
        inc_reg nStep
        waitseconds 1
        'T = Timer
        'While Timer - T < 1: DoEvents: Wend
        ReadXReturnX4 2
        If (m_bBPCreateLogFile) Then
            Print #fnLog, Xformat$(Timer - RunTimer, "###0.00") + "   " + Xformat$(x5 - p_atm, "##0.000")
        End If

        progress.Line25.Caption = ts$(229) + ": " + Xformat$((x5 - p_atm) * PCNV, "###0.000  ") + PU$   ' "Pressure"
        If best_pressure_seen < x5 Then
            best_pressure_seen = x5
            times_since_better = 0
        Else
            times_since_better = times_since_better + 1
        End If
        Rem don't timeout if regulator is less than 25%
        If REGPOS < 30 Then times_since_better = 0
        progress.Refresh
        DoEvents
    Loop While ((x5 - p_atm) < HPress) And (times_since_better < 20) And (Not Aborted)
    plast = x5 - p_atm
    
    ' read initial pressure once
    ReadXReturnX4 2
    initial_pressure = x5
    If (m_bBPCreateLogFile) Then
        Print #fnLog, Xformat$(Timer - RunTimer, "###0.00") + "   " + Xformat$(x5 - p_atm, "##0.000")
    End If
  
  
    ' Write header to file
    fn = FreeFile
    Open EXE_Path$ + "lastdata.cft" For Output As #fn
    Print #fn, "EXTENDED"
    Print #fn, 2
    Print #fn, "Operator="; operator$(current_unit%)
    Print #fn, "Lot Number="; lot_number$(current_unit%)
    Print #fn, "HOLD"
    Print #fn, date$
    Print #fn, Line1$(current_unit%)
    Print #fn, Line2$(current_unit%)
    If Len(Gas$) < 21 Then
        Print #fn, Gas$
    Else
        Print #fn, Mid$(Gas$, 21)
    End If
    Print #fn, sid$(current_unit%)
    
    excercize_valve_2

    ' Start the test
    tstart = Timer
    ' delay time - wait before taking readings
    While ((Timer - tstart) < Hold_Delay(current_unit%)) And (HKey$ <> "A") And (Not Aborted)
        T = Timer
        DoEvents
        ReadXReturnX4 2
        b_pres = x5
        b_time = Timer - tstart
        If (m_bBPCreateLogFile) Then
            Print #fnLog, Xformat$(T - tstart, "###0.00") + "   " + Xformat$(b_pres - p_atm, "##0.000")
        End If

        progress.Line25.Caption = ts$(229) + ": " + Xformat$((b_pres - p_atm) * PCNV, "###0.000  ") + PU$ + "  " + ts$(246) + ": " + Format$(b_time, "#####0.00 ") + ts$(245) ' "Pressure"/"Delay Time"/"sec."
        progress.Line25.Refresh
    Wend

    ' read initial pressure second time if ...
    If (Hold_Delay(current_unit%) > 0) Then
        ReadXReturnX4 2
        initial_pressure = x5
        If (m_bBPCreateLogFile) Then
            Print #fnLog, Xformat$(Timer - tstart, "###0.00") + "   " + Xformat$(x5 - p_atm, "##0.000")
        End If

    End If
    
    failed = False
    
    ' Set up graph
    If PH_autoscale Then
        newymax = initial_pressure - p_atm + 2 * HRate
        newymin = initial_pressure - p_atm - 2 * HRate
    Else
        newymax = PH_maxY
        newymin = PH_minY
    End If
    
    progress.Picture1.Scale (0, newymax)-(Hold_Time(current_unit%), newymin)
    
    ' Draw max and min lines around test pressure
    'If PH_autoscale Then
    '    progress.Picture1.Line (0, 0.75 * (newymax - newymin) + newymin)-(Hold_Time(current_unit%), 0.75 * (newymax - newymin) + newymin), RGB(255, 0, 0)
    '    progress.Picture1.Line (0, 0.25 * (newymax - newymin) + newymin)-(Hold_Time(current_unit%), 0.25 * (newymax - newymin) + newymin), RGB(255, 0, 0)
    'End If
    
    ' Format scale markers
    If newymax > 100 Then
        progress.Y_Max.Caption = Format$(newymax, "######0")
    Else        'format changed from ##0.#### to ##0    edc 04-3-07
        progress.Y_Max.Caption = Format$(newymax, "##0")
    End If
    If newymin > 100 Then
        progress.Y_Zero.Caption = Format$(newymin, "######0")
    Else    'format changed from ##0.#### to ##0    edc 04-30-07
        progress.Y_Zero.Caption = Format$(newymin, "##0")
    End If

    plast = initial_pressure - p_atm
    If num_PH_AvePoints < 1 Then num_PH_AvePoints = 1


    
    first_reading = -1
    array_limit = 100
    ReDim data_array(2, array_limit)
    numdatapoints = 1
    data_array(1, numdatapoints) = plast
    data_array(2, numdatapoints) = 0
    numseconds = 0
    tlast = Timer
    
    ' Loop the test
    While (numseconds <= Hold_Time(current_unit%)) And (HKey$ <> "A") And (Not Aborted)
        
        ' PH_reading_freq is the sampling rate
        'While Timer - T < PH_reading_freq: DoEvents: Wend
        waitseconds PH_reading_freq
        
        DoEvents

        ' Read in new pressures and time and average them together
        tempReadings = 0
        For i = 1 To num_PH_AvePoints
            ReadXReturnX4 2
            If (m_bBPCreateLogFile) Then
                Print #fnLog, Xformat$(Timer - tlast, "###0.00") + "   " + Xformat$(x5 - p_atm, "##0.000")
            End If

            tempReadings = tempReadings + (x5 - p_atm)
        Next i
        b_pres = tempReadings / num_PH_AvePoints
        ' Figure out the differential time, compensate for any midnight crossover, and add to the total time
        time_added = Timer - tlast
        If time_added < 0 Then time_added = time_added + 86400
        numseconds = numseconds + time_added
        b_time = numseconds
        If first_reading = -1 Then first_reading = b_pres
        
        tlast = Timer

        ' Display new pressure and time
        progress.Line25.Caption = ts$(229) + ": " + Xformat$(b_pres * PCNV, "###0.000  ") + PU$ + "  " + ts$(74) + ": " + Format$(b_time, "#####0.00 ") + ts$(245) ' "Pressure"/"Time"/"sec."
        progress.Line25.Refresh
  
        ' Save the readings to disk
        Print #fn, str$(b_pres); ","; str$(b_time)
 
        numdatapoints = numdatapoints + 1
        
        ' Check the array dimensions
        If numdatapoints + 1 >= array_limit Then
            array_limit = array_limit + 100
            ReDim Preserve data_array(2, array_limit)
        End If
        
        ' Copy the points into the array
        data_array(1, numdatapoints) = b_pres
        data_array(2, numdatapoints) = b_time
        
        ' Set new y-scale values and update the scale of the graph, if using autoscale
        ' We don't want to scale out if we are checking absolute pressure
        If PH_autoscale And PH_fail_method$ = "dpdt" Then
        '============ CODE ALTERATIONS EDC 04-26-07 ================================================================
        'the two removed lines of code caused the y axis to grow uncontrolably in both the positive and negative
        'directions the now code will limit change to when the pressure drops below a certain point.
           'newymin = (b_pres) - 2 * HRate * b_time
           'newymax = (b_pres) + 2 * HRate * b_time
           If numdatapoints = 1 Then
                newymax = Int((b_pres) + 5)
                If (b_pres - 5) >= 0 Then
                    newymin = Int((b_pres) - 5)
                Else
                    newymin = 0
                End If
            Else
                If newymin > (b_pres) - 2 Then
                    newymin = Int(newymin - 2)
                End If
            End If
       '============= End Code Alterations  edc 04-26-07============================================================
            If newymax > 100 Then
                progress.Y_Max.Caption = Format$(newymax, "#######0")
            Else    'format changed from ##0.#### to ##0
                progress.Y_Max.Caption = Format$(newymax, "##0")
            End If
            If newymin > 100 Then
                progress.Y_Zero.Caption = Format$(newymin, "#######0")
            Else    'format changed from ##0.#### to ##0.0
                progress.Y_Zero.Caption = Format$(newymin, "##0")
            End If
        End If
        
        progress.Picture1.Scale (0, newymax)-(Hold_Time(current_unit%), newymin)

        ' Redraw the graph (this produces an interesting "smoothing" effect if doing autoscale!)
        'progress.Picture1.Line (tlast, plast)-(b_time, b_pres), RGB(255, 0, 255)
        progress.Picture1.Cls
        For i = 2 To numdatapoints
            progress.Picture1.Line (data_array(2, i - 1), data_array(1, i - 1))-(data_array(2, i), data_array(1, i)), RGB(255, 0, 255)
        Next i
        progress.Picture1.Refresh
        
        ' Store current readings as "last point" readings
        plast = b_pres
        'tlast = b_time

        ' Check pass/fail condition
       ' fail_check = (initial_pressure - p_atm) - b_pres
       ' If PH_fail_method = "dpdt" Then fail_check = fail_check / b_time
       ' If fail_check > HRate Then
       '     failed = True
       '     If PH_stopOnFail Then
       '         Aborted = True
       '     End If
       ' End If

    Wend  ' Main test loop
    
    
    '''''''''''''''''''''''''''''''''''''''''''''''''
    'august 30 2012
    ' Sam Bouabane & Sean Vesley
    ' made a msgbox that states if the test is failed if
    If data_array(1, 2) < startThresholdMin Then
        MsgBox ("Test failed! Start pressure " + str$(data_array(1, 2)) + " Is lower than " + str$(startThresholdMin) + ".")
    ElseIf data_array(1, 2) > startThresholdMax Then
        MsgBox ("Test failed! Start pressure " + str$(data_array(1, 2)) + " Is higher than " + str$(startThresholdMax) + ".")
    Else
        MsgBox ("Test Passed! Start pressure " + str$(data_array(1, 2)) + " is withing given parameters!")
    End If
    '''''''''''''''''''''''''''''''''''''''''''''''''
    
    Move_Valve 2, "O"
    Zero_Reg
    If ExtraPG Then
        Move_Valve 10, "O"
        Pres% = 2
    End If
    ' 6.71.33 leave the venting valve open
    'Move_Valve 2, "C"

    ' Calculate pass/fail options and print them out
    addendum$ = ""
    failed = False
    'if not using regression, the pressure difference is simply the difference
    ' between the first and last pressures; otherwise, it is the slope of the
    ' pressure curve multiplied by the test time (in seconds)
    If PH_regression Then
        stat_array.count = numdatapoints
        dim_xy_data stat_array                  ' set up the xy_data array
        For i = 1 To numdatapoints
            With stat_array
                .X(i) = data_array(2, i)        ' time
                .Y(i) = data_array(1, i)        ' pressure
            End With
        Next i
        result = linear_fit(stat_array)
        If Not result.error Then
            finalfail = Abs(result.slope * b_time) * PCNV
        Else
            ' SHOULD PUT ERROR MESSAGE HERE
        End If
    Else
        finalfail = (initial_pressure - p_atm - b_pres) * PCNV
    End If
    
    If volume <> -1 Then                    ' We have chamber volume, so we can figure out cc/sec
         CCs = finalfail / (initial_pressure - p_atm) * volume  ' Standard volume leaked is P/Po*V
    End If
    
    temp1$ = "0": temp2$ = "0"
    If PH_fail_method$ = "dpdt" Then
        finalfail = finalfail / b_time      ' PSI/sec; HRate is currently in PSI/sec as well, regardless of setting
        If finalfail > HRate Then failed = True
        CCs = CCs / b_time
        temp1$ = "1"
        If pressHoldUnit = "M" Then
            finalfail = finalfail * 60      ' Reconvert back to pressure per minute
            CCs = CCs * 60
            addendum$ = "/min"
            temp2$ = "1"
            HRate = HRate * 60              ' Neede for writing to data file, below
        Else
            addendum$ = "/sec"
        End If
       ' If finalfail > HRate / b_time Then failed = True
    Else
        If finalfail > HRate Then failed = True
    End If
    
    ' also write to data file
    Print #fn, "0,0"
    Print #fn, str$(finalfail); ","; "-1"
    Print #fn, str$(HRate); ","; temp1$; ","; temp2$
    Print #fn, str$(CCs)                    ' Volume lost
    Close #fn
    If status_lights_enable Then setStatusLights 1
    
    If failed Then
        tempstring = ts$(247) + " " + Format$(finalfail, "###0.#####") + PU$ + addendum$
    Else
        tempstring = ts$(248) + " " + Format$(finalfail, "###0.#####") + PU$ + addendum$
    End If
    ' Tack on the volume information if appropriate
    If CCs <> -1 Then
        tempstring$ = tempstring$ + vbCrLf + "or " + Format$(CCs, "###0.#####") + " cc" + addendum$
    Else
       ' tempstring$ = tempstring$ + vbCrLf + "Volume loss could not be calculated because chamber volume is unknown."
    End If
    MsgBox (tempstring$)
    
    do_final_copy

End Sub

Sub process_CVtable()
    Dim fn As Integer
    Dim lohm_path As String
    
    On Error Resume Next
    'JF CONTINUE LOHM HERE
    fn = FreeFile
    'get the user's lohmtable
    lohm_path = gpps2(Curr_U$, "lohmpath", IFile$, "")
    If lohm_path = "" Then
        If current_unit% = 1 Then
            Open EXE_Path$ + "lohmtable.cal" For Input As #fn
        Else
            Open EXE_Path$ + "lohmtable" + Trim$(str$(current_unit%)) + ".cal" For Input As #fn
        End If
    Else
        If current_unit% = 1 Then
            Open lohm_path For Input As #fn
        Else
            If InStr(lohm_path, ".cal") > 0 Then
                lohm_path = Left(lohm_path, Len(lohm_path) - 4) + Trim$(str$(current_unit%)) + ".cal"
            Else
                lohm_path = lohm_path + Trim$(str$(current_unit%)) + ".cal"
            End If
            Open lohm_path For Input As #fn
        End If
    End If
    
    On Error GoTo 0
    ' High flow meter 4 (currently only used on the Corning machine)
    If FY2(2, 2) <> 0 Then
        process_CVtable_for_FM fn, 4
    End If
    
    ' High flow meter 3 (currently only used on the Corning machine)
    If FY2(2, 0) <> 0 Then
        process_CVtable_for_FM fn, 3
    End If
    
    ' High flow meter 2 (extra high flow meter)
    If FY2(1, 2) <> 0 Then
        process_CVtable_for_FM fn, 2
    End If
    
    ' High flow meter 1
    If FY2(1, 0) <> 0 Then
        process_CVtable_for_FM fn, 1
    End If
    
    Close #fn
    Screen.MousePointer = 0
    
End Sub

Sub process_CVtable_for_FM(ByRef fn As Integer, fm%)
    Dim n%, i%, a$, j%
    Dim lohm_path As String
    Dim retry_counter As Long

    retry_counter = 0
    bad_cv_correction = False
    cv_flag = False
    cv_warning_flag = False
    On Error GoTo bad_cvtable
    
    Input #fn, n%
    cv_table_size%(fm%) = Abs(n%)
    
    If ExtraPG And n% > 0 Then
        MsgBox ts$(249)         ' "You are using an older style lohm table.  You may get more accuracy if you re-run the lohm table calibration."
    End If
    
    
zero_lohm_table:
    ' if lohm table is zero size, create fake very low resistance table
    If n% = 0 Then
'        ReDim CV_flow!(3), intermediate_CV_Value!(1, 3)
        cv_table_size%(fm%) = 0 '3
        CV_flow!(fm%, i%) = 10000
        intermediate_CV_Value!(fm%, 0, i%) = 0.00001
        intermediate_CV_Value!(fm%, 1, i%) = 0.00001
'        CV_flow!(fm%, 1) = 10000
'        intermediate_CV_Value!(fm%, 0, 1) = 0.00001
'        intermediate_CV_Value!(fm%, 1, 1) = 0.00001
'        CV_flow!(fm%, 2) = 100000
'        intermediate_CV_Value!(fm%, 0, 2) = 0.00001
'        intermediate_CV_Value!(fm%, 1, 2) = 0.00001
'        CV_flow!(fm%, 3) = 1000000
'        intermediate_CV_Value!(fm%, 0, 3) = 0.00001
'        intermediate_CV_Value!(fm%, 1, 3) = 0.00001
    Else
'        ReDim CV_flow!(cv_table_size%), intermediate_CV_Value!(1, cv_table_size%)
        For i% = 1 To cv_table_size%(fm%)
            Input #fn, CV_flow!(fm%, i%), intermediate_CV_Value!(fm%, 0, i%)
            If n% < 0 Then
                Input #fn, intermediate_CV_Value!(fm%, 1, i%)
            Else
                intermediate_CV_Value!(fm%, 1, i%) = intermediate_CV_Value!(fm%, 0, i%)
            End If
            DoEvents
        Next i%
        'Close #fn
    End If
    
    Rem Find the index corresponding to the maximum CV value
    Rem not sure why this was changed, but it could be causing big problems !  Jeff Dixon Dec 2000
    For j% = 0 To 1
        First_Good_CV_Index%(j%) = 1
        Do While First_Good_CV_Index%(j%) < cv_table_size%(fm%)
            If intermediate_CV_Value!(fm%, j%, First_Good_CV_Index%(j%)) < 0.01 Then
                First_Good_CV_Index%(j%) = First_Good_CV_Index%(j%) + 1
            Else
                Exit Do
            End If
        Loop
    Next j%
    
done_cvtable:
    On Error GoTo 0
    Exit Sub
    
bad_cvtable:
    cv_table_size%(fm%) = 0
    n% = 0
    
    retry_counter = retry_counter + 1
    If retry_counter > 10000 Then
        MsgBox ("Error loading lohm calibration tables!")
        Exit Sub
    End If
    
    GoTo zero_lohm_table
End Sub

Sub Pulse_V2(Index As Integer)

    If nov2 Then Exit Sub

    'AJB 12-14-09
    If hasMultipleMVs Then
        If Index = 1 Then
            If motorValveIndex = 0 Then
                Send_RS232 ("D" + mv1_index_char)
                Debug.Print "Decrement MV1"
            ElseIf motorValveIndex = 1 Then
                Send_RS232 ("D" + mv2_index_char)
                Debug.Print "Decrement MV2"
            ElseIf motorValveIndex = 2 Then
                Send_RS232 ("D" + mv3_index_char)
                Debug.Print "Decrement MV3"
            End If
        Else
            If motorValveIndex = 0 Then
                Send_RS232 ("I" + mv1_index_char)
                Debug.Print "Increment MV1"
            ElseIf motorValveIndex = 1 Then
                Send_RS232 ("I" + mv2_index_char)
                Debug.Print "Increment MV2"
            ElseIf motorValveIndex = 2 Then
                Send_RS232 ("I" + mv3_index_char)
                Debug.Print "Increment MV3"
            End If
        End If
    Else
        If Index = 1 Then
            Send_RS232 ("D" + mv1_index_char) 'pulse closed
        Else
            Send_RS232 ("I" + mv1_index_char) 'pulse open
        End If
    End If

'if running humidity test, update bubbler mv position to reach target humidity
'If enableHumidityForAutoTests And RUNNING Then
'    goToTargetHumidity
'End If

End Sub

Sub Pulse_BubblerMV(direction As Integer)
    
    Dim numPulses As Integer
    Dim i As Integer
    
    ReadXReturnX4 1 'read current flow
    
    'set number of pulses based on current flow rate
'    If x5 > 100000 Then
'        numPulses = 15
'    ElseIf x5 > 80000 Then
'        numPulses = 13
'    ElseIf x5 > 60000 Then
'        numPulses = 11
'    ElseIf x5 > 40000 Then
'        numPulses = 9
'    ElseIf x5 > 20000 Then
'        numPulses = 7
'    ElseIf x5 > 10000 Then
'        numPulses = 5
'    ElseIf x5 > 5000 Then
'        numPulses = 3
'    Else
        numPulses = 1
'    End If
        
    If direction = 0 Then
        For i = 1 To numPulses
            Send_RS232 ("IS") 'pulse open
        Next i
    Else
        For i = 1 To numPulses
            Send_RS232 ("DS") 'pulse closed
        Next i
    End If
    
End Sub

Sub QuickSort(Low As Integer, High As Integer, da As pf_array)
    
    Dim RandIndex As Integer
    Dim Partision As Single
    Dim i%, j%
    
    If Low < High Then
        If High - Low = 1 Then
            If da.a(Low).pr > da.a(High).pr Then
                SWAP Low, High, da
            End If
        Else
            RandIndex = RandInt%(Low, High)
            SWAP High, RandIndex, da
            Partision = da.a(High).pr
            Do
                i% = Low: j% = High
                Do While (i% < j%) And (da.a(i%).pr <= Partision)
                    i% = i% + 1
                Loop
                Do While (j% > i%) And (da.a(j%).pr >= Partision)
                    j% = j% - 1
                Loop
                If i% < j% Then
                    SWAP i%, j%, da
                End If
            Loop While i% < j%
            SWAP i%, High, da
            If (i% - Low) < (High - i%) Then
                QuickSort Low, i% - 1, da
                QuickSort i% + 1, High, da
            Else
                QuickSort i% + 1, High, da
                QuickSort Low, i% - 1, da
            End If
        End If
    End If
    
End Sub

Static Function RandInt%(Lower As Integer, upper As Integer)
RandInt% = Int(Rnd * (upper - Lower + 1)) + Lower
End Function

Function raw_reading(X As Integer) As Long
    Dim p2value As Long
    Dim NEWX%
    
    On Error GoTo local_error
    tryhold

    If readAllFlows And X > 100 Then
        Select Case X
        Case 101: NEWX% = 10
        Case 102: NEWX% = 11
        Case 103: NEWX% = 4
        Case 104: NEWX% = 5
        Case 105: NEWX% = 42
        Case 106: NEWX% = 43
        Case 107: NEWX% = 44
        Case 108: NEWX% = 45
        End Select
    ElseIf X > 4 Then
        NEWX% = X
    ElseIf X = 3 Then
        If Not hasMultipleMVs Then
            NEWX% = 7
        Else
            If motorValveIndex = 0 Then
                NEWX% = 7
            ElseIf motorValveIndex = 1 Then
                NEWX% = 31
            ElseIf motorValveIndex = 2 Then
                NEWX% = 24
            End If
        End If
    ElseIf X = 4 Then
        If Second_Penetrometer And penetrometer_select = 2 Then
            NEWX% = 27
        Else
            NEWX% = 6
        End If
    ElseIf X = 2 Then
        If Pres% = 0 Then
            If Not manrunning And ExtraPG And Not way3 Then
                p2value = raw_reading(13)
                If p2value >= DAC_over Then
                    low_over_error p2value
                    Debug.Print "Pres% = 0 and Goto low_over_error"
                End If
            End If
            NEWX% = 1
        ElseIf Pres% = 1 Then
            If Not manrunning And ExtraPG And Not way3 Then
                p2value = raw_reading(13)
                If p2value >= DAC_over Then low_over_error p2value
            End If
            NEWX% = 0
        ElseIf Not ExtraPG Then
            MsgBox "Error - raw_reading called with Pres%=" + str$(Pres%)
        Else
            If Pres% = 2 Then
                NEWX% = 13    'highrange
            ElseIf Pres% = 3 Then
                NEWX% = 12    'lowrange
            Else
                MsgBox "Error - raw_reading called with Pres%=" + str$(Pres%)
            End If
        End If
        Debug.Print "X=2    Newx: " + str(NEWX%)
    ElseIf X = 1 Then
        If HFLOW% > 1 And Not xhflow Then
            MsgBox "Error - raw_reading called with hflow%=" + str$(HFLOW%)
        End If
        If version < 7 Then ' mapping was changed in version 7
            If HFLOW% = 0 Then
                NEWX% = 5
            ElseIf HFLOW% = 1 Then
                NEWX% = 4
            ElseIf HFLOW% = 2 Then
                NEWX% = 11
            ElseIf HFLOW% = 3 Then
                NEWX% = 10
            Else
                MsgBox "Error - raw_reading called with hflow%=" + str$(HFLOW%)
            End If
        Else
            If HFLOW% = 0 Then
                If motorValveIndex >= 1 Then
                    NEWX% = 43 'AJB 12-16-09
                Else
                    NEWX% = 11 'high range medium flow meter
                End If
            ElseIf HFLOW% = 1 Then
                If motorValveIndex >= 1 Then
                    NEWX% = 42 'AJB 12-16-09
                Else
                    NEWX% = 10 'low range medium flow meter
                End If
            ElseIf HFLOW% = 2 Then
                If motorValveIndex >= 1 Then
                    NEWX% = 45 'AJB 12-16-09
                Else
                    NEWX% = 5 'high range high flow meter
                End If
            ElseIf HFLOW% = 3 Then
                If motorValveIndex >= 1 Then
                    NEWX% = 44 'AJB 12-16-09
                Else
                    NEWX% = 4 'low range high flow meter
                End If
            ElseIf HFLOW% = 4 Then
                NEWX% = 9
            ElseIf HFLOW% = 5 Then
                NEWX% = 8
            Else
                MsgBox "Error - raw_reading called with hflow%=" + str$(HFLOW%)
            End If
            
            Debug.Print "Newx: " + str(NEWX%)
        End If
    ElseIf X = 0 Then
        If GasPerm Then
            ' no low flow meter on a Gas Permeameter
            raw_reading = DAC_zero
            Exit Function
        End If
        If lflow% = 0 Then
            NEWX% = 3
        ElseIf lflow% = 1 And integrity And (version >= 7 Or autocompress = False) Then
            NEWX% = 9
        ElseIf lflow% = 1 Then
            NEWX% = 2
        Else
            MsgBox "Error - raw_reading called with lflow%=" + str$(lflow%)
        End If
    End If

    'raw_reading = RSEcho("R" + Chr$(Asc("A") + NEWX%), ver2or3)
    ' If we are remapping gauge readings, use the remapped value - Mix
    If UseRemap And NEWX% >= LBound(GaugeRemap) And NEWX% <= UBound(GaugeRemap) Then
        ' Read counts
        raw_reading = RSEcho("R" + Chr$(Asc("A") + GaugeRemap(NEWX%)), ver2or3)
        ' Specifiy which ReadingMath will be used to calculate x5 later (if any)
        ActiveReadMath = ReadingMaths(GaugeRemap(NEWX%))
    Else
        ' Read counts
        raw_reading = RSEcho("R" + Chr$(Asc("A") + NEWX%), ver2or3)
        ' Specifiy which ReadingMath will be used to calculate x5 later (if any)
        ActiveReadMath = ReadingMaths(NEWX%)
    End If
    
    If NEWX% = 0 Or NEWX% = 1 Then
        NEWX% = NEWX%
    End If
    
    Exit Function
    
local_error:
    log_append "error number " + str$(Err.Number) + " in raw_reading called with " + str$(X)
    Resume local_return
local_return:
    raw_reading = 100
    
End Function

'Sub PrepareHumidity()
'
'    Dim currentHumidity As Single
'
'    If enableHumidityForAutoTests Then
'
'        If Math.Abs(readHumiditySensor - targetHumidity) <= goToHumidityTolerance Then Exit Sub
'
'        status.Show
'        status.Label1.Caption = "Waiting for humidity:"
'        status.Label2.Caption = "Target Humidity: " & targetHumidity & "     Current Humidity: " & readHumiditySensor
'        status.Command1.Caption = "Skip"
'        status.Command1.Enabled = False
'
'        Move_Valve 3, "C" 'set bubbler enable
'        Move_Valve 2, "O" 'open vent valve (hardware valve 3)
'
''        Send_RS232 "CS" 'close bubbler mv
''        While RSEcho("VS", 1) <> Asc("S") 'wait for valve to fully close
''            status.Label1.Caption = "Closing Bubbler MV:"
''            status.Label2.Caption = "Target Humidity: " & targetHumidity & "     Current Humidity: " & readHumiditySensor
''            DoEvents
''        Wend
'
'        ' flow some air through the system to reach target starting humidity
'        Send_RS232 "OB" 'open mv 2
'        While RSEcho("VB", 1) <> Asc("S") 'wait for valve to fully open
'            status.Label1.Caption = "Opening MV2:"
'            status.Label2.Caption = "Target Humidity: " & targetHumidity & "     Current Humidity: " & readHumiditySensor
'            DoEvents
'        Wend
'
'        inc_reg 400 'create some flow
'
'        status.Command1.Enabled = True 'let user skip
'        status.Refresh
'
'        goToTargetHumidity
'
''        Dim startTime As Single
''        startTime = Timer
''
''        'overshoot target humidity
''        While readHumiditySensor < targetHumidity And status.Command1.Enabled And Timer - startTime <= initialHumidityWaitTime
''            status.Label1.Caption = "Increasing humidity:"
''            status.Label2.Caption = "Target Humidity: " & targetHumidity & "     Current Humidity: " & readHumiditySensor
''            DoEvents
''        Wend
''
''        startTime = Timer
''        'pulse open bubbler mv to get come back down to target humidity
''        While readHumiditySensor > targetHumidity And status.Command1.Enabled And Timer - startTime <= initialHumidityWaitTime
''            Pulse_BubblerMV 0 'pulse open
''            status.Label1.Caption = "Waiting for humidity:"
''            status.Label2.Caption = "Target Humidity: " & targetHumidity & "     Current Humidity: " & readHumiditySensor
''            waitForStableHumidity
''            status.Label1.Caption = "Waiting for humidity:"
''            status.Label2.Caption = "Target Humidity: " & targetHumidity & "     Current Humidity: " & readHumiditySensor
''        Wend
'
'        'try to trap this humidity in the system
'        zeroRegVentTime = 5000 'temporarily set vent time to 5 seconds so we don't have to wait as long
'        Zero_Reg
'        zeroRegVentTime = 30000 'change back to 30 seconds
'
'        Move_Valve 3, "C" 'set bubbler enable again, it should have been disabled by Zero_Reg
'
'        'close bubbler mv
''        Send_RS232 "CS"
''        While RSEcho("VS", 1) <> Asc("S") 'wait for valve to fully close
''            status.Label1.Caption = "Waiting for humidity:"
''            status.Label2.Caption = "Target Humidity: " & targetHumidity & "     Current Humidity: " & readHumiditySensor
''            DoEvents
''        Wend
'
'        'close mv2
'        Send_RS232 "CB" 'close mv 2
'        While RSEcho("VB", 1) <> Asc("S") 'wait for valve to fully close
'            status.Label1.Caption = "Closing MV2:"
'            status.Label2.Caption = "Target Humidity: " & targetHumidity & "     Current Humidity: " & readHumiditySensor
'            DoEvents
'        Wend
'
'        status.Hide
'
''        currentHumidity = readHumiditySensor
'
''        If targetHumidity >= currentHumidity Then
'            'set start position of bubbler mv to fully opened
''            Send_RS232 "OS"
''            While RSEcho("VS", 1) <> Asc("S") 'wait for valve to fully open
''                DoEvents
''            Wend
''
''            'also close mv2
''            Send_RS232 "CB"
''            While RSEcho("VB", 1) <> Asc("S") 'wait for valve to fully close
''                DoEvents
''            Wend
'
''        Else
''            'set start position of bubbler mv to fully opened
''            Send_RS232 "OS"
''            While RSEcho("VS", 1) <> Asc("S") 'wait for valve to fully open
''                DoEvents
''            Wend
''        End If
'
'
'    Else
'        Move_Valve 3, "O" 'set bubbler enable valve to close off path to bubbler
'        Send_RS232 "CS" 'close bubbler mv
'        While RSEcho("VS", 1) <> Asc("S") 'wait for valve to fully close
'            DoEvents
'        Wend
'    End If
'
'End Sub

Function getMV2Position() As Single

    ReadXReturnX4 3 'read position

    If oLimit = cLimit Then
        x5 = 0.5
    Else
        x5 = (x4 - cLimit) / (oLimit - cLimit)
    End If

    getMV2Position = x5

End Function

Function getBubblerMVPosition() As Single
    
    ReadXReturnX4 32
    bubblerMV_CLIMIT = x4
    
    ReadXReturnX4 33
    bubblerMV_OLIMIT = x4
    
    ReadXReturnX4 31
    
    x5 = (x4 - bubblerMV_CLIMIT) / (bubblerMV_OLIMIT - bubblerMV_CLIMIT)
    getBubblerMVPosition = x5

End Function


'Try to maintain the target humidity, exit when a given amount of time is elapsed or the humidity is stable
'and close enough to the target value
Sub goToTargetHumidity()

    Dim tolerance As Single
    Dim startTime As Long
    Dim elapsedTime As Long
    Dim timeout As Single
    Dim minTime As Integer
    Dim h1 As Single
    Dim h2 As Single
    
    If Not afterBubblePoint Then Exit Sub
    
    If minHumidityAdjustmentFlow > 0 Then
        If progress.Visible = False Then Exit Sub
        ReadXReturnX4 1 'read current flow
        If x5 < minHumidityAdjustmentFlow Then Exit Sub
    End If
    
    timeout = goToHumidityMaxWaitTime 'seconds
    minTime = goToHumidityMinWaitTime 'seconds
    tolerance = goToHumidityTolerance 'percent
    
    startTime = Timer
    elapsedTime = 0
    
    lastGoodHumidity = readHumiditySensor

    While ((Abs(targetHumidity - lastGoodHumidity) > tolerance And elapsedTime < timeout And elapsedTime >= 0) Or elapsedTime < minTime) And Not Aborted

        'lastGoodHumidity = readHumiditySensor
        updateHumidityDisplay

        If targetHumidity > lastGoodHumidity + tolerance Then
            'valve needs to be closed if it isn't completely closed
            ReadXReturnX4 32 'read close limit
            bubblerMV_CLIMIT = x4
            ReadXReturnX4 31 'read position

            If x4 > bubblerMV_CLIMIT Then
                progress.Line26.BackColor = vbWhite
                
                'pulse bubbler mv closed
                Pulse_BubblerMV 1
            Else
                progress.Line26.BackColor = vbRed
                h1 = readHumiditySensor
                Waitms 2000, True
                h2 = readHumiditySensor
                If Math.Abs(h1 - h2) < 1 Then Exit Sub
            End If
            
            waitForStableHumidity
            updateHumidityDisplay
        ElseIf targetHumidity < lastGoodHumidity - tolerance Then
            'valve needs to be opened if it isn't fully open
            ReadXReturnX4 33 'read open limit
            bubblerMV_OLIMIT = x4
            ReadXReturnX4 31 'read position

            If x4 < bubblerMV_OLIMIT Then
                progress.Line26.BackColor = vbWhite
                
                'pulse bubbler mv open
                Pulse_BubblerMV 0
            Else
                progress.Line26.BackColor = vbGreen
                h1 = readHumiditySensor
                Waitms 2000, True
                h2 = readHumiditySensor
                If Math.Abs(h1 - h2) < 1 Then Exit Sub
            End If
            
            waitForStableHumidity
            updateHumidityDisplay
        End If
'
'        If initial = True Then
'            If status.Command1.Enabled = False Then Exit Sub
'        End If

        'waitForStableHumidity initial
        
        'Waitms 2000, False
        elapsedTime = Timer - startTime
        
        'lastGoodHumidity = readHumiditySensor
    Wend

    goToHumidityWaitTimeCounter = Timer - startTime
    goToHumidityCounter = goToHumidityCounter + 1

End Sub

Sub updateHumidityDisplay()
    lastGoodHumidity = readHumiditySensor
    progress.Line26.Caption = "Bubbler MV Position:  " & Format$(getBubblerMVPosition(), "##0.00%") & ", Current Humidity:  " & lastGoodHumidity & " %"
End Sub


'Sub goToTargetHumidity()
'
'    Dim mvPos As Long
'
'    'read current flow
'    ReadXReturnX4 1
'
'    mvPos = getBubblerMVPosition(targetHumidity, x5)
'
'    Send_RS232l "GS", mvPos
'
'    While RSEcho("VS", 1) <> Asc("S") 'wait for bubbler mv to stop moving
'        DoEvents
'    Wend
'
'    waitForStableHumidity
'
'End Sub

Sub PrepareTemperatures()
    Dim temperaturesSet As Boolean
    Dim temperaturesNotOK As Integer
    Dim dryTemp As Single
    Dim wetTemp As Single
    Dim resTemp As Single
    Dim airTemp As Single
    Dim bubTemp As Single
    Dim cabTemp As Single
    Dim hhTemp As Single
    Dim mulTemp As Single
    Dim statusStr As String
    
    If dryChamberTemperature <> 0 And setTemperatureForAuto(current_unit%, 0) Then
        setNewTemperature dryChamberTemperature, dryChamberTargetTemperature(current_unit%)
    End If
    If wetChamberTemperature <> 0 And setTemperatureForAuto(current_unit%, 1) Then
        setNewTemperature wetChamberTemperature, wetChamberTargetTemperature(current_unit%)
    End If
    If reservoirTemperature <> 0 And setTemperatureForAuto(current_unit%, 2) Then
        setNewTemperature reservoirTemperature, reservoirTargetTemperature(current_unit%)
    End If
    If airTemperature <> 0 And setTemperatureForAuto(current_unit%, 3) Then
        setNewTemperature airTemperature, airTargetTemperature(current_unit%)
    End If
    If bubblerTemperature <> 0 And setTemperatureForAuto(current_unit%, 4) Then
        setNewTemperature bubblerTemperature, bubblerTargetTemperature(current_unit%)
    End If
    If cabinetTemperature <> 0 And setTemperatureForAuto(current_unit%, 5) Then
        setNewTemperature cabinetTemperature, cabinetTargetTemperature(current_unit%)
    End If
    If hydroHeadTemperature <> 0 And setTemperatureForAuto(current_unit%, 6) Then
        setNewTemperature hydroHeadTemperature, hydroHeadTargetTemperature(current_unit%)
    End If
    If mullenTemperature <> 0 And setTemperatureForAuto(current_unit%, 7) Then
        setNewTemperature mullenTemperature, mullenTargetTemperature(current_unit%)
    End If
    
    If delayTestForTemperature(current_unit%, 0) Or delayTestForTemperature(current_unit%, 1) Or _
       delayTestForTemperature(current_unit%, 2) Or delayTestForTemperature(current_unit%, 3) Or _
       delayTestForTemperature(current_unit%, 4) Or delayTestForTemperature(current_unit%, 5) Or _
       delayTestForTemperature(current_unit%, 6) Or delayTestForTemperature(current_unit%, 7) Then
        Status.Show
        temperaturesSet = False
        While Not temperaturesSet
            temperaturesNotOK = 0
            statusStr = ""
            If dryChamberTemperature <> 0 And delayTestForTemperature(current_unit%, 0) Then
                dryTemp = readNewTemperature(dryChamberTemperature)
                If Abs(dryChamberTargetTemperature(current_unit%) - dryTemp) > 0.1 Then
                    temperaturesNotOK = temperaturesNotOK + 1
                    statusStr = statusStr + "Dry Chamber(" & dryTemp & "), "
                End If
            End If
            
            If wetChamberTemperature <> 0 And delayTestForTemperature(current_unit%, 1) Then
                wetTemp = readNewTemperature(wetChamberTemperature)
                If Abs(wetChamberTargetTemperature(current_unit%) - wetTemp) > 0.1 Then
                    temperaturesNotOK = temperaturesNotOK + 1
                    statusStr = statusStr + "Wet Chamber(" & wetTemp & "), "
                End If
            End If
            
            If reservoirTemperature <> 0 And delayTestForTemperature(current_unit%, 2) Then
                resTemp = readNewTemperature(reservoirTemperature)
                If Abs(reservoirTargetTemperature(current_unit%) - resTemp) > 0.1 Then
                    temperaturesNotOK = temperaturesNotOK + 1
                    statusStr = statusStr + "Reservoir(" & resTemp & "), "
                End If
            End If
            
            If airTemperature <> 0 And delayTestForTemperature(current_unit%, 3) Then
                airTemp = readNewTemperature(airTemperature)
                If Abs(airTargetTemperature(current_unit%) - airTemp) > 0.1 Then
                    temperaturesNotOK = temperaturesNotOK + 1
                    statusStr = statusStr + "Air(" & airTemp & "), "
                End If
            End If
            
            If bubblerTemperature <> 0 And delayTestForTemperature(current_unit%, 4) Then
                bubTemp = readNewTemperature(bubblerTemperature)
                If Abs(bubblerTargetTemperature(current_unit%) - bubTemp) > 0.1 Then
                    temperaturesNotOK = temperaturesNotOK + 1
                    statusStr = statusStr + "Bubbler(" & bubTemp & "), "
                End If
            End If
            
            If cabinetTemperature <> 0 And delayTestForTemperature(current_unit%, 5) Then
                cabTemp = readNewTemperature(cabinetTemperature)
                If Abs(cabinetTargetTemperature(current_unit%) - cabTemp) > 0.1 Then
                    temperaturesNotOK = temperaturesNotOK + 1
                    statusStr = statusStr + "Cabinet(" & cabTemp & "), "
                End If
            End If
            
            If hydroHeadTemperature <> 0 And delayTestForTemperature(current_unit%, 6) Then
                hhTemp = readNewTemperature(hydroHeadTemperature)
                If Abs(hydroHeadTargetTemperature(current_unit%) - cabTemp) > 0.1 Then
                    temperaturesNotOK = temperaturesNotOK + 1
                    If burst Then
                        statusStr = statusStr + "Burst(" & hhTemp & "), "
                    Else
                        statusStr = statusStr + "Hydro Head(" & hhTemp & "), "
                    End If
                End If
            End If
            
            If mullenTemperature <> 0 And delayTestForTemperature(current_unit%, 7) Then
                mulTemp = readNewTemperature(mullenTemperature)
                If Abs(mullenTargetTemperature(current_unit%) - cabTemp) > 0.1 Then
                    temperaturesNotOK = temperaturesNotOK + 1
                    statusStr = statusStr + "Mullen(" & mulTemp & "), "
                End If
            End If
            
            If temperaturesNotOK > 0 Then
                statusStr = Left(statusStr, Len(statusStr) - 2)
                Status.Label1.Caption = "Waiting for following temperatures:"
                Status.Label2.Caption = statusStr
                'Sleep 1000
                DoEvents
            Else
                temperaturesSet = True
            End If
            
            'Check to see if the user aborted
            If Not Status.Command1.Enabled Then temperaturesSet = True
        Wend
        Unload Status
    End If
End Sub

Sub read_temperature(i As Long, wet As Boolean)

    If i > temperature_array_size Then
        temperature_array_size = i + 10
        ReDim Preserve temperature1(temperature_array_size)
        ' now always redim number 2 because new porometry test can
        ' also read the dry temperature and needs the second array to
        ' store the temperature from the second pass.  This would break
        ' on systems with a dry temperature but no reservoir temperature
        ' no harm to redim number 2 even if we are running dry
        'If reservoirTemperature <> 0 Then
            ReDim Preserve temperature2(temperature_array_size)
        'End If
    End If
        
    If wet Then
        temperature1(i) = readNewTemperature(wetChamberTemperature)
        If reservoirTemperature <> 0 Then
            temperature2(i) = readNewTemperature(reservoirTemperature)
        End If
    Else
        temperature1(i) = readNewTemperature(dryChamberTemperature)
    End If
    'If using_watlow Then
    '    temperature1(i) = read_external_watlow
    'Else
    '    ReadXReturnX4 27
    '    temperature1(i) = convert_to_c(x5, tsunit$)
    '    If temperature% > 1 Then
    '        ReadXReturnX4 30
    '        temperature2(i) = convert_to_c(x5, tsunit$)
    '    End If
    'End If
  
End Sub

Sub read_two_temperatures(i As Long)
    
    If i > temperature_array_size Then
        temperature_array_size = i + 10
        ReDim Preserve temperature1(temperature_array_size)
        ' now always redim number 2 because new porometry test can
        ' also read the dry temperature and needs the second array to
        ' store the temperature from the second pass.  This would break
        ' on systems with a dry temperature but no reservoir temperature
        ' no harm to redim number 2 even if we are running dry
        'If reservoirTemperature <> 0 Then
            ReDim Preserve temperature2(temperature_array_size)
        'End If
    End If
    
    temperature1(i) = readNewTemperature(dryChamberTemperature)
    temperature2(i) = readNewTemperature(airTemperature)

End Sub


Function readNewTemperature(i As Integer, Optional convert2c As Boolean = True) As Single
' set convert2c as false when calling if you want the raw value, not converted to C
' this would only be for display purposes
If i = 0 Or i > 8 Then
    ' this shouldn't happen
    readNewTemperature = 0
ElseIf i = 1 Or i = 2 Then
    ReadXReturnX4 24 + (i * 3) ' 27 or 30
    If convert2c Then
        readNewTemperature = convert_to_c(x5, tsunit$)
    Else
        readNewTemperature = x5
    End If
ElseIf i >= 3 Then
    ' read rabbit board
    readNewTemperature = read_rabbit_watlow(i - 3) ' call with 0, 1, 2, 3, 4, 5
Else
    ' read aux com port (A if i=-1, -3, -5, -7, etc., B if i=-2, -4, -6, -8, etc.
    ' the aux com port is already set to the proper port, but it may not be open
    readNewTemperature = read_external_watlow((i And 1) + 1)
End If
End Function

Function readHumiditySensor() As Single
    ReadXReturnX4 humidityGaugeNumber
    
    readHumiditySensor = Format$(((x4 - humiditySensorZeroCounts) / (humiditySensorFullCounts - humiditySensorZeroCounts)) * 100, "##0.00")
End Function

Function readReserveTankLevel() As Single
    Dim readValue As Long
    Dim retValue As Single
    Dim channel As Integer
    'This function will read the reserve tank level in counts from
    'the channel specified in the ini file for ReserveTankLevelChannel
    'and return the value in units.
    
    ' Remap the channel as needed
    If UseRemap And ReserveTankLevelChannel >= LBound(GaugeRemap) And ReserveTankLevelChannel <= UBound(GaugeRemap) Then
        channel = GaugeRemap(ReserveTankLevelChannel)
    Else
        channel = ReserveTankLevelChannel
    End If
    
    ' Get the counts
    readValue = RSEcho("R" + Chr$(Asc("A") + channel), ver2or3)
    
    'retValue = (readValue - ReserveTankLevelZero) * 100# / (ReserveTankLevelSpan - ReserveTankLevelZero)
    ' Math the value as requested
    If ReadingMaths(channel).OverrideActive Then
        retValue = CountsToReadingByRM(readValue, ReadingMaths(channel))
    Else
        retValue = (readValue - ReserveTankLevelZero) * 100# / (ReserveTankLevelSpan - ReserveTankLevelZero)
    End If
    readReserveTankLevel = retValue
End Function

Function readChamberLiquidLevel(Index As Integer) As Single
    Dim readValue As Long
    Dim retValue As Single
    Dim channel As Integer
    
    ' Remap the channel as needed
    If UseRemap And ChamberLiquidLevelChannel(Index) >= LBound(GaugeRemap) And ChamberLiquidLevelChannel(Index) <= UBound(GaugeRemap) Then
        channel = GaugeRemap(ChamberLiquidLevelChannel(Index))
    Else
        channel = ChamberLiquidLevelChannel(Index)
    End If
    
    ' Get the counts
    readValue = RSEcho("R" + Chr$(Asc("A") + channel), ver2or3)
    
    'retValue = (readValue - ChamberLiquidLevelZero(Index)) * 100# / (ChamberLiquidLevelSpan(Index) - ChamberLiquidLevelZero(Index))
    ' Math the value as requested
    If ReadingMaths(channel).OverrideActive Then
        retValue = CountsToReadingByRM(readValue, ReadingMaths(channel))
    Else
        retValue = (readValue - ChamberLiquidLevelZero(Index)) * 100# / (ChamberLiquidLevelSpan(Index) - ChamberLiquidLevelZero(Index))
    End If
    readChamberLiquidLevel = retValue
End Function

Sub ReadXReturnX4(X As Integer)
    Dim temp_x4 As Long
    Dim Temp_X5 As Single
    Dim old_pres%, new_pres%
    Dim k As Single
    Dim fn As Integer
    Dim LowX4 As Long
    Dim LowX5 As Single
    Dim targetX4 As Long
    Dim x4Diff As Long
    Dim adjMVIndex As Integer
    Dim alreadyPaused As Integer
    alreadyPaused = 0
'    If X = 2 And FrazierRunning And (Not manrunning) Then follows inserted code
' **********
' Begin balance and not penetrometer code entered by Tim Richards 04 05 14
'
'   After reading the balance, exit the routine without hitting the other code.
'
    If g_bBalanceNotPenet And X = 4 Then
    
        ReadBalanceNotPenet x4, x5
        Exit Sub
    
    End If
'
' End code entered by Tim Richards 04 05 14
' **********
    
    ' Code entered by JF 1-13-2010
    ' This code is so that manual control can read all 4 flow values at the same time for Corning
'    If X = 100 Then
    If X = 100 Or X = 101 Then
        x4 = raw_reading(101)
        x5 = (x4 - FX1(1, 1)) / (FX2(1, 1) - FX1(1, 1)) * (FY2(1, 1) * gasflowconversionfactor - FY1(1, 1)) + FY1(1, 1)
        If hasMultipleMVs Then
            ManualControl1.lowFlowRate1.Caption = ts$(307) + " 1 " + ts$(305) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "#####0.000 \c\c")  ' "/"Counts"/"\c\c"
        Else
            ManualControl.lowFlowRate1.Caption = ts$(307) + " 1 " + ts$(305) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "#####0.000 \c\c")  ' "/"Counts"/"\c\c"
        End If
    End If
    
    If X = 100 Or X = 102 Then
        x4 = raw_reading(102)
        x5 = (x4 - FX1(1, 0)) / (FX2(1, 0) - FX1(1, 0)) * (FY2(1, 0) * gasflowconversionfactor - FY1(1, 0)) + FY1(1, 0)
        If hasMultipleMVs Then
            ManualControl1.highFlowRate1.Caption = ts$(308) + " 1 " + ts$(305) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "######.000 \c\c")   ' "High Flow Rate (High): "/"Counts"/"\c\c"
        Else
            ManualControl.highFlowRate1.Caption = ts$(308) + " 1 " + ts$(305) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "######.000 \c\c")   ' "High Flow Rate (High): "/"Counts"/"\c\c"
        End If
    End If
    
    If X = 100 Or X = 103 Then
        x4 = raw_reading(103)
        x5 = (x4 - FX1(1, 3)) / (FX2(1, 3) - FX1(1, 3)) * (FY2(1, 3) * gasflowconversionfactor - FY1(1, 3)) + FY1(1, 3)
        If hasMultipleMVs Then
            ManualControl1.lowFlowRate2.Caption = ts$(307) + " 2 " + ts$(305) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "#####0.000 \c\c")  ' "/"Counts"/"\c\c"
        Else
            ManualControl.lowFlowRate2.Caption = ts$(307) + " 2 " + ts$(305) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "#####0.000 \c\c")  ' "/"Counts"/"\c\c"
        End If
    End If
    
    If X = 100 Or X = 104 Then
        x4 = raw_reading(104)
        x5 = (x4 - FX1(1, 2)) / (FX2(1, 2) - FX1(1, 2)) * (FY2(1, 2) * gasflowconversionfactor - FY1(1, 2)) + FY1(1, 2)
        If hasMultipleMVs Then
            ManualControl1.highFlowRate2.Caption = ts$(308) + " 2 " + ts$(305) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "######.000 \c\c")   ' "High Flow Rate (High): "/"Counts"/"\c\c"
        Else
            ManualControl.highFlowRate2.Caption = ts$(308) + " 2 " + ts$(305) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "######.000 \c\c")   ' "High Flow Rate (High): "/"Counts"/"\c\c"
        End If
    End If
    
    If X = 100 Or X = 105 Then
        x4 = raw_reading(105)
        x5 = (x4 - FX1(2, 1)) / (FX2(2, 1) - FX1(2, 1)) * (FY2(2, 1) * gasflowconversionfactor - FY1(2, 1)) + FY1(2, 1)
        If hasMultipleMVs Then
            ManualControl1.lowFlowRate3.Caption = ts$(307) + " 3 " + ts$(305) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "#####0.000 \c\c")  ' "/"Counts"/"\c\c"
        Else
            ManualControl.lowFlowRate3.Caption = ts$(307) + " 3 " + ts$(305) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "#####0.000 \c\c")  ' "/"Counts"/"\c\c"
        End If
    End If
    
    If X = 100 Or X = 106 Then
        x4 = raw_reading(106)
        x5 = (x4 - FX1(2, 0)) / (FX2(2, 0) - FX1(2, 0)) * (FY2(2, 0) * gasflowconversionfactor - FY1(2, 0)) + FY1(2, 0)
        If hasMultipleMVs Then
            ManualControl1.highFlowRate3.Caption = ts$(308) + " 3 " + ts$(305) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "######.000 \c\c")   ' "High Flow Rate (High): "/"Counts"/"\c\c"
        Else
            ManualControl.highFlowRate3.Caption = ts$(308) + " 3 " + ts$(305) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "######.000 \c\c")   ' "High Flow Rate (High): "/"Counts"/"\c\c"
        End If
    End If
    
    If X = 100 Or X = 107 Then
        x4 = raw_reading(107)
        x5 = (x4 - FX1(2, 3)) / (FX2(2, 3) - FX1(2, 3)) * (FY2(2, 3) * gasflowconversionfactor - FY1(2, 3)) + FY1(2, 3)
        If hasMultipleMVs Then
            ManualControl1.lowFlowRate4.Caption = ts$(307) + " 4 " + ts$(305) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "#####0.000 \c\c")  ' "/"Counts"/"\c\c"
        Else
            ManualControl.lowFlowRate4.Caption = ts$(307) + " 4 " + ts$(305) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "#####0.000 \c\c")  ' "/"Counts"/"\c\c"
        End If
    End If
    
    If X = 100 Or X = 108 Then
        x4 = raw_reading(108)
        x5 = (x4 - FX1(2, 2)) / (FX2(2, 2) - FX1(2, 2)) * (FY2(2, 2) * gasflowconversionfactor - FY1(2, 2)) + FY1(2, 2)
        If hasMultipleMVs Then
            ManualControl1.highFlowRate4.Caption = ts$(308) + " 4 " + ts$(305) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "######.000 \c\c")   ' "High Flow Rate (High): "/"Counts"/"\c\c"
        Else
            ManualControl.highFlowRate4.Caption = ts$(308) + " 4 " + ts$(305) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "######.000 \c\c")   ' "High Flow Rate (High): "/"Counts"/"\c\c"
        End If
    End If
    
    If X >= 100 And X <= 108 Then Exit Sub
'    End If
    'End Code enterd by JF 1-13-2010
    
    'ajb 11-01-09 CODE TO SWITCH BETWEEN CARTRIDGE TESTER PRESSURE GAUGES AND REGULAR GAUGES
'    If X = 2 Then
'        If cartridge_tester Then
'            If TType%(current_unit%) <> 4 And cartridge_tester_side = 1 And RUNNING Then
'                'we are doing a cfp, bp, gp test on the cartridge tester side and trying to read P3
'
'                'take initial reading
'                x4 = raw_reading(28)
'
'                'Debug.Print "X4(28): " + Str$(x4)
'                If x4 > DAC_two Then
'                    Pres% = 0
'                    'Debug.Print "High Range - Pres%: " + Str$(Pres%)
'                    x4 = raw_reading(29)
'                    'Debug.Print "X4(29): " + Str$(x4)
'                Else
'                    'Debug.Print "Low Range - Pres%: " + Str$(Pres%)
'                    Pres% = 1
'                End If
'                x5 = (x4 - PX1(Pres% + 4)) / (PX2(Pres% + 4) - PX1(Pres% + 4)) * (PY2(Pres% + 4) - PY1(Pres% + 4)) + PY1(Pres% + 4)
'                Exit Sub
'
'            ElseIf TType%(current_unit%) = 4 And cartridge_tester_side = 1 And RUNNING And switchLPGauge Then
'                'we are doing an ambient or elevated lp test
'                'take initial reading
'                x4 = raw_reading(34)
'                Debug.Print "X4(34): " + str$(x4)
'                If x4 > DAC_two Then
'                    Pres% = 0
'                    'Debug.Print "High Range - Pres%: " + Str$(Pres%)
'                    x4 = raw_reading(35)
'                    'Debug.Print "X4(35): " + Str$(x4)
'                Else
'                    'Debug.Print "Low Range - Pres%: " + Str$(Pres%)
'                    Pres% = 1
'                End If
'                x5 = (x4 - PX1(Pres% + 4)) / (PX2(Pres% + 4) - PX1(Pres% + 4)) * (PY2(Pres% + 4) - PY1(Pres% + 4)) + PY1(Pres% + 4)
'
'                Exit Sub
'            End If
'        Else
'            If (TType%(current_unit%) = 4 Or TType%(current_unit%) = -1) And switchLPGauge And testing And RUNNING Then
'                If num_sample_pressure_gauges = 1 Then
'                    x4 = raw_reading(28)
'                    Debug.Print "X4(28): " + str$(x4)
'                    If x4 > DAC_two Then
'                        Pres% = 0
'                        'Debug.Print "High Range - Pres%: " + Str$(Pres%)
'                        x4 = raw_reading(29)
'                        'Debug.Print "X4(29): " + Str$(x4)
'                    Else
'                        'Debug.Print "Low Range - Pres%: " + Str$(Pres%)
'                        Pres% = 1
'                    End If
'                    x5 = (x4 - PX1(Pres% + 4)) / (PX2(Pres% + 4) - PX1(Pres% + 4)) * (PY2(Pres% + 4) - PY1(Pres% + 4)) + PY1(Pres% + 4)
'                    Exit Sub
'                End If
'            End If
'        End If
'    End If
'
'    'AJB 11-01-09
'
'    If X = 2 And FrazierRunning And (Not manrunning) Then
'      X = 13 + dpgplus%
'    End If
theStart:
    ' 6.71.20 begin
    'JF 9-30-2010 - Changed for use with 3 flow meters
    If X = 1 And Not suspend_v10 And Not diffpgflow(current_unit%) Then
        If xhflow_meters = 1 Then
            If vflow% = 0 And HFLOW% > 1 Then
                vflow% = 1
                Move_Valve 9, "O"
            ElseIf vflow% = 1 And HFLOW% < 2 Then
                vflow% = 0
                Move_Valve 9, "C"
            End If
        ElseIf xhflow_meters = 2 Then
                Move_Valve 9, "C"
                Move_Valve 19, "C"
            If vflow% <> 0 And (HFLOW% = 0 Or HFLOW% = 1) Then
                vflow% = 0
            ElseIf vflow% <> 1 And (HFLOW% = 2 Or HFLOW% = 3) Then
                vflow% = 1
                Move_Valve 9, "C"
                Move_Valve 19, "O"
            ElseIf vflow% <> 2 And (HFLOW% = 4 Or HFLOW% = 5) Then
                vflow% = 2
                Move_Valve 9, "O"
                Move_Valve 19, "C"
            End If
        End If
    End If
    
'    If X = 1 And HFLOW% > 1 And vflow% = 0 And suspend_v10 = False Then
'        vflow% = 1: Move_Valve 9, "O"
'    ElseIf X = 1 And HFLOW% < 2 And vflow% = 1 And suspend_v10 = False Then
'        vflow% = 0: Move_Valve 9, "C"
'    End If
    
    ' 6.71.20 end

    x4 = raw_reading(X)
    
    If x4 > DAC_over Then
        If X = 1 And Not suspend_v10 And Not diffpgflow(current_unit%) Then
            x4 = DAC_over
        Else
            x4 = DAC_over
        End If
    End If
    
    If x4 >= DAC_two And X = 2 And Pres% = 1 And RUNNING And (Not ExtraPG) Then
        ' recalibrate when switching from low to high range of main pressure gauge
        LowX4 = x4
        ' lowx4 = count value of low range
        Pres% = 0   ' reset to high range

        ' read count value of high range
        x4 = raw_reading(2)

        ' on newer machines without relay to wait for,
        ' read low range again and average
        temp_x4 = x4
        Pres% = 1
        LowX4 = (LowX4 + raw_reading(2)) / 2
        Pres% = 0
        x4 = temp_x4

        max_count_p = x4
        X1FIRST = x4
        GoTo 11080
    End If
    
    If x4 >= DAC_two And X = 2 And Pres% > 0 And RUNNING And ExtraPG Then
        LowX4 = x4
        LowX5 = (LowX4 - PX1(Pres%)) / (PX2(Pres%) - PX1(Pres%)) * (PY2(Pres%) - PY1(Pres%)) + PY1(Pres%)
        old_pres% = Pres%
        new_pres% = Pres% - 1
        Pres% = new_pres%
        x4 = raw_reading(2)
        ' 19000 counts for hardware 6 = 92.5% of span plus zero
        If x4 > DAC_zero + 0.925 * DAC_span And Pres% > 0 Then
            new_pres% = new_pres% - 1
            Pres% = new_pres%
            x4 = raw_reading(2)
        End If
        
        'Added in a check for x4 = 100.  This happens when the low pressure gauge is over scale.
        'If it is overscale, it is impossible to find the correct crossover point.
        If old_pres% = 2 And Pres% < 2 And x4 <> 100 Then 'Check crossover point between pressure gauges
            adjustSpanForTargetPressure Pres%, x4, LowX5
        End If
        
        temp_x4 = x4
        Pres% = old_pres%
        LowX4 = (LowX4 + raw_reading(2)) / 2
        Pres% = new_pres%
        x4 = temp_x4
        
        If Pres% <= 1 Then
            Move_Valve 10, "C"
        Else
            Move_Valve 10, "O"
        End If
        Rem for routines keeping track of maximum count value, when the range
        Rem of the gauge changes, reset the maximum value so far
        max_count_p = x4
        X1FIRST = x4
        GoTo 11080
    End If

    'JF 9-30-2010 Changing the following to incorporate the third flow meter
    If X = 1 And x4 >= DAC_two And RUNNING Then
        If hasMultipleMVs And motorValveIndex > 0 Then
            adjMVIndex = 2
        Else
            adjMVIndex = 1
        End If
        If HFLOW% = 0 And alreadyPaused < 2 Then
            alreadyPaused = alreadyPaused + 1
            Waitms 5000, True
            GoTo theStart
        End If
        
        If HFLOW% = 0 And using_hflow1 And Not runningLohmCalibration Then 'switch from Low Flow High Range to Med Flow Low Range
            'First we determine the low flow meters reading value
            ' Low flow side = 3, High flow side = 2
            LowX4 = x4
            LowX5 = (LowX4 - FX1(adjMVIndex, HFLOW%)) / (FX2(adjMVIndex, HFLOW%) - FX1(adjMVIndex, HFLOW%)) * (FY2(adjMVIndex, HFLOW%) * gasflowconversionfactor - FY1(adjMVIndex, HFLOW%)) + FY1(adjMVIndex, HFLOW%)
            
            HFLOW% = 2
            x4 = raw_reading(1)
            
            adjustSpanForTargetFlow adjMVIndex, HFLOW%, x4, LowX5
            
            HFLOW% = 3
            x4 = raw_reading(1)
            
            ' we will leave v10 closed for now - it will open the next time they call this
            using_hflow1 = False
            GoTo 11075
        ElseIf HFLOW% = 1 Then ' switch from Low Flow Low Range to Low Flow High Range
            LowX4 = x4
            HFLOW% = 0
            x4 = raw_reading(1)
            temp_x4 = x4
            HFLOW% = 1
            LowX4 = (LowX4 + raw_reading(1)) / 2
            HFLOW% = 0
            x4 = temp_x4
            GoTo 11075
        ElseIf HFLOW% = 3 Then ' switch from Med Flow Low Range to Med Flow High Range
            LowX4 = x4
            HFLOW% = 2
            x4 = raw_reading(1)
            temp_x4 = x4
            HFLOW% = 3
            LowX4 = (LowX4 + raw_reading(1)) / 2
            HFLOW% = 2
            x4 = temp_x4
            GoTo 11075
        ElseIf HFLOW% = 2 And xhflow_meters = 2 And Not runningLohmCalibration Then ' switch from Med Flow High Range to High Flow Low Range
            'First we determine the low flow meters reading value
            ' Low flow side = 3, High flow side = 2
            LowX4 = x4
            LowX5 = (LowX4 - FX1(adjMVIndex, HFLOW%)) / (FX2(adjMVIndex, HFLOW%) - FX1(adjMVIndex, HFLOW%)) * (FY2(adjMVIndex, HFLOW%) * gasflowconversionfactor - FY1(adjMVIndex, HFLOW%)) + FY1(adjMVIndex, HFLOW%)
            
            HFLOW% = 4
            x4 = raw_reading(1)
            
            adjustSpanForTargetFlow adjMVIndex, HFLOW%, x4, LowX5
            
            HFLOW% = 5
            x4 = raw_reading(1)
            
            GoTo 11075
        ElseIf HFLOW% = 5 Then ' switch from High Flow Low Range to High Flow High Range
            LowX4 = x4
            HFLOW% = 4
            x4 = raw_reading(1)
            temp_x4 = x4
            HFLOW% = 5
            LowX4 = (LowX4 + raw_reading(1)) / 2
            HFLOW% = 4
            x4 = temp_x4
            GoTo 11075
        End If
    End If
  
    If X = 27 And fluidsensor Then
      x5 = (x4 - fsx0) / (fsx1 - fsx0) * (fsy1 - fsy0) + fsy0
    ElseIf X = 27 And (dryChamberTemperature = 1 Or wetChamberTemperature = 1 Or reservoirTemperature = 1) Then
      x5 = (x4 - tsx0) / (tsx1 - tsx0) * (tsy1 - tsy0) + tsy0
    ElseIf X = 30 And (dryChamberTemperature = 2 Or wetChamberTemperature = 2 Or reservoirTemperature = 2) Then
      x5 = (x4 - tsx0) / (tsx1 - tsx0) * (tsy1 - tsy0) + tsy0
      Exit Sub
    End If
    If X = 3 Or (X > 13 And X < 28) Then
        'JF 2-16-2010
        'The following line could cause some unknown problems
        'x5 = x4
        Exit Sub
    End If
    
    If X = 0 Then
        x5 = (x4 - FX1(0, lflow%)) / (FX2(0, lflow%) - FX1(0, lflow%)) * (FY2(0, lflow%) * gasflowconversionfactor - FY1(0, lflow%)) + FY1(0, lflow%)
    End If
    
11075
    If X = 1 Then
        ' Calculated Flow Meter Value
        If hasMultipleMVs Then
            If motorValveIndex = 0 Then
                x5 = (x4 - FX1(1, HFLOW%)) / (FX2(1, HFLOW%) - FX1(1, HFLOW%)) * (FY2(1, HFLOW%) * gasflowconversionfactor - FY1(1, HFLOW%)) + FY1(1, HFLOW%)
            Else
                x5 = (x4 - FX1(2, HFLOW%)) / (FX2(2, HFLOW%) - FX1(2, HFLOW%)) * (FY2(2, HFLOW%) * gasflowconversionfactor - FY1(2, HFLOW%)) + FY1(2, HFLOW%)
            End If
            
            If Not switchingMVs Then
                If motorValveSwitchFlow <> 0 And motorValveIndex = 0 And RUNNING Then
                    If x5 >= motorValveSwitchFlow Then
                        'position second motor valve to take over
                        switchToMv2
                        monitorFlow = True
                    End If
                ElseIf motorValveIndex = 1 And x5 < motorValveSwitchFlow And motorValveSwitchFlow <> 0 And monitorFlow = True Then
                    'switchToMv1
                    Debug.Print "Enter decrease routine"
                'This is where we need to switch to MV3
                'Maybe not
                End If
            End If
        Else
            x5 = (x4 - FX1(1, HFLOW%)) / (FX2(1, HFLOW%) - FX1(1, HFLOW%)) * (FY2(1, HFLOW%) * gasflowconversionfactor - FY1(1, HFLOW%)) + FY1(1, HFLOW%)
        End If
   
        
    End If
11080
    If HighTempPressureGauge And X = 2 And Pres% < 2 Then
        Dim temp As Integer
        Debug.Print "X4: " + str$(x4) + " Pres%: " + str$(Pres%)
        temp = readNewTemperature(dryChamberTemperature)
        x5 = getNewHighTempPressure(x4, temp, Pres%)
    Else
        If X = 2 Then
            x5 = (x4 - PX1(Pres%)) / (PX2(Pres%) - PX1(Pres%)) * (PY2(Pres%) - PY1(Pres%)) + PY1(Pres%)
        End If
    End If
    
    If X = 4 Then
        If Second_Penetrometer And penetrometer_select = 2 Then
            x5 = (x4 - PENZERO) / PENSPAN * (P2PEN20500 - P2PEN500) + P2PEN500
        Else
            x5 = (x4 - PENZERO) / PENSPAN * (PEN20500 - PEN500) + PEN500
            'Debug.Print "Pen1: " + Str$(x4)
        End If
    End If
    
    If DiffPG Then
        If X = 12 + dpgplus% Then x5 = (x4 - PX1(5)) / (PX2(5) - PX1(5)) * (PY2(5) - PY1(5)) + PY1(5)
        If X = 13 + dpgplus% Then x5 = (x4 - PX1(4)) / (PX2(4) - PX1(4)) * (PY2(4) - PY1(4)) + PY1(4)
    End If
    
    If X = 34 Then x5 = (x4 - PX1(7)) / (PX2(7) - PX1(7)) * (PY2(7) - PY1(7)) + PY1(7)
    If X = 35 Then x5 = (x4 - PX1(6)) / (PX2(6) - PX1(6)) * (PY2(6) - PY1(6)) + PY1(6)
    If X = 36 Then x5 = (x4 - PX1(9)) / (PX2(9) - PX1(9)) * (PY2(9) - PY1(9)) + PY1(9)
    If X = 37 Then x5 = (x4 - PX1(8)) / (PX2(8) - PX1(8)) * (PY2(8) - PY1(8)) + PY1(8)
    
    If piston_position_transducer_exists Then '6.71.123.06
        If X = 37 Then   '37 = piston position transducer high
            'calculation assumes default unit of cm
            If x4 <= PX1(8) Then
                x5 = PY1(8)
            ElseIf x4 >= PX2(8) Then
                x5 = PY2(8)
            Else
                x5 = (((x4 - PX1(8)) / (PX2(8) - PX1(8))) * (PY2(8) - PY1(8))) + PY1(8)
            End If
        End If
    End If
    
    If slurry_tube_exists Or tank_level_exists And (X = 39 Or X = 38) Then '6.71.123.06
        If X = 39 Or X = 38 Then   '39 = slurry tube level
            'calculation assumes default unit of cm
            If Not (slurry_tube_exists) And tank_level_exists Then
                If x4 < tankZeroCounts Then
                    x5 = tankZeroCounts
                ElseIf x4 > tankFullCounts Then
                    x5 = tankFullCounts
                Else
                    x5 = ((x4 - tankZeroCounts) / (tankFullCounts - tankZeroCounts)) * 100
                End If
                'x5 = x4
            Else
                If x4 <= slurry_tube_almost_empty_counts Then
                    x5 = slurry_tube_almost_empty_cm
                ElseIf x4 >= slurry_tube_almost_full_counts Then
                    x5 = slurry_tube_almost_full_cm
                Else
                    x5 = ((x4 - slurry_tube_almost_empty_counts) / (slurry_tube_almost_full_counts - slurry_tube_almost_empty_counts)) * (slurry_tube_almost_full_cm - slurry_tube_almost_empty_cm) + slurry_tube_almost_empty_cm
                End If
            End If
        End If
    End If
    
    If slurry_tube_exists Then '6.71.123.06
        If X = 41 Then 'slurry tube pressure
            If x4 <= PX1(10) Then
                x5 = PY1(10)
            ElseIf x4 >= PX2(10) Then
                x5 = PY2(10)
            Else
                x5 = (((x4 - PX1(10)) / (PX2(10) - PX1(10))) * (PY2(10) - PY1(10))) + PY1(10)
            End If
        End If
    End If
    
    If num_sample_pressure_gauges >= 1 Then
        If X = 28 Then
            x5 = (x4 - PX1(5)) / (PX2(5) - PX1(5)) * (PY2(5) - PY1(5)) + PY1(5)
        ElseIf X = 29 Then
            x5 = (x4 - PX1(4)) / (PX2(4) - PX1(4)) * (PY2(4) - PY1(4)) + PY1(4)
        End If
    End If
    
    ' Apply reading math if math override is active
    If ActiveReadMath.OverrideActive Then x5 = CountsToReadingByRM(x4, ActiveReadMath)
    
End Sub

Function getCountForTargetFlow(mvIndex As Integer, flowIndex As Integer, targetFlow As Single) As Long
    Dim targetCount As Long
    Dim targetPercent As Single
    
    targetPercent = (targetFlow - FY1(mvIndex, flowIndex)) / (FY2(mvIndex, flowIndex) * gasflowconversionfactor - FY1(mvIndex, flowIndex))
    targetCount = targetPercent * (FX2(mvIndex, flowIndex) - FX1(mvIndex, flowIndex)) + FX1(mvIndex, flowIndex)
    
    getCountForTargetFlow = targetCount
End Function

Function getCountForTargetPressure(presIndex As Integer, targetPres As Single) As Long
    Dim targetCount As Long
    Dim targetPercent As Single
    
    targetPercent = (targetPres - PY1(presIndex)) / (PY2(presIndex) - PY1(presIndex))
    targetCount = targetPercent * (PX2(presIndex) - PX1(presIndex)) + PX1(presIndex)
    
    getCountForTargetPressure = targetCount
End Function

Sub adjustSpanForTargetFlow(mvIndex As Integer, flowIndex As Integer, currentCount As Long, currentFlow As Single)
    Dim targetSpan As Long
    Dim flowCountSpan As Long
    Dim flowAdjustedReal As Single
    Dim flowAdjustedCount As Long
    
    If Not disableSpanAdjustments And Not (version < 7) Then
        flowCountSpan = FX2(mvIndex, flowIndex) - FX1(mvIndex, flowIndex)
        flowAdjustedReal = currentFlow - FY1(mvIndex, flowIndex)
        flowAdjustedCount = currentCount - FX1(mvIndex, flowIndex)
        targetSpan = ((flowCountSpan * flowAdjustedReal) / flowAdjustedCount) + FY1(mvIndex, flowIndex)
        FY2(mvIndex, flowIndex) = targetSpan
        FY2(mvIndex, flowIndex + 1) = targetSpan * 0.4
    End If
End Sub

Sub adjustSpanForTargetPressure(presIndex As Integer, currentCount As Long, currentPres As Single)
    Dim targetSpan As Long
    Dim presCountSpan As Long
    Dim presAdjustedReal As Single
    Dim presAdjustedCount As Long
    
    If Not disableSpanAdjustments And Not (version < 7) Then
        presCountSpan = PX2(presIndex) - PX1(presIndex)
        presAdjustedReal = currentPres - PY1(presIndex)
        presAdjustedCount = currentCount - PX1(presIndex)
        targetSpan = ((presCountSpan * presAdjustedReal) / presAdjustedCount) + PY1(presIndex)
        PY2(presIndex) = targetSpan
    End If
End Sub

Function read_external_watlow(channel As Integer) As Single
' channel is 1 or 2
Dim i As Integer
Dim a$
On Error Resume Next
If TitleScrn.AuxComm.PortOpen = False Then
    'TitleScrn.AuxComm.CommPort = watlow_com_number
    TitleScrn.AuxComm.PortOpen = True
    If Err.Number <> 0 Then
        read_external_watlow = watlow_last_temperature(channel)
        Exit Function
    End If
End If
TitleScrn.AuxComm.Output = "? C" + Format$(channel) + Chr$(13)
' this shouldn't require a second wait routine since we never read the external watlow
' at the same time we are expecting a character back from the instrument
' and we never expect a character back from the watlow when we are reading the instrument
' though we should test this
a$ = ""
Do
    If TitleScrn.AuxComm.InBufferCount = 0 Then
        Waitms2 2000, True
    End If
    If TitleScrn.AuxComm.InBufferCount > 0 Then
        a$ = a$ + TitleScrn.AuxComm.Input
    Else
        Exit Do
    End If
    If Right$(a$, 1) = Chr$(13) Then
        ' there has to be a chr$(17) in the response, right before the number
        i = InStr(a$, Chr$(17))
        If i > 0 Then
            watlow_last_temperature(channel) = val(Mid$(a$, i + 1))
        End If
        Exit Do
    End If
Loop
read_external_watlow = watlow_last_temperature(channel)
End Function

Function read_rabbit_watlow(channel As Integer) As Single
    ' channel is 0, 1, 2, 3, 4, or 5
    Dim sendChar$, getChar$, chanChar$
    Dim a$, L As Long, T As Single, lt As Single, i As Integer
    Dim viaModbus As Boolean
    Dim message$, retMessage$
    Dim modbusResponse$
    
    If channel < 0 Or channel > 5 Then
        read_rabbit_watlow = 0
        Exit Function
    End If
    
    If ComLoc% = 0 Then
        read_rabbit_watlow = 0
        Exit Function
    End If
    
    If channel < 2 Then
        sendChar$ = ">"
        getChar$ = "<"
        viaModbus = watlowViaModbus(1)
    ElseIf channel < 4 Then
        sendChar$ = "}"
        getChar$ = "{"
        viaModbus = watlowViaModbus(2)
    Else
        sendChar$ = "]"
        getChar$ = "["
        viaModbus = watlowViaModbus(3)
    End If
    
    If viaModbus Then
        modbusResponse$ = readWatlowViaModbus(channel, getChar$, sendChar$)
        read_rabbit_watlow = val(modbusResponse$)
        Exit Function
    Else
        If (channel And 1) = 0 Then
            chanChar$ = "1"
        Else
            chanChar$ = "2"
        End If
        
        ' wait until watlow returns null character to signify an empty buffer
        While (RSEcho(getChar$, 1) <> 0)
          DoEvents
        Wend
        
        Send_RS232 sendChar$ + "?"
        Send_RS232 sendChar$ + " "
        Send_RS232 sendChar$ + "C"
        Send_RS232 sendChar$ + chanChar$
        Send_RS232 sendChar$ + Chr$(13)
        a$ = ""
        Do
            T = Timer ' restart timer for each new character
            Do
                lt = Timer
                If lt + 0.1 < T Then T = T - 86400
                If lt - T > 0.5 Then
                    L = 0
                    Exit Do
                End If
                ' get next return character, if there is one
                L = RSEcho(getChar$, 1)
            Loop Until L > 0
            If L = 0 Then Exit Do
            a$ = a$ + Chr$(L)
            If L = 13 Then
                ' there has to be a chr$(17) in the response, right before the number
                i = InStr(a$, Chr$(17))
                If i > 0 Then
                    read_rabbit_watlow = val(Mid$(a$, i + 1))
                    Exit Function
                End If
                Exit Do
            End If
        Loop
    End If
    ' error if we get here
    read_rabbit_watlow = 0
End Function

Sub Refill_Penetro()
    Dim ok_should_be_used As Boolean
    Dim T As Single, t2 As Single, k As Single
    Dim tempPEN20500 As Single
    Dim tempPEN500   As Single
    Dim tempPENZERO As Long, tempPENTWO As Long, tempPENSPAN As Long
    
    If (penetrometer_select = 2) Then
        tempPEN20500 = P2PEN20500
        tempPEN500 = P2PEN500
        tempPENZERO = P2PENZERO
        tempPENTWO = P2PENTWO
        tempPENSPAN = P2PENSPAN
    Else
        tempPEN20500 = PEN20500
        tempPEN500 = PEN500
        tempPENZERO = PENZERO
        tempPENTWO = PENTWO
        tempPENSPAN = PENSPAN
    End If
    
    ' remember the current position of the pressure regulator
    ' note that this variable does not have the same meaning in version 6
    initp = REGPOS
    ' close valve 3 (the drain valve) to stop flow out of system
    If Drain12 Then
        Move_Valve 11, "C"
        If tempPEN20500 < 0 Then
            ' wait 2 seconds for this valve to completely close on lowered penetrometer systems
            waitseconds 2
        End If
    Else
        Move_Valve 2, "C"
    End If
    ' bring the sample back to atmospheric pressure by one of the following means
    ' if you have it, close valve 9
    ' for recirculation, close valve 21 before closing valve 9
    If recirculation Then
        Move_Valve 20, "C"
        waitseconds 2
    End If
    ' This leaves the pressure regulator at high pressure but vents the penetrometer
    Move_Valve 8, "C"
    If Auto_fill Then waitseconds lperm_autoFillVentTime
    If tank_level_exists Then
        ReadXReturnX4 tank_level_location
        If x5 < min_tank_fill_level Then
            TankFillDialog.Show 0
        End If
    End If
    ' open the water inlet valve, if it is there.
    Move_Valve 12, "O"
    ' actual refill code:
    Msgform.cancel.Visible = False
    Msgform.lb.Visible = False
    Msgform.ok.Visible = False
    If Not Auto_fill Then
        Msgform.StopTest.Visible = True
        Msgform.Label.Caption = ts$(218)            ' "Begin filling penetrometer"
        ok_should_be_used = True
        Msgform.Label1.Visible = True
        Msgform.Label1.Caption = ts$(216) + str$(100 * ver1or3) + " " + ts$(217) + str$(500 * ver1or3)    ' "Fill until counts are between"/"and"
        Msgform.Show 0
        Msgform.Refresh
    Else
        Msgform.StopTest.Visible = False
        Msgform.Label.Caption = ts$(253)                ' "Refilling penetrometer"
        Msgform.Label1.Visible = False
        'ok_should_be_used = False
        ok_should_be_used = True
        Msgform.Show 0
        Msgform.Refresh
    End If
    
    ' check the penetrometer level first
    If (isPenetrometerFull) Then GoTo stopfill
    
    ReadXReturnX4 4
    While x4 < tempPENZERO Or x4 > tempPENTWO
        ReadXReturnX4 4
        Msgform.Label.Caption = Format$(x5, "#0.00 \c\m   ") + Format$(x4, "####0 " + ts$(432))  ' "\c\m"/"\c\o\u\n\t\s"
        Msgform.Refresh
        DoEvents
        If ok_should_be_used And Not Msgform.StopTest.Visible Then GoTo stopfill
    Wend
    ' 1000 counts in hardware version 6 is 2.5% of span plus zero
    ' 10500 counts in hardware version 6 is 50% of span plus zero
    While x4 < tempPENZERO + 0.025 * tempPENSPAN Or x4 > tempPENZERO + 0.5 * tempPENSPAN
        ReadXReturnX4 4
        Msgform.Label.Caption = Format$(x5, "#0.00 \c\m   ") + Format$(x4, "####0 " + ts$(432))  ' "\c\m"/"\c\o\u\n\t\s"
        Msgform.Refresh
        DoEvents
        If ok_should_be_used And Not Msgform.StopTest.Visible Then GoTo stopfill
    Wend
    While x4 - pen_bias >= tempPENZERO
        ReadXReturnX4 4
        Msgform.Label.Caption = Format$(x5, "#0.00 \c\m   ") + Format$(x4, "####0 " + ts$(432))  ' "\c\m"/"\c\o\u\n\t\s"
        Msgform.Refresh
        DoEvents
        If ok_should_be_used And Not Msgform.StopTest.Visible Then GoTo stopfill
        ' since we are in range, check to see if we are above the bottom_fill_point for bottom fill
        ' autofill machines.  If we are, we want to close the sample isolation valve to let the penetrometer
        ' fill up more on its own
        If tempPEN20500 < 0 And Auto_fill And x5 > bottom_fill_point And Vpos(20) = 1 Then
            ' close valve 20 to stop sample from filling any more
            Move_Valve 19, "C" ' some machines use 20
            Move_Valve 11, "C" ' some machines use 12
        End If
    Wend
    If ok_should_be_used Then
        Msgform.ok.Visible = True
        Msgform.ok.SetFocus
        While Msgform.ok.Visible And Msgform.StopTest.Visible
            ReadXReturnX4 4
            Msgform.Label.Caption = Format$(x5, "#0.00 \c\m   ") + Format$(x4, "####0 " + ts$(432)) ' "\c\m"/"\c\o\u\n\t\s"
            Msgform.Refresh
            DoEvents
        Wend
    End If
stopfill:
    ' close the water inlet valve, if it is there
    Move_Valve 12, "C"
    If Auto_fill And (Not TopFill) And version < 7 Then
        Rem pulse drain valve
        Move_Valve 11, "O"
        Move_Valve 11, "C"
    End If
    If tempPEN20500 < 0 And Auto_fill And Vpos(20) = 0 Then
        ' we now need to open valve 20 again and wait for penetrometer to stabilize
        Move_Valve 19, "O"
        Move_Valve 11, "O"
        ' wait until penetrometer hasn't gone down in 2 seconds or 20 seconds maximum
        ' with 5 second minimum
        T = Timer
        t2 = T
        ReadXReturnX4 4
        k = x5
        Do
            ReadXReturnX4 4
            Msgform.Label.Caption = Format$(x5, "#0.00 \c\m   ") + Format$(x4, "####0 " + ts$(432))  ' "\c\m"/"\c\o\u\n\t\s"
            Msgform.Refresh
            If x5 < k Then
                k = x5
                T = Timer
            End If
            If T > Timer + 0.1 Then T = T - 86400 ' handle midnight
            If t2 > Timer + 0.1 Then t2 = t2 - 86400
            If (Timer - t2) < 5 Then T = Timer
        Loop Until ((Timer - T) > 2) Or ((Timer - t2) > 20)
    End If
        
    FillDone = True
    inrange = False
    If Not Auto_fill And Msgform.StopTest.Visible Then
        MsgBox ts$(254) + vbCrLf + ts$(63), 0, ts$(223)    '  "Penetrometer should now be full."/"Press OK to continue."/"Test Setup"
    End If
    ' since we are unloading MSGFORM, the following line should not be needed
    'MSGFORM.StopTest.Visible = False
    Unload Msgform
    
End Sub
Private Function isPenetrometerFull() As Boolean
' Check the reading of the penetrometer sensore
' We want to see sensors reading to be inside of  PENZERO and PENTWO.
' If the penetrometer is full, for example after the Hydrohead or Burst tests,
' then it make sense to allow some water to drain and check if the sensor reading
' is between PENZERO and PENTWO.

    Dim nTimes As Integer
    nTimes = 10
    
'    drain 2 seconds
'    waitseconds 2
    Dim tempPENZERO As Long
    
    Select Case penetrometer_select

        Case 2
        tempPENZERO = P2PENZERO
    
        Case Else
        
        tempPENZERO = PENZERO
    End Select
    
    ReadXReturnX4 4
    If (x4 < nTimes * tempPENZERO) Then
        Move_Valve 12, "C"
        Move_Valve 11, "O"
        Move_Valve 22, "O"

        While (x4 < nTimes * tempPENZERO)
            ReadXReturnX4 4
        Wend
        
        isPenetrometerFull = False
        
        Move_Valve 12, "O" ' open fill valve
        Move_Valve 22, "C" ' close drain valve
        Move_Valve 11, "O" ' open isolation valve

    Else
        isPenetrometerFull = False
    End If
    
End Function
Sub reg_goto(target As Long)

    If Not newreg Then
        MsgBox "Error:  reg_goto can't be called by this feature number"
        End
    End If
    
    Send_RS232l "GE", target
    While RSEcho("VE", 1) <> Asc("S")
        tryhold
    Wend
    
End Sub

Sub reg_goto_up(target As Long)

    If Not newreg Then
        MsgBox "Error:  reg_goto_up can't be called by this feature number"
        End
    End If
    Send_RS232l "G+E", target
    While RSEcho("VE", 1) <> Asc("S")
        tryhold
    Wend

End Sub

Function regpos_from_p(P As Single) As Long
' return the regulator position that should give a pressure of p
' 6.71.22 will now extrapolate if it runs out of table

Dim i As Integer

If reg_table_size%(regnum) <= 1 Then
    ' estimate based on reg_ol and reg_cl and 0 to 100 PSI
    If P <= 0 Then
        regpos_from_p = reg_cl
    ElseIf P >= 100 Then
        regpos_from_p = reg_ol
    Else
        regpos_from_p = P * (reg_ol - reg_cl) / 100 + reg_cl
    End If
Else
    i = 2
    If regnum = 0 Then
        While i < reg_table_size%(0) And P > reg_table_pres!(i)
            i = i + 1
        Wend
' 6.71.22 commented out these lines
'        If P > reg_table_pres!(i) Then
'            regpos_from_p = reg_table_pos(i)
'        Else
            regpos_from_p = (P - reg_table_pres!(i - 1)) * (reg_table_pos(i) - reg_table_pos(i - 1)) / (reg_table_pres!(i) - reg_table_pres!(i - 1)) + reg_table_pos(i - 1)
'        End If
    Else
        While i < reg_table_size%(1) And P > reg_table_pres2!(i)
            i = i + 1
        Wend
' 6.71.22 commented out these lines
'        If P > reg_table_pres2!(i) Then
'            regpos_from_p = reg_table_pos2(i)
'        Else
            regpos_from_p = (P - reg_table_pres2!(i - 1)) * (reg_table_pos2(i) - reg_table_pos2(i - 1)) / (reg_table_pres2!(i) - reg_table_pres2!(i - 1)) + reg_table_pos2(i - 1)
'        End If
    End If
End If

End Function

Function new_regpos_from_p(P As Single) As Long
    Dim i As Integer
    
    While i < reg_table_size%(0) And P > reg_table_pres!(i)
        i = i + 1
    Wend

    new_regpos_from_p = reg_table_pos(i - 1)
End Function

Sub ReZeroAll()

    If RUNNING Then
        MsgBox ts$(255), 0, ts$(256)       ' "You cannot re-zero the flow meters during a test."/"Re-Zero"
        Exit Sub
    End If
        
    ReadXReturnX4 3             'valve 2 position
    If (x4 > cLimit) Or (Vpos(3) = 0) Or (Vpos(1) = 1) Then
        MsgBox ts$(257), 0, ts$(256)        ' "You cannot re-zero the flow meters if Valve 2 is open, Valve 3 is closed, or Valve 1 is open."/"Re-Zero"
        Exit Sub
    End If

    reply% = MsgBox(ts$(258), 4, ts$(256))      ' "Continue with re-zero of flow meters."/"Re-Zero
    If reply% = 7 Then Exit Sub

    lflow% = 0

    ReadXReturnX4 0
    FX1(0, 0) = x4
    FX2(0, 0) = x4 + DAC_span
    lflow% = 1
 
    ReadXReturnX4 0
    FX1(0, 1) = x4
    FX2(0, 1) = x4 + DAC_span

    HFLOW% = 0
    ReadXReturnX4 1
    FX1(1, 0) = x4
    FX2(1, 0) = x4 + DAC_span
    HFLOW% = 1
    ReadXReturnX4 1
    FX1(1, 1) = x4
    FX2(1, 1) = x4 + DAC_span
    HFLOW% = 2
    ReadXReturnX4 1
    FX1(1, 2) = x4
    FX2(1, 2) = x4 + DAC_span
    HFLOW% = 3
    ReadXReturnX4 1
    FX1(1, 3) = x4
    FX2(1, 3) = x4 + DAC_span
    
End Sub

Function RInStr(main$, short$)
' find and return the position of the rightmost occurrence of short$
' in main$

    Dim POS%, newpos%

    POS% = 0
    Do
        newpos% = InStr(POS% + 1, main$, short$)
        If newpos% = 0 Then Exit Do
        POS% = newpos%
    Loop
    RInStr = POS%

End Function

Function RSEcho(db$, NumBytes As Byte) As Long
    ' assume GA character is a space
    RSEcho = RSEcho_New(db$, NumBytes, " ", 0, 0)
End Function

Function RSEchoi(db$, i As Integer, NumBytes As Byte) As Long
    ' assume GA character is a space
    RSEchoi = RSEcho_New(db$, NumBytes, " ", 2, CLng(i))
End Function

Function RSEchol(db$, L As Long, NumBytes As Byte) As Long
    ' assume GA character is a space
    RSEchol = RSEcho_New(db$, NumBytes, " ", 2, L)
End Function

Function RSEchob(db$, b As Byte, NumBytes As Byte) As Long
    ' assume GA character is a space
    RSEchob = RSEcho_New(db$, NumBytes, " ", 1, CLng(b))
End Function

Function RSEcho_GA(db$, NumBytes As Byte, ga$) As Long
    RSEcho_GA = RSEcho_New(db$, NumBytes, ga$, 0, 0)
End Function

Sub RSOutput_Raw(message$)
' just send message out the serial port.  Don't wait for anything
' This is used by Modbus communication routines
' This won't work on networked connections
' Make sure that message$ is filled with bytes, not chars
' or this may have trouble in CJK settings
Dim i%, curChar As Byte
Dim numchars%
Dim buffer As Variant
Dim ba1(0) As Byte
If ComLoc% = -1 Then
    numchars% = LenB(message$)
    For i% = 1 To numchars%
        ' use a byte array so that we can send non-ascii characters out the port
        ba1(0) = AscB(MidB(message$, i%, 1))
        buffer = ba1
        TitleScrn.MainComm.Output = buffer
    Next i%
End If
End Sub

Function RSInput_Raw() As Integer
' raw serial port input, used for Modbus
' returns byte of next character in serial port stream, or -1 if there is no character
' this won't work on networked connections
' Since this uses bytes and not characters, it should work with CJK
Dim buffer As Variant
Dim ba() As Byte
If ComLoc% = -1 Then
    If (TitleScrn.MainComm.InBufferCount = 0) Then
        RSInput_Raw = -1
    Else
        buffer = TitleScrn.MainComm.Input
        ba = buffer
        RSInput_Raw = ba(0)
    End If
Else
    RSInput_Raw = -1 ' there are never any characters to return in demo mode
End If
End Function

Function RSEcho_New(db$, NumBytes As Byte, ga$, numextra As Byte, extraint As Long) As Long
' now uses 6 bit return values with a 32 offset so all return values are printable
' This means that when numbytes=1 you can only return a value from 0 to 63
' When numbytes=2 you can only return a value from 0 to 4095
' and when numbytes=3 you can return a value from 0 to 262143

    Dim c$, i%, trys%, Ret1%, Ret2%, Ret3%, test%, char%, numchars%, curChar As Byte
'    Dim TmpTime As Single
    Dim full_redo_trys%
    Dim buffer As Variant
    Dim ba() As Byte
    Dim ba1(0) As Byte
    Static prev_db$
    Dim redo_command As Boolean
    Dim charstart As Integer
    Dim L As Long
    
    If network_connected Then
        If network.Remote_Option.value Then
            ' send this request to the computer at the other end of the network
            If Len(db$) = 1 Then
                L = Asc(db$)
            ElseIf Len(db$) = 2 Then
                L = Asc(Left$(db$, 1)) + 256 * Asc(Mid$(db$, 2, 1))
            Else ' must be 3
                L = Asc(Left$(db$, 1)) + 256 * Asc(Mid$(db$, 2, 1)) + 256& * 256 * Asc(Mid$(db$, 3, 1))
            End If
            abort_wait = False
            c$ = str$(L) & "," & str$(NumBytes) & "," & str$(Asc(ga$)) & "," & str$(numextra) & "," & str$(extraint)
            network.data_sent_label = c$
            network.Winsock1.SendData c$ & vbCrLf
            If abort_wait = False Then
                Waitms 30000, True
            End If
            RSEcho_New = val(network.response_label.Caption)
            Exit Function
        End If
    End If
    
    redo_command = False

    ' normal RSEcho with ga character a variable
    'DoEvents
    If ComLoc% = 0 Then
      If NumBytes = 0 Then
        RSEcho_New = 0
      ElseIf NumBytes = 1 Then
        RSEcho_New = 83 ' this is the "S" return value to say a valve has stopped
      Else
        RSEcho_New = DAC_zero ' this is the zero voltage reading
      End If
      ' wait 0.1 seconds to more properly simulate what happens with a real instrument
      Waitms 100, False
      Exit Function
    End If
    If ComLoc% = -1 Then
      full_redo_trys% = 0
full_redo:
      If redo_command Then
        ' we have just sent a space character to the comm port, so we had better wait for it
        ' to come back
        ' wait for no longer than 2 seconds
        If (TitleScrn.MainComm.InBufferCount = 0) Then
            Waitms 2000, True ' will return after 2 seconds, or if we get an input character
        End If
        'TmpTime = Timer
        'While (TitleScrn.MainComm.InBufferCount = 0) And (Timer <= TmpTime + 2) And (Timer + 0.1 > TmpTime)
        '    DoEvents
        'Wend
        ' new check - if we are going a "RG" command, we need to add an extra space character
        ' to avoid endless looping with confusion with the "G" command
        If Left$(db$, 2) = "RG" Then
            ' send out an extra space and wait for it to come back
            TitleScrn.MainComm.Output = " "
            fill_cel Timer, 4, 32
            If (TitleScrn.MainComm.InBufferCount = 0) Then
                Waitms 2000, True
            End If
            'TmpTime = Timer
            'While (TitleScrn.MainComm.InBufferCount = 0) And (Timer <= TmpTime + 2) And (Timer + 0.1 > TmpTime)
            '    DoEvents
            'Wend
        End If
       End If
      redo_command = False
      Rem use the comm1 port
      Rem first, discard any values that are out there
      While TitleScrn.MainComm.InBufferCount > 0
        buffer = TitleScrn.MainComm.Input
        ba = buffer
        fill_cel Timer, 3, ba(0) ' got extra character back
      Wend
      Rem second, send all bytes out
      numchars% = Len(db$) + numextra
      If version < 7 Then charstart = 1 Else charstart = 0
      For i% = charstart To numchars%
        trys% = 0
RedoComm:
        ' use a byte array so that we can send non-ascii characters out the port
        If i% = 0 Then
            ' for version 7, send a null character at the beginning of each sequence
            ' to keep everything in sync at the higher baud rates
            curChar = 0
        ElseIf i% <= Len(db$) Then
            'Changed to using Asc instead of AscB because it was changing some byte values.
            'curChar = AscB(Mid$(db$, i%, 1))
            curChar = Asc(Mid$(db$, i%, 1))
        ' for integers, numextra = 2 and we send out the high byte last
        ElseIf i% = numchars% And numextra = 2 Then
            curChar = (extraint \ 256)
        ' for integers and bytes we send out the low byte first (or only)
        Else
            curChar = (extraint And 255)
        End If
        ba1(0) = curChar
        buffer = ba1
        If TitleScrn.MainComm.PortOpen = False Then
            On Error GoTo blah
            TitleScrn.MainComm.PortOpen = True
        End If
        TitleScrn.MainComm.Output = buffer
        fill_cel Timer, 1, curChar ' sent out character
        ' wait no more than 0.4 seconds for a character to appear
        If TitleScrn.MainComm.InBufferCount = 0 Then
            Waitms 400, True
        End If
        'TmpTime = Timer
        'While (TitleScrn.MainComm.InBufferCount = 0) And (Timer <= TmpTime + 0.4) And (Timer + 0.1 > TmpTime)
        '    DoEvents
        'Wend
        trys% = trys% + 1
        If trys% > 10 Then
            MsgBox ts$(260) + str$(TitleScrn.MainComm.CommPort) + vbCrLf + ts$(261) + vbCrLf + ts$(262), vbCritical, ts$(263)    ' "Communications Error! Channel"/"Not getting a response from the instrument."/"Please check communications cable and restart."/"Porometer Control"
            PA = 0
            Return
        End If
        DoEvents
        If TitleScrn.MainComm.InBufferCount = 0 Then
            'MsgBox "timeout reading echoed character"
            If log_comm Then
                log_append "timeout reading echoed character"
            End If
            numhangs = numhangs + 1
            GoTo RedoComm
        End If
reget_input:
        buffer = TitleScrn.MainComm.Input
        ba = buffer
        fill_cel Timer, 2, ba(0) ' got a character in
        If ba(0) <> curChar Then
            ' may be out of sync.  Give it 0.4 seconds for the next character to come in
            If TitleScrn.MainComm.InBufferCount = 0 Then
                Waitms 400, True
            End If
            'TmpTime = Timer
            'While (TitleScrn.MainComm.InBufferCount = 0) And (Timer <= TmpTime + 0.4) And (Timer + 0.1 >= TmpTime)
            '    DoEvents
            'Wend
            If TitleScrn.MainComm.InBufferCount = 0 Then
                If log_comm Then
                    log_append "echoed character (" + str$(ba(0)) + ")<> sent (" + str$(curChar) + ")"
                End If
                numhangs = numhangs + 1
                redo_command = True
                GoTo RedoComm
            End If
            If log_comm Then
                log_append "echoed character (" + str$(ba(0)) + ")<> sent (" + str$(curChar) + ") but got another character as well, so checking that"
            End If
            ' we got in another character
            ' go back and read it in
            GoTo reget_input
        End If
      Next i%
      Ret1% = 0: Ret2% = 0: Ret3% = 0
      For i% = 1 To NumBytes
        Ret1% = Ret2%
        Ret2% = Ret3%
        If version < 7 Then
            TitleScrn.MainComm.Output = ga$
            fill_cel Timer, 6, CByte(Asc(ga$))
        End If
        Rem wait for return character
        If TitleScrn.MainComm.InBufferCount = 0 Then
            Waitms 1000, True
        End If
        'TmpTime = Timer
        'While (TitleScrn.MainComm.InBufferCount = 0) And (Timer <= TmpTime + 1) And (Timer + 0.1 > TmpTime)
        '    DoEvents
        'Wend
        ' this line causes trouble in Japan:
        'Ret2% = Asc(Left$(TitleScrn.MainComm.Input + vbNullChar, 1))
        ' problem is with dual byte characters found in Japan
        ' When the byte value in the return string equals a character that signifies
        ' that it is the start of a two-byte character, then input wants to return a
        ' two-byte character, but only has the first byte of the character so it
        ' waits for the next byte to come in, which never happens so it times out
        ' if the buffer is empty, send back the ga character
        If TitleScrn.MainComm.InBufferCount = 0 Then
            Ret3% = Asc(ga$)
            If log_comm Then
                log_append "communications error getting read value back"
            End If
            numhangs = numhangs + 1
            redo_command = True
            ' if we didn't get anything back, send a space character to re-sync a bad
            ' read command sequence
            TitleScrn.MainComm.Output = " "
            fill_cel Timer, 4, 32
            Exit For
        Else
            buffer = TitleScrn.MainComm.Input
            ba = buffer
            Ret3% = ba(0)
            fill_cel Timer, 5, ba(0)
        End If
        DoEvents
      Next i%
      If redo_command Then
        full_redo_trys% = full_redo_trys% + 1
        If full_redo_trys% < 10 Then
            GoTo full_redo
        End If
        If log_comm Then
            log_append "too many errors"
        End If
        MsgBox ts$(264) + " (" + db$ + ")"      ' "Communications error: No response from read command"
        ' send dummy return value
        If NumBytes = 0 Then
            RSEcho_New = 0
        ElseIf NumBytes = 1 Then
            RSEcho_New = 83 ' this is the "S" return value to say a valve has stopped
        Else
            RSEcho_New = DAC_zero ' this is the zero voltage reading
        End If
        Exit Function
      End If
      If NumBytes = 0 Then
        RSEcho_New = 0
      ElseIf NumBytes = 1 Then
        ' for one byte, just return the entire character, unchanged
        ' this works for both version 6 and 7
        ' Under version 7, the characters is assumed to be printable
        RSEcho_New = Ret3%
      ElseIf version < 7 Then
        ' for version 6, the only other alternative is 2 bytes
        RSEcho_New = CLng(Ret3%) * 256 + CLng(Ret2%)
      Else
        ' for version 7, there may be 2 or 3 bytes, and each byte is a value
        ' from 32 to 95 (printable characters all) while actually signifies
        ' a 6-bit value from 0 to 63
        If Ret3% < 32 Or Ret3% > 95 Then
            log_append "invalid return value"
            Ret3% = 33
        End If
        If Ret2% < 32 Or Ret2% > 95 Then
            log_append "invalid return value"
            Ret2% = 33
        End If
        If NumBytes = 2 Then
            RSEcho_New = CLng(Ret3% - 32) * 64 + CLng(Ret2% - 32)
        Else
            If Ret1% < 32 Or Ret1% > 95 Then
                log_append "invalid return value"
                Ret1% = 33
            End If
            RSEcho_New = (CLng(Ret3% - 32) * 64 + CLng(Ret2% - 32)) * 64 + CLng(Ret1% - 32)
        End If
      End If
      prev_db$ = db$
      Exit Function
    End If

' this is left over from version 5 - remove it
'    ' Second Send all bytes out
'    numchars% = Len(DB$) + numextra
'    For i% = 1 To numchars%
'        trys% = 0
'Redo:   If i% <= Len(DB$) Then
'            curchar = AscB(Mid$(DB$, i%, 1))
'        ElseIf i = numchars% And numextra = 2 Then
'            curchar = (extraint \ 256)
'        Else
'            curchar = (extraint And 255)
'        End If
'        char% = curchar
'
'        trys% = trys% + 1
'        If trys% > 10 Then
'            MsgBox ts$(265) + vbCrLf + ts$(261) + vbCrLf + ts$(262), vbExclamation, ts$(263)       ' "Communications Error!"/"Not getting a response from the instrument."/" Please check communications cable and restart."/"Porometer Control"
'            End
'        End If
'        DoEvents
'        If test% <> char% Then GoTo Redo
'    Next i%
'    Ret1% = 0: Ret2% = 0
'
'    If NumBytes = 1 Then RSEcho_New = Ret2% Else RSEcho_New = Ret2% * 256 + Ret1%
'Ret:
Exit Function
blah:
PA = 0
End Function

Function Run_Ambient_LqPerm(x_array As dat_array) As Boolean
' Called from run_c_pass to handle an ambient or elevated pressure liquid permeability test
' The return value corresponds to dont_reopen_valve_20, which is set here but used at the end
' of run_c_pass.

    Dim timestamp As LARGE_INTEGER, startTime As LARGE_INTEGER
    Dim lasttime As LARGE_INTEGER
    Dim T As Single, lastT As Single
    Dim h As Single, lastH As Single
    Dim difftime As Double
    Dim nowString$
    Dim s_local_BalanceNotPenet_gm_cm As String
    Dim s_local_BalanceNotPenet_Height_Mass As String
    Dim lastx4 As Long
    Dim VOL As Single
    Dim fn As Integer
    ' 6.71.81 new variables
    Dim l_temp As Long
    Dim using_pressure As Boolean
    Dim local_time As Single
    Dim last_time_regulator_incremented As Single
    
    If cartridge_tester Then
        switchLPGauge = False 'AJB 11-01-09
    End If
    
    nowString$ = Format(str$(now), "mmddyy_hhmm")
    using_pressure = False
 
' **********
' Begin code inserted by search for Tim Richards on Monday 6/14/04
' change     Msgform.Label.Caption = Format$(x5, "#0.00 \c\m   ") + Format$(x4, "####0 " + ts$(432))  ' "\c\m"/"\c\o\u\n\t\s"
'
  
    If g_bBalanceNotPenet = True Then
        s_local_BalanceNotPenet_gm_cm = ts$(484)
        s_local_BalanceNotPenet_Height_Mass = ts$(486)
    Else
        s_local_BalanceNotPenet_gm_cm = ts$(485)
        s_local_BalanceNotPenet_Height_Mass = ts$(243)
    End If
'
' End code inserted by Tim Richards 6/14/04
' **********
    
    If use_temperature Then
    
        ' set temperature
        'Send_RS232i ";", Int(TTarg * 10)
        setNewTemperature wetChamberTemperature, TTarg
        Status.Label1.Caption = ts$(266) + str$(TTarg) + " " + tsunit$      ' "Waiting for temperature to reach"
        Status.Show 0
        x5 = -1
        
        While (x5 < TTarg - 5 Or x5 > TTarg + 10) And Status.Command1.Enabled
            'ReadXReturnX4 27
            x5 = readNewTemperature(wetChamberTemperature)
            Status.Label2.Caption = ts$(267) + ": " + Xformat$(x5, "#####.0") + " " + tsunit$     ' "Current temperature"
        Wend
        
        If Not Status.Command1.Enabled Then
            If MsgBox(ts$(268), 4, ts$(269)) = 7 Then       ' "Do you want to start the test at the current temperature?  (No will cancel the test)"/"Liquid Permeability Test"
                Aborted = True
                Unload Status
                Exit Function       ' GoTo END_PASS
            End If
        End If
        Unload Status
    End If
        
    
        
    If TMode%(current_unit%) = 2 Then       ' Elevated pressure test
        Run_Elev_LqPerm x_array
        Status.Command1.Visible = False
        Status.Label1.Caption = ts$(449)    ' "Venting system - please wait"
        Status.Show 0
        
        ' for recirculation systems, we want to close off the pressure line into the penetrometer as soon as
        ' possible to avoid liquid getting back into the machine
        If recirculation Then
            ' new experimental for ballard
            Move_Valve 8, "C" ' first, vent most of the pressure out of valve 9, leaving valve 21 open
            waitseconds 30
            ' then close valve 21
            Move_Valve 20, "C"
            ' wait for valve 21 to close
            waitseconds 2
            ' turn on fill and then turn it off.  This will vent any remaining pressure back into the tank
            Move_Valve 12, "O"
            waitseconds 2
            Move_Valve 12, "C"
            ' now pressurize the area between valve 9 and 21 with any air remaining in the air system
            ' this should blow any oil in valve 9 back away from valve 9
            Move_Valve 8, "O"
        End If      ' Recirculation
        
        ' at the end of a test, for bottom fill liquid perm instruments
        ' you want to close the isolation valve (20 in liqperm only machines, 12 in others)
        ' so we will close both
        If PEN20500 < 0 Then
            Move_Valve 19, "C"
            Move_Valve 11, "C"
            ' wait for valves(s) to fully close before finishing
            waitseconds 2
            Run_Ambient_LqPerm = True       ' this is setting dont_reopen_valve_20 true in run_c_pass
        End If
        
        Unload Status
        Exit Function   ' GoTo END_PASS
    
    End If              'run elevated liquid perm.
        
    'run ambient liquid permeability test
    ' this includes new bublflow based liquid permeability
    progress.List1.clear
    progress.List1.AddItem ts$(269) + " (cm)    " + ts$(229) + " " + PU$ + "    " + ts$(30) + " (cc/min)"        ' "Height of Liquid"/"cm"/"Pressure"/"Flow"/"cc/m"
    progress.List1.AddItem " "
'    If special_ambient Then
'        ' special ambient is only run on machines with both a
'        ' venting valve and a drain valve.  Both valves should
'        ' be open (the venting valve isn't important as it is\
'        ' bypassed for this
'        Move_Valve 2, "O"
'        Move_Valve 11, "O"
'        ' the penetrometer venting valve must be open (to let
'        ' the air from the manifold into the penetrometer)
'        Move_Valve 8, "O"
'        ' the air must be going from the manifold up to the penetrometer
'        Dry_Chamber_Control "C"
'        ' valve 1 must be open to let the air into the system
'        Move_Valve 0, "O"
'        If low_flow_controller Then set_low_flow_rate BUBLFLOW
'        ' the regulator should be pulsed the right amount of times
'        ' to set to the initial bublflow
'        If REGPOS < 0 Then REGPOS = 0
'        If newreg Then
'            If SBPP - 100 < reg_cl Then         ' original, but hfbp always false at this point --> ' Or hfbp Then
'                reg_goto (SBPP)
'            Else
'                reg_goto (SBPP - 100)
'            End If
'        Else
'            If ip_reg_enable Then
'                If REGPOS < SBPP Then
'                    inc_reg SBPP - REGPOS
'                End If
'            Else
'                While REGPOS < SBPP: inc_reg 1: Wend   '  initial pressure
'            End If
'        End If
'    Else
        If ip_reg_enable And (PEN20500 < 0) Then
            ' open valve 2 all the way
            openv2completely
            ' increase pressure to about 1 PSI
            l_temp = regpos_from_p(1)
            If l_temp > 4000 Then l_temp = 4000
            If REGPOS < l_temp Then
                inc_reg l_temp - REGPOS
            End If
            ' wait for stable pressure - experimental as of 6.71.81
            last_time_regulator_incremented = Timer
            ' step 1, wait for pressure to rise above what we want,
            ' incrementing every 5 seconds if necessary
            ' - we should already be close because of the previous inc_reg
            Do
                ReadXReturnX4 2
                progress.Line26.Caption = "1:P=" + Xformat$((x5 - P0) * PCNV, "###0.000  ") + PU$ + "  R=" + Format$(REGPOS)
                progress.Line26.Refresh
                If (x5 - P0) >= 1 Then Exit Do
                local_time = Timer
                If local_time + 1 < last_time_regulator_incremented Then
                    last_time_regulator_incremented = last_time_regulator_incremented - 86400
                End If
                If local_time - last_time_regulator_incremented > lperm_init_wait Then
                    inc_reg 5
                    last_time_regulator_incremented = local_time
                End If
            Loop
            ' step 2, decrement the regulator by 1 until the pressure drops below
            ' what we want
            Do
                ReadXReturnX4 2
                progress.Line26.Caption = "2:P=" + Xformat$((x5 - P0) * PCNV, "###0.000  ") + PU$ + "  R=" + Format$(REGPOS)
                progress.Line26.Refresh
                If (x5 - P0) < 1 Then Exit Do
                local_time = Timer
                If local_time + 1 < last_time_regulator_incremented Then
                    last_time_regulator_incremented = last_time_regulator_incremented - 86400
                End If
                If local_time - last_time_regulator_incremented > 1 Then
                    If REGPOS = 0 Then Exit Do
                    lower_reg 1
                    last_time_regulator_incremented = local_time
                End If
            Loop
            ' step 3, wait for pressure to rise above what we want,
            ' incrementing every 5 seconds if necessary
            ' minimum wait 20 seconds
            Do
                ReadXReturnX4 2
                progress.Line26.Caption = "3:P=" + Xformat$((x5 - P0) * PCNV, "###0.000  ") + PU$ + "  R=" + Format$(REGPOS)
                progress.Line26.Refresh
                local_time = Timer
                If local_time + 1 < last_time_regulator_incremented Then
                    last_time_regulator_incremented = last_time_regulator_incremented - 86400
                End If
                If (x5 - P0) >= 1 And (local_time - last_time_regulator_incremented) > 20 Then Exit Do
                If (x5 - P0) < 1 And (local_time - last_time_regulator_incremented) > lperm_init_wait Then
                    inc_reg 5
                    last_time_regulator_incremented = local_time
                End If
            Loop
            ' open valve 9 to let this pressure go to the penetrometer
            Move_Valve 8, "O"
            using_pressure = True
        End If
        If Drain12 Then
            Move_Valve 11, "O"
        Else
            Move_Valve 2, "O"
        End If
'    End If      'if special_ambient

' **********
' Begin Balance Not Penet code entered by Tim Richards on Tueday 6/15/04
'
    If g_bBalanceNotPenet = True Then
        Move_Valve 4, "C"
    End If
'
' End code entered by Tim Richards 6/15/04
' **********

    QueryPerformanceCounter startTime
    timestamp = startTime
        
    ' make "Turn" visible on progress screen
    progress.mainmenu(1).Visible = True
    HKey2$ = ""
        
3720
    T = Timer
    ReadXReturnX4 4                                   'read penetrometer transducer
    ' 50 counts in hardware version 6 is 2.25% of span below zero
    ' 20000 counts in hardware version 6 is 97.5% of span above zero
    If (x4 <= DAC_zero - DAC_span * 0.0225 Or x4 >= pen_max_counts) And Not Aborted Then GoTo 3720       'if out of range, reread
    h = x5      'height
    
3740
    lastH = h
    lastT = T
    lasttime = timestamp
    lastx4 = x4
    
3760
    T = Timer
    If using_pressure Then
        
        ReadXReturnX4 2
        progress.Line26.Caption = "P=" + Xformat$((x5 - P0) * PCNV, "###0.000  ") + PU$ + "  R=" + Format$(REGPOS)
        progress.Line26.Refresh
        P = x5 - P0
    End If
'    If special_ambient Then
'        ReadXReturnX4 0
'        ' don't increment the regulator when you have a low flow
'        ' controller - it won't help any
'        If low_flow_controller Then
'            If x5 < BUBLFLOW Then
'                inc_lfctrl 10
'            End If
'        Else
'            If x5 < BUBLFLOW Then
'                inc_reg 10
'            End If
'        End If
'
'        f = x5
'        ReadXReturnX4 2
'        P = x5
'    End If
    
    ReadXReturnX4 4                                         'read pene. transducer
    h = x5                                                  'height
    QueryPerformanceCounter timestamp
        
    difftime = time_difference(lasttime, timestamp)
        
    ' Write to the debugging log if appropriate
    If debugH20Perm Then
        fn = FreeFile
        Open "liqpermdebug_" + nowString$ + ".txt" For Append As #fn
        Print #fn, (P); ","; h; ","; time_difference(startTime, timestamp)
        Close #fn
    End If
        
' **********
' Begin Balance not Penetrometer code entered by search for Tim Richards on Monday June 21, 2004 9:38AM
' modify the progress line to read a 'tare' balance using coopted sample_zero_point
'
'    Progress_Output (P - real_atm) * PCNV, h, (ptarg - real_atm) * PCNV
'
' End Balance not Penetrometer code by Tim Richards 6/20/04
' **********

    ' 6.71.54 caption was not being updated properly - "=" was substituted for first "+", causing
    '  the entire expression to be a boolean, which displayed a value of "false"
    progress.Line25.Caption = s_local_BalanceNotPenet_Height_Mass + ":" + _
        Xformat$(h, "##0.00") + " " + s_local_BalanceNotPenet_gm_cm + "  " + ts$(74) + _
        ":" + Xformat$(difftime, "###0.0") + " " + ts$(245)     ' "Height"/"cm"/"Time"/"Sec."
    progress.Line25.Refresh
        
'    If special_ambient Then
'        progress.Line26.Caption = "P=" + Xformat$((P - P0) * PCNV, "###0.000  ") + PU$ + "   F=" + flowformat$(f) + " cc/min"       ' "cc/min"
'        progress.Line26.Refresh
'    End If
    
    If T + 0.1 < lastT Then lastT = lastT - 86400!                  'check for day change
    If Aborted Then Exit Function       ' GoTo END_PASS
    If x4 <= DAC_under Or x4 >= pen_max_counts Then    'if transducer is out of range
        'If points < 2 Then GoTo 3760 Else Exit Function     ' GoTo END_PASS             'end test if more than 2 points taken
        Exit Function ' 6.71.81 quit test even if less than 2 data points are taken
    End If
    If HKey2$ = "T" Then
        HKey2$ = ""
        Exit Function
    End If
    DoEvents
    ' 500 counts differential is 2.5% of span
    '  MsgBox (Str$(time_difference(lastAccurateTime, accurateTime)))
    If Abs(x4 - lastx4) < DAC_span * 0.025 Or (T - lastT < LP_mintime) Then GoTo 3760  'not enough dist. between last point or elapsed time
    If Second_Penetrometer And penetrometer_select = 2 Then
        VOL = P2CSECAREA * (lastH - h)                              'volume
    Else
        VOL = CSECAREA * (lastH - h)                                'volume
    End If
    
    DoEvents
    f = VOL / difftime * 60                                         'flow
    If f > 0.75 * MaxLQFlow(penetrometer_select) Then FlowFlag = True                    'check for 75% of max flow
'    If special_ambient Then
'        P = P - P0
'    ElseIf using_pressure = False Then
    If using_pressure = False Then
        P = 0
    End If
    ' if using_pressure=true we set P above
    
    If Second_Penetrometer And penetrometer_select = 2 Then
        P = P + (lastH + h) / 2 * P2PSIPERCM                        'pressure
    Else
        P = P + ((lastH + h) / 2 - sample_zero_point) * PSIPERCM                        'pressure
    End If
    
    ' 6.71.81 correct for lohm value
    P = P - (liquid_lohm(penetrometer_select) * f / 75700) ^ 2
    
    'if penetrometer has changed by 10cc from starting volume, allow it to record
    If f > 0 And P > 0 Then                                 'if p and f > 0, write them out
        points = points + 1
        dat_size_check x_array, points
        If points > 32000 Then Aborted = True
        x_array.a(points).fl = f
        x_array.a(points).pr = P + P0
        x_array.a(points).eqd = 0
        x_array.a(points).time = difftime
        
        'AJB 10-20-09 6.71.130
        If dryChamberTemperature <> 0 Then
            x_array.a(points).temp1 = readNewTemperature(dryChamberTemperature)
        End If
        
        If airTemperature <> 0 Then
            x_array.a(points).temp2 = readNewTemperature(airTemperature)
        End If
        'AJB 10-20-09 6.71.130
        
        If use_fluid_sensor Then
            ReadXReturnX4 27
            x_array.a(points).fluid = x5 - fluid_sensor_0
        End If
        
        If use_temperature Or recirculation Then read_temperature points, True
    End If
    
    took_point_time = Timer
    'update status bar
    progress.List1.AddItem Xformat$(h, "     #####0.000") + Xformat$(P * PCNV, "               #####0.000") + Xformat$(f, "         #####0.00")
    progress.List1.ListIndex = progress.List1.ListCount - 1
    progress.List1.ListIndex = -1
    pass = 1
    GoTo 3740       ' Loop back to get next point
        
End Function

' Purpose:
'          fill the array and update it as the new value arrives (FIFO method)
' Input:
'   pressureArray: the ray of parameters that should be modified
'   value:         is the parameter which will be inserted into the pressureArray
'   nCounter:      controls number of calls ( starts with 0)

Sub InsertNewValue(ByRef pressureArray() As Double, ByVal value As Double, ByVal nSize As Integer, ByVal nCounter As Integer)
    Dim i%
        
    If (nCounter <= nSize) Then
        pressureArray(nCounter) = value
    Else
        For i = 1 To nSize
            pressureArray(i - 1) = pressureArray(i)
        Next i
            pressureArray(nSize) = value
    End If

End Sub

'Purpose:
'           To calculate mean value of the array
'Input:
'pressureArray: an array which plays the role of stack
'nSize:         size of the array (it could be part of array elements)
'nCounter:      number of elements in the array which are not zero
'
'OutPut:
'           Returns the mean value of the array elements
Function getMeanValue(ByRef pressureArray() As Double, nSize As Integer, nCounter As Integer) As Double
    Dim i%
    Dim sum As Double
    
    ' get the sum
    sum = 0
    For i = 0 To nSize
        sum = sum + pressureArray(i)
    Next i%
    
    ' calculate the mean
    If (nCounter < nSize) Then
        getMeanValue = sum / nCounter
    Else
        getMeanValue = sum / (nSize + 1) 'a.k.a VB6 array size
    End If
    
    Exit Function
End Function


'Purpose:
'           To calculate standard deviation of the array elements (sample)
'Input:
'pressureArray: an array which plays the role of stack
'nSize:         size of the array (it could be part of array elements)
'nCounter:      number of elements in the array which are not zero
'
'OutPut:
'           Returns the standard deviation of the array elements

Function getStandardDeviation(ByRef pressureArray() As Double, ByVal nSize As Integer, ByVal nCounter As Integer) As Double
    Dim i%
    Dim sum  As Double
    Dim sum2 As Double
    Dim mean As Double
    Dim error As Double
    Dim error2 As Double
    Dim nElements As Integer

    ' sanity check
    If (nCounter < 2 Or nSize < 2) Then
        getStandardDeviation = error
        Exit Function
    End If

'   init
    error = 0
    If (nCounter < (nSize + 1)) Then
        nElements = nCounter
    Else
        nElements = nSize + 1
    End If
    
    
    ' get the sum's
    sum = 0
    For i = 0 To (nElements - 1)
        sum = sum + pressureArray(i)
        sum2 = sum2 + pressureArray(i) * pressureArray(i)
    Next i%
    
    ' calculate the mean and standard deviation
    mean = sum / nElements
    error2 = sum2 / (nElements - 1) - (nElements * mean * mean) / (nElements - 1)
    If (error2 < 0) Then error2 = 0
    error = Sqr(error2)
    
    getStandardDeviation = error
    
    Exit Function

End Function

Sub Run_C_Pass(x_array As dat_array)
    
    Dim geoPoreStuff As Boolean
    Dim preg_fact As Single
    Dim p5 As Single
    Dim f5 As Single
    Dim CHFACTR As Single
    Dim BBHigh As Single
    Dim T As Single
    Dim X As Single
    Dim SP As Single
    Dim EF As Single
    Dim brokenCrap As Integer
    
    Dim k As Single
    Dim lowered As Integer
    Dim lastp As Single
    Dim lastf As Single
    Dim lastflow As Single
    Dim LastFIncTime As Single
    Dim diffp0 As Single
    Dim Possible_BP_Pressure As Single
    Dim local_time As Single
    Dim curtime As Single
    Dim elapsed As Single
    Dim hitpoint As Single
    Dim F_at_2 As Single
    Dim T_at_2 As Single
    Dim flow_at_2 As Single
    Dim pres_at_2 As Single
    Dim PX4 As Long
    Dim flow_at_last_pressure_fall_back As Single
    Dim special_pulse As Boolean, hfbp As Boolean, hittimes%, diffpgbase%, eqdone%
    Dim possibleErrorHits%
    Dim initial_offset%, i%
    Dim x1first_lockin As Boolean, num_times_reversed%, num_times_reversed_p%
    Dim BADINDEX%
    Static BUBBLEPT As Single
    
'    Dim m_nBPPressureArraySize As Integer
    Dim m_fBPPressureArray() As Double
    Dim m_fBPPressureUsingSpread As Double
    Dim m_fBPPressureUsingMean As Double
    Dim m_fBPCurrentMeanPressure As Double
    Dim m_fBPCurrentStandardDeviation As Double
    Dim m_fBPPreviousStandardDeviation As Double
    Dim m_fBPMaxMeanPressure As Double
    Dim m_fBPMaxStandardDeviation As Double
    Dim m_nBPPressurePointCounter As Integer
    
    Dim FSTART As Single
    Dim fmin As Single
    Dim fmax As Single
    Dim flowmin As Single
    Dim FTPOINT As Single
    Dim f0 As Single
    Dim f1 As Single
    Dim f1X4 As Long
    Dim f2 As Single
    Dim f2X4 As Long
    ' these are now declared in the module header since hold needs to reset them
    'Dim LastFlowTime As Single
    'Dim FlowN As Single
    'Dim fsum As Single
    Dim maxdflow As Single
    Dim PStart As Single
    Dim PMax As Single
    Dim pt As Single
    Dim p1 As Single
    Dim p2 As Single
    Dim P1X4 As Long
    Dim P2X4  As Long
    Dim P3 As Single
    Dim P3X4 As Long
    Dim PSUM As Single
    Dim PMin As Single
    Dim REGOUT As Integer
    Dim TPoint As Single
    Dim X0 As Single
    Dim x1 As Single
    Dim max_val_p As Single
    Dim ii%
    Dim tempval As Single
    Dim tempPres As Single
    Dim runefdjump As Boolean
    Dim hfbp_ebpp_toggle As Boolean
    Dim time_to_bubble As Single
    Dim eqstarttime As Single
    Dim best_seen_low_pressure As Single
    Dim max_p_drop_seen As Single
    Dim fn1 As Integer
    Dim temp1 As Single, temp2 As Single
    Dim time As Date
    Dim num_times_kicked_flow As Integer
    Dim current_ip_pressure_target As Single
    Dim fn3 As Integer
    Dim dont_reopen_valve_20 As Boolean
    ' pressure_steps moved to global section
    Dim step_index As Integer
    Dim ptemp$
    Dim fn4 As Integer
    Dim fn5 As Integer
    using_low_regulator = True
    ' 6.71.20 new variable
    Dim temp_hflow%
    ' 6.71.33
    Dim last_pres% ' last value of pres% when we read the pressure.  This is so we know when we change pressure ranges
                ' so we don't trigger a false bubble point reading
    Dim runGP_SinglePoint As Boolean        ' Flag for doing a single point test with GP
    Dim l_temp As Long ' for internal use when we need an intermediate value that may be long
    '  6.71.53
    Dim usingWetSample As Boolean   ' Used to determine if UpdateLine25 should display pore diameter during test or not
    Dim BPTLFirstPointTime As Single
    Dim BPTLLastPointTime As Single
    ' 6.71.83
    Dim preg_start_point As Long
    ' 6.71.86
    Dim justSwitchedRegulators As Boolean ' true only if we just switched regulators and haven't taken a good data point with the new regulator yet.
      '06-11-07 edc
    Dim firstRun As Boolean     'true if first run of the BLOOP routine for bubble point
    Dim currPoint(1, 200) As Single    '0 = pressure 1 = flow
    Dim count As Integer
    Dim currentTime As Single
    Dim lasttime As Single
    Dim startFPT As Single
    Dim startTime As Single
    'JF added 7/1/2011 for Delta FPT
    Dim lastFPT As Single
    Dim lastFPTTime As Single
    Dim currFPT As Single
    Dim currFPTTime As Single
    Dim deltaFPT As Single
    Dim possibleBP As Boolean
    Dim prevXLabel As String
    Dim prevYLabel As String
    Dim prevXMax As String
    Dim prevYMax As String
    Dim BP_Array As dat_array
    
    'JF added 7-23-2009 for Gurley
    Dim regulator_increment_value As Integer
    Dim regulator_initial_value As Integer
    Dim previous_pressure_reading As Single
    Dim current_pressure_reading As Single
    Dim pressure_increase As Single
    Dim target_pressure As Single
    Dim remaining_pressure_difference As Single
    Dim usermsgres As VbMsgBoxResult
    
    Dim timediff As Single
    Dim outStr As String
    Dim mfDebugFile As Integer
    
    Dim mainDebugFile As Integer
    
    'Variables for Microflow
    Dim previousRegPos As Integer
    Dim absPAtmos As Single
    Dim diffPAtmos As Single
    Dim currentPressureIncrease As Single
    
    'JF added 11-1-2010 for Microflow Debug Data
    Dim initAbsP As Single
    Dim finalAbsP As Single
    Dim initDiffP As Single
    Dim initDiffP0 As Single
    Dim finalDiffP As Single
    Dim diffAbsP As Single
    Dim diffDiffP As Single
    Dim switchingToCapFlowSide As Boolean
    Dim frazierDelayTime As Integer
    
    Dim progressBoxBackup As PictureBox
    
    Dim BPEndTime     As Double
    Dim BPCurrentTime As Double
    Dim BPPrevTime    As Double
    Dim BPStartTime   As Double
    
    'JF added for END_PASS Debugging
    Dim endPassCause As Integer
    Dim BPPrevPressure As Double
    
    Dim alreadyDidThat As Boolean
    
    alreadyDidThat = False
  
    lowered = 0
    ' initialaize BP parameters
    BPStartTime = Timer
    BPPrevPressure = -1
    BPPrevTime = -1
    m_nBPPressurePointCounter = 0
    m_fBPCurrentMeanPressure = 0
    m_fBPCurrentStandardDeviation = 0
    m_fBPPreviousStandardDeviation = 999999
    m_fBPMaxMeanPressure = -1 'do not panic
    m_fBPMaxStandardDeviation = -1
    m_fBPPressureUsingMean = -1
    m_fBPPressureUsingSpread = -1
    
    
    ReDim m_fBPPressureArray(m_nBPPressureArraySize)
    
    Dim iCounter%
    For iCounter = 0 To m_nBPPressureArraySize
        m_fBPPressureArray(iCounter) = 0
    Next iCounter%
    
    geoPoreStuff = False
    
    If debugRunCPass Then
        MsgBox "Debugging Run C Pass"
        mainDebugFile = 50
        Open EXE_Path$ + "runCPass_Debug.log" For Output As #mainDebugFile
        Print #mainDebugFile, "1     RUNNING: " + str$(RUNNING) + "     regnum: " + str$(regnum)
    End If
    
    mfDebugFile = -1 ' value to signify the file is not open
    switchingToCapFlowSide = False
    
    If threestagetest(current_unit%) Then
        diffpgflow(current_unit%) = True
    End If
    
    If diffpgflow(current_unit%) Then
        If debugRunCPass Then Print #mainDebugFile, "2"
        If Num_Microflow_Volumes > 1 Then
            If microFlowUseAllVolumes Then
                Current_Microflow_Volume_Index = 1
                progress.lblMicroflowVolume.Caption = "Volume " + str(Current_Microflow_Volume_Index)
                update_microflow_volume_valves
            Else
                progress.lblMicroflowVolume.Caption = "Volume " + str(Current_Microflow_Volume_Index)
            End If
        End If
        
        'progress.lblMicroflowVolume.Caption = "Volume " + str(Current_Microflow_Volume_Index)
        'Close valve 10 so there is no restriction to pressure
        
        Move_Valve 9, "O"
        
        'Now we need to get the values of both pressure gauges at atmospheric pressure
        previousRegPos = REGPOS
        Zero_Reg
        Move_Valve 13, "O"
        waitseconds 10
        ReadXReturnX4 2
        absPAtmos = x5
        ReadXReturnX4 13 + dpgplus%
        diffPAtmos = x5
        Move_Valve 13, "C"
        inc_reg previousRegPos
        
        mfDebugFile = FreeFile
        Open "microflowdebug.log" For Output As #mfDebugFile
    End If
    
    
    If hasHumidityControls And enableHumidityControlForAutoTests Then
        If debugRunCPass Then Print #mainDebugFile, "3"
    
        If TType(current_unit%) = 1 Or TType(current_unit%) = 2 Then
            afterBubblePoint = False
            Move_Valve 3, "O" 'close bubbler enable
        Else
            afterBubblePoint = True
            Move_Valve 3, "C" 'open bubbler enable
        End If
        
        Move_Valve 2, "C" 'close vent valve
        
        Open "hdata.txt" For Output As #55
        Print #55, ""
        Print #55, "FLOW" & Chr(9) & "PRESSURE" & Chr(9) & "HUMIDITY" & Chr(9) & "BUBBLER POS" & Chr(9) & "GoToHumidity Counter" & Chr(9) & "GoToHumidity Timer" & Chr(9) & "Reg. Pos" & Chr(9) & "MV2 Pos." & Chr(9) & "lfc Pos."
        goToHumidityCounter = 0
        
    ElseIf hasHumidityControls Then
        If debugRunCPass Then Print #mainDebugFile, "4"
        
        Move_Valve 3, "O" 'close bubbler enable
        Move_Valve 2, "C" 'close the damn vent valve
    End If
    
    startTime = 60
    startFPT = 50
    firstRun = True ' initialize variables and arrays for the bubble point graph
    count = 0
    
    justSwitchedRegulators = False
    If regnum = 0 Then
        fifty_or_seven = 50
    Else
        fifty_or_seven = 7
    End If
    
    fn5 = FreeFile
    Open EXE_Path$ + "PreBPdata.dat" For Output As #fn5
    If TMode%(current_unit%) = 3 Then
        Print #fn5, ts$(30) + "(cc/min)"; vbTab; ts$(229) + "(" + PU$ + ")"; vbTab; ts$(277); vbTab; _
            ts$(273); vbTab; ts$(276); vbTab; ts$(274); vbTab; "F/PT " + ts$(275)
'        Print #fn5, ts$(273); vbTab; ts$(274); vbTab; ts$(75); vbTab; "F/PT " + ts$(275); vbTab; ts$(276); vbTab; _
'            ztempPressure$; vbTab; ztempFlow$; vbTab; ztempDiam$
    Else
        Print #fn5, ts$(30) + "(cc/min)"; vbTab; ts$(229) + "(" + PU$ + ")"; vbTab; ts$(277); vbTab; _
            ts$(273); vbTab; ts$(276); vbTab; ts$(274); vbTab; "F/PT " + ts$(275); vbTab; "Delta F/PT " + ts$(275)
'        Print #fn5, ts$(273); vbTab; ts$(274); vbTab; "Torr"; vbTab; "F/PT " + ts$(275); vbTab; "Delta F/PT"; vbTab; ts$(276); vbTab; _
'            ztempPressure$; vbTab; ztempFlow$; vbTab; ztempDiam$
    End If
    Close #fn5


    ' Check to see if we want to do a single point gas perm test
    runGP_SinglePoint = (GP_singlePointTest And TType%(current_unit%) = 3)
    ' if we're using a pressure step list, why not load it here?
    If PS_usingList Or runGP_SinglePoint Then
        If debugRunCPass Then Print #mainDebugFile, "5"
        If PS_usingList Then
            If debugRunCPass Then Print #mainDebugFile, "6"
        
            If (PS_path = "") Then
                ' Open a file box for the user
                fsel_path$ = EXE_Path$ + "\parms\*.psl"
                fsel_title$ = ts$(497)      ' "Choose pressure list"
                fsel_name$ = ""
                fsel_io = True
                fsel TitleScrn.hwnd
                
                If fsel_return = "" Then Exit Sub
                PS_path$ = fsel_return
            End If
        
            ' Pathname should be valid now
            fn4 = FreeFile
            Open PS_path$ For Input As #fn4
            Input #fn4, ptemp$
            With pressure_steps
                .count = val(Right$(ptemp$, Len(ptemp$) - 1))
                ReDim .values(.count)
                For i = 1 To .count
                    Input #fn4, ptemp$
                    .values(i) = val(ptemp$) / PCNV
                Next i
            End With
            Close #fn4
        
        ElseIf runGP_SinglePoint Then
            If debugRunCPass Then Print #mainDebugFile, "7"
        
        ' "hijack" the list structure to enter our single point for the test
            With pressure_steps
                .count = 1
                ReDim .values(.count)
                .values(1) = GP_target

            End With
        End If
        
        step_index = 1
    End If
    
    If debugRunCPass Then Print #mainDebugFile, "8     RUNNING: " + str$(RUNNING) + "     regnum: " + str$(regnum)
    
    dont_reopen_valve_20 = False
    best_seen_low_pressure = 0      ' used in minimum pressure equilibrium skipping routine
    max_p_drop_seen = 0             ' used in minimum pressure equilibrium skipping routine
    runefdjump = True
    ' maxdflow is the maximum difference in flow that we have
    ' seen at the beginning of the test which tells us the
    ' amount of increase in flow that we should continue to see
    ' at every data point we check to see if we have a new maxdflow.
    ' If we don't, we increase v2factr by .1.  When v2factr=1.5 we
    ' stop checking for a new maxdflow but still check to increment v2factr
    maxdflow = 0: BADINDEX% = 1
    reply% = 0
    If PULSEWIDTH = 0 And v2solenoid = False Then special_pulse = True
    preg_fact = 1
    p5 = 0
    f5 = 0
    
    ' figure out if the routine should show pore diameter during testing
    usingWetSample = (TType%(current_unit%) < 3)
    
    'temp1 = TType%(current_unit%)
    'temp2 = TMode%(current_unit%)
    'If temp1 = 1 Then           ' CFP
    '    If pass = 0 Then                        ' first stage of test
    '        usingWetSample = (temp2 = 3 Or temp2 = 7)    ' others have wetted sample
    '    ElseIf pass = 1 Then
    '        usingWetSample = (temp2 <> 3 And temp2 <> 7)
    '    End If
    'Else
    '    usingWetSample = (temp1 = 2)
    'End If
  '  If usingWetSample Then MsgBox ("wet") Else MsgBox ("dry")
  
    ' if not WUDU and second stage or WUDD second stage ...
    Call Move_Valve(14, "O")
    If Not ((TMode%(current_unit%) = 2 And TType%(current_unit%) = 1 And pass = 2) Or (TMode%(current_unit%) = 1 And TType%(current_unit%) = 1 And pass = 2)) Then
        If Not nowait_at_beginning Then reply% = MsgBox(ts$(190), 1, ts$(223))          ' "Press OK to start test."/"Test Setup"
    End If
    If reply% = 2 Then Aborted = True: Exit Sub
    
    If Not ((TType%(current_unit%) = 1) And (TMode%(current_unit%) = 1)) Then
        If debugRunCPass Then Print #mainDebugFile, "9     RUNNING: " + str$(RUNNING) + "     regnum: " + str$(regnum)
        LastPr = 0
        LastFl = 0
    End If
    BBHigh = 0

    If debugRunCPass Then Print #mainDebugFile, "10     RUNNING: " + str$(RUNNING) + "     regnum: " + str$(regnum)

    RunTimer = Timer
    progress.Timer1.Interval = 2000
    progress.Timer1.Enabled = True
    HKey$ = ""
    HKey2$ = ""
    If First_Curve Then
    'DAMMIT
        GMaxP = STARTP
        progress.Picture1.Scale (0, STARTF / 1000)-(STARTP, 0)
    End If
    progress.Refresh
    'If temperature% > 0 Or using_watlow = True Then
    If dryChamberTemperature <> 0 Then
        fn3 = FreeFile
        Open EXE_Path$ + "tempdata" + Format$(pass%) + ".txt" For Output As #fn3
    End If
    If PROGRAMCTRL = 3300 Then GoTo 3299
    
    ' handle liquid permeability test (ambient or elevated)
    If TType%(current_unit%) = 4 Then
        If debugRunCPass Then Print #mainDebugFile, "11"
        
        dont_reopen_valve_20 = Run_Ambient_LqPerm(x_array)
        If ip_reg_enable And (PEN20500 < 0) Then
            ' just in case, close valve 9
            Move_Valve 8, "C"
        End If
        endPassCause = 1
        GoTo END_PASS
    End If  ' liquid perm test
     
    ' handle resin tests
    If TType%(current_unit%) = 7 Then
        If debugRunCPass Then Print #mainDebugFile, "12"
    
        If Resin_Diverter_Valve > 0 Then
            Run_Resin_Test
            endPassCause = 2
            GoTo END_PASS
        Else
            MsgBox "Please verify that the resin system is installed"
            endPassCause = 3
            GoTo END_PASS
        End If
    End If
     
    'integrity test
    If TType%(current_unit%) = 2 And TMode%(current_unit%) = 2 And integrity Then
        If debugRunCPass Then Print #mainDebugFile, "13"
        Debug.Print "Is integrity"
        lflow% = 1
        ReadXReturnX4 0
        FLAST = x5
        ReadXReturnX4 2
        DoEvents
        plast = x5
        If AirTop Then
            Move_Valve 19, "C"
        End If
        OPENV2MOSTLY
        ReadXReturnX4 FUSE%
        f = x5
        ReadXReturnX4 2
        P = x5
        ReadXReturnX4 3
        DoEvents
        UpdateLine25 usingWetSample
        
        
        
        If P > BBHigh Then BBHigh = P
        If (newreg = False And ip_reg_enable = False) Then
            If debugRunCPass Then Print #mainDebugFile, "14"
            Rem for version < 6, initial point of the regulator is
            Rem the number of clicks that are entered on the bublflow
            Rem table.
            If REGPOS < 0 Then REGPOS = 0
            manrunning = True
            While REGPOS < BUBLFLOW - 1: inc_reg 1: Wend
            manrunning = False
            inc_reg 1
        ElseIf newreg Then
            If debugRunCPass Then Print #mainDebugFile, "15"
        
            Rem for version 6, initial point of the regulator is
            Rem the position that gives pressure (in PSI) equal to
            Rem the bublflow parameter.  This is similar to older
            Rem versions.  This requires that the regulator has been
            Rem calibrated.  If the regulator is not calibrated,
            Rem simply move it to a percentage open equal to the bublflow
            If reg_table_size%(regnum) = 0 Then
                ii% = BUBLFLOW * (reg_ol - reg_cl) / 100# + reg_cl
                'MsgBox "Opening regulator by percentage to " + Str$(ii%)
                reg_goto (ii%)
            Else
                move_motorized_regulator_to_pressure (BUBLFLOW)
            End If
        ElseIf ip_reg_enable Then
            If debugRunCPass Then Print #mainDebugFile, "16"
            ' initial point of the regulator is the position that gives pressure
            ' (in PSI) equal to the bublflow parameter
            If reg_table_size%(regnum) = 0 Then
                ' use a percentage of the range (4000/100)
                l_temp = BUBLFLOW * 40
            Else
                l_temp = regpos_from_p(BUBLFLOW)
            End If
            If l_temp > 4000 Then l_temp = 4000
            If REGPOS < l_temp Then inc_reg l_temp - REGPOS
        End If
        ' set to initial test pressure
        ' clear regulator and then set it to ITP
        ' assume regulator is already cleared
        If reg_table_size%(regnum) > 0 Then
            If debugRunCPass Then Print #mainDebugFile, "17"
            If newreg Then
                move_motorized_regulator_to_pressure (ITP)
            ElseIf ip_reg_enable Then
                l_temp = regpos_from_p(ITP)
                If l_temp > 4000 Then l_temp = 4000
                If REGPOS < l_temp Then inc_reg l_temp - REGPOS
            End If
        End If
topITP:
        If debugRunCPass Then Print #mainDebugFile, "18"

        ReadXReturnX4 2
        'T = Timer
        'While (Timer - T) < 3: DoEvents: Wend
        waitseconds 3
        P = x5
        UpdateLine25 usingWetSample
        If P > BBHigh Then BBHigh = P
        If Not Aborted And x5 < ITP + P0 Then
            inc_reg 10
            GoTo topITP
        End If
        GoSub WAITINITIAL
4600
        If debugRunCPass Then Print #mainDebugFile, "19"

        GoSub WAITINITIAL
        PROGRAMCTRL = 4600
        GoSub 3310
        PROGRAMCTRL = 0
        If x4 = DAC_over Then
            endPassCause = 4
            GoTo END_PASS
        End If
        If Aborted Then
            endPassCause = 5
            GoTo END_PASS
        End If
        NOWHERE% = NOWHERE% + 1
        DoEvents
        If NOWHERE% > 299 Then
            endPassCause = 6
            GoTo END_PASS
        End If
        ' 200 counts differential is 1% of span
        If P <= plast And V2POS > SV2P + DAC_span / 100 Then inc_reg 10: GoTo 4600
        points = points + 1
        dat_size_check x_array, points
        If points > 32000 Then HKey2$ = "T"
        x_array.a(points).fl = f
        If x_array.a(points).fl <= 0 Then x_array.a(points).fl = 0
        x_array.a(points).pr = P
        x_array.a(points).eqd = 0
        x_array.a(points).time = Timer
        
        'AJB 10-20-09 6.71.130
        If dryChamberTemperature <> 0 Then x_array.a(points).temp1 = readNewTemperature(dryChamberTemperature)
        If airTemperature <> 0 Then x_array.a(points).temp2 = readNewTemperature(airTemperature)
        'AJB 10-20-09 6.71.130
        
        'TJM 3-23-2010 start
        If hasHumidityControls And enableHumidityControlForAutoTests Then
            If debugRunCPass Then Print #mainDebugFile, "20"
            
            goToTargetHumidity
            
            'ReadXReturnX4 1 're-read current flow
            'x_array.a(points).fl = x5
            
            'ReadXReturnX4 2 're-read current pressure
            'x_array.a(points).pr = x5
            
            x_array.a(points).humidity = lastGoodHumidity
            
            Print #55, x_array.a(points).fl & Chr(9) & x_array.a(points).pr & Chr(9) & x_array.a(points).humidity & Chr(9) & Format$(getBubblerMVPosition(), "##0.00%") & Chr(9) & goToHumidityCounter & Chr(9); goToHumidityWaitTimeCounter & Chr(9) & REGPOS & Chr(9) & Format$(getMV2Position(), "##0.00%") & Chr(9) & lfcpos
            
        ElseIf hasHumidityControls And recordHumidityForAutoTests Then
            'just read humidity sensor and record the point, don't try to correct the humidity by calling goToTargetHumidity
            x_array.a(points).humidity = readHumiditySensor
        End If
        'TJM 3-23-2010 end
        
        If use_fluid_sensor Then
            ReadXReturnX4 27
            x_array.a(points).fluid = x5 - fluid_sensor_0
        End If
        took_point_time = Timer
        Scr_Refresh x_array
        FLAST = f: plast = P: pass = 1
        If P - P0 > Maxpres Or f > MAXFLOW Or HKey2$ = "T" Then
            HKey$ = " "
            HKey2$ = " "
            endPassCause = 7
            GoTo END_PASS
        End If
        If Pres% = 1 Then TPoint = P
        NOWHERE% = 0
        DoEvents
        Rem set manrunning true for all but last increment
        Rem in version 6 this causes inc_reg to return without
        Rem waiting.  It will then wait after the last inc_reg
        Rem in older versions, this has no effect.
        ' 6.71.20 begin
        If ip_reg_enable And REGPOS >= 4000 Then
            If debugRunCPass Then Print #mainDebugFile, "21"
            ' if we are already at 4000 counts, see if we can switch regulators
            If dualregulator And using_low_regulator Then
                If debugRunCPass Then Print #mainDebugFile, "Switch Regulators 1"
                 'decrease regulator to the second_regulator_starting_point
'                lower_reg 4000 - second_regulator_starting_point
'                waitseconds 3
'                Move_Valve 16, "O"
'                waitseconds 10
'                regnum = 1
'                fifty_or_seven = 7
'                SBPP = SBPP2
'                SHFP = SHFP2
'                using_low_regulator = False
                SwitchRegulators "1"
                GoTo 4600 ' skip next pressure regulator increment
            Else
                ' we might as well end the test since we can't go up any more
                HKey$ = " "
                HKey2$ = " "
                endPassCause = 8
                GoTo END_PASS
            End If
        End If
        ' 6.71.20 end
        manrunning = True
        inc_reg Int(preginc * fifty_or_seven)
        'For REGOUT = 1 To Int(preginc) - 1
        '    inc_reg fifty_or_seven
        'Next REGOUT
        '' for version 7, this will increment by (int(preginc)-1)*50
        '' so we still need to go up by (preginc-int(preginc)+1)*50
        '' this can't be larger than 100
        '' for version < 7, this will increment by preginc-1
        '' and we only need to increment one more time
        'manrunning = False
        'inc_reg (preginc - Int(preginc) + 1) * fifty_or_seven
        GoTo 4600

WAITINITIAL:
        If debugRunCPass Then Print #mainDebugFile, "24"

        T = Timer
4920
        If debugRunCPass Then Print #mainDebugFile, "25"

        ReadXReturnX4 2
        P = x5
        lflow% = 1
        ' ReadXReturnX4 FUSE%
        
        ReadXReturnX4 0
        
        
        f = x5
        UpdateLine25 usingWetSample
        If P > BBHigh Then BBHigh = P
        DoEvents
        If Aborted Then Return
        If Timer + 0.1 < T Then T = T - 86400
        If Timer - T < BUBLTIME Then GoTo 4920
        Return
    End If
    'Debug.Print "Is not Integrity" 'AJB 10-05-09
    'hfbp = False
    If (BUBLFLOW <= MaxLowFlow) Or _
       (TType%(current_unit%) = 3) Or _
       (TType%(current_unit%) = 1 And pass = 2) Or _
       (TType%(current_unit%) = 2 And TMode%(current_unit%) = 2) Then
       'GoTo 3150
       hfbp = False
    Else
        hfbp = True
    End If
    'hfbp = True
'original BP routine
3150
        If debugRunCPass Then Print #mainDebugFile, "26     RUNNING: " + str$(RUNNING) + "     regnum: " + str$(regnum)

    ' this has been updated to use the high flow meter if necessary
    ' this has been further updated to do TType%=2, TMode%=3 HydroHead test
    If hfbp Then
        If debugRunCPass Then Print #mainDebugFile, "27"
    
        Debug.Print "Into hfbp" 'AJB 10-05-09
        FUSE% = 1
       
        If xhflow And BUBLFLOW > FY2(1, 0) * gasflowconversionfactor Then
            hfmin% = 2: HFLOW% = 3
        Else
            hfmin% = 0: HFLOW% = 1
        End If
        Rem re-zero the high flow meter now
        HFLOW% = hfmin%
        
        ReadXReturnX4 1
        
        
        If x4 < 3 Then
            MsgBox ts$(212) + vbCrLf$ + ts$(19)        ' "Warning: The High Flow"/"is not calibrated correctly"
        End If
        FX1(1, hfmin%) = x4
        FY1(1, hfmin%) = 0
        FX2(1, hfmin%) = x4 + DAC_span
        Rem zero high range of high flow meter being used
        HFLOW% = hfmin% + 1
        ReadXReturnX4 1
        If x4 < 3 Then
            MsgBox ts$(212) + vbCrLf$ + ts$(19)      ' "Warning: The High Flow"/"is not calibrated correctly"
        End If
        FX1(1, HFLOW%) = x4
        FY1(1, HFLOW%) = 0
        FX2(1, HFLOW%) = x4 + DAC_span
    Else
 
            FUSE% = 0
          
    End If
    ReadXReturnX4 FUSE%
    FLAST = x5
    ReadXReturnX4 2
    plast = x5
    If TType%(current_unit%) = 2 And TMode%(current_unit%) = 3 Then
        If debugRunCPass Then Print #mainDebugFile, "28     RUNNING: " + str$(RUNNING) + "     regnum: " + str$(regnum)
        Rem HydroHead test
        ' Move_Valve now updates vpos so we don't need to
        If externalhydrohead Then
            If debugRunCPass Then Print #mainDebugFile, "29"
        
            ' open external pressure
            Move_Valve 11, "O"
            ' close external vent
            Move_Valve 13, "C"
            Move_Valve 12, "C" ' also close "fill" since miswired
        ElseIf (hhRunAsMullen(current_unit%) And mullen_penetrometer > 0) Or _
                (hydrohead_penetrometer > 0) Or (burst_penetrometer > 0) Then
            If debugRunCPass Then Print #mainDebugFile, "29A"
        
            ' normal hydrohead through the penetrometer on a non-airtop
            ' machine
            Dry_Chamber_Control "C" ': vpos(4) = 1
            Move_Valve 8, "O" ': vpos(9) = 1
            If Drain12 Then
                Move_Valve 11, "O"
            Else
                Move_Valve 2, "O" ': vpos(3) = 1
            End If
        ElseIf AirTop Then
            If debugRunCPass Then Print #mainDebugFile, "30     RUNNING: " + str$(RUNNING) + "     regnum: " + str$(regnum)
        
            ' for airtop machines, you use the normal air flow, not
            ' the penetrometer
            Dry_Chamber_Control "O" ' close path to penetrometer
            ' don't care what you do with the penetrometer venting valve
            ' if there is a drain valve, open it to allow flow out of
            ' the sample chamber bottom
            If Drain12 Then Move_Valve 11, "O"
            ' close the venting valve
            Move_Valve 2, "C"
        ElseIf PEN20500 < 0 Then
            If debugRunCPass Then Print #mainDebugFile, "31"
        
            ' new for Seika Toyota - hydrohead with air from bottom of air
            ' sample chamber, through external tube, and down into liquid
            ' sample chamber.
            Dry_Chamber_Control "O" ' close path to penetrometer
            Move_Valve 8, "C" ' vent penetrometer
            Move_Valve 11, "O" ' open valve 12, if it is there
            Move_Valve 2, "C" ' close the venting valve
            Move_Valve 19, "O" ' open isolation valve between liquid chamber and penetrometer
            If recirculation Then Move_Valve 20, "O" ' open isolation valve between penetrometer and valve 9
        Else ' old normal air bottom machine
            If debugRunCPass Then Print #mainDebugFile, "32"
        
            ' normal hydrohead through the penetrometer on a non-airtop
            ' machine
            Dry_Chamber_Control "C" ': vpos(4) = 1
            Move_Valve 8, "O" ': vpos(9) = 1
            If Drain12 Then
                Move_Valve 11, "O"
            Else
                Move_Valve 2, "O" ': vpos(3) = 1
            End If
        End If
    End If
'"NORMAL BUBBLE POINT Test starts Here"
    
    If Not hfbp Then
        If debugRunCPass Then Print #mainDebugFile, "33     RUNNING: " + str$(RUNNING) + "     regnum: " + str$(regnum)
    
        ' open valve 1 to start normal bubble point
        Move_Valve 0, "O"
        If low_flow_controller Then
            ' keep the low flow controller at zero for now
            zero_lfctrl
            Debug.Print "low flow controller true" 'AJB 10-05-09
            'set_low_flow_rate BUBLFLOW
        End If
        'vpos(1) = 1
    End If
    If debugRunCPass Then Print #mainDebugFile, "34     RUNNING: " + str$(RUNNING) + "     regnum: " + str$(regnum)
    
    
    PMax = 0
    fmax = 0
    DoEvents
    ReadXReturnX4 FUSE%
    f = x5

    ReadXReturnX4 2
    P = x5
    ReadXReturnX4 3
    If autocompress And compression_pressure <> 0 And Compression_Increase_Factor > 0 Then test_compression_pressure P - P0
    UpdateLine25 usingWetSample
    If P > BBHigh Then BBHigh = P
    If TType%(current_unit%) = 3 Or (TType%(current_unit%) = 1 And pass = 2) Then GoTo 3251
    
    ' now for new bubble point. bublflow is now used for minimum flow during pressurization.  bubltime time it must remain stable
    If EBPP > 0 And hfbp = False Then
        If debugRunCPass Then Print #mainDebugFile, "35     RUNNING: " + str$(RUNNING) + "     regnum: " + str$(regnum)
    
        Debug.Print "EBPP > 0 && hfpb = False"
        ' for now you can't do high flow bubble point with estimated bubble point pressure greater than 0
        ' program will not prompt for EBPP if high flow test is selected
        GoSub 3500
        If low_flow_controller Then
            If debugRunCPass Then Print #mainDebugFile, "36     RUNNING: " + str$(RUNNING) + "     regnum: " + str$(regnum)
        
            ' just in case, the low flow controller should be zeroed now
            zero_lfctrl
            ' now increase the regulator to test pressure
            If ip_reg_enable Then
                If debugRunCPass Then Print #mainDebugFile, "37     RUNNING: " + str$(RUNNING) + "     regnum: " + str$(regnum)
            
'                ' set the regulator at the maximum pressure for this test
'                i% = regpos_from_p(0) ' start with the zero point of the regulator
'                If i% < 0 Then i% = 0 ' but not less than zero counts
'                ' we subtract the zero point from SBPP because SBPP already includes
'                ' the zero point of the regulator and so does regpos_from_p and we
'                ' don't want to add it in twice.  (If the zero point is actually zero,
'                ' this won't make any difference, but if the zero point is high, if
'                ' we don't correct for this we may increase the regulator too much.)
'                i% = regpos_from_p(Maxpres) + SBPP - i%
                ' set the regulator to the ebpp + max_bp_pres_dif
                ' derate max_bp_pres_dif by absolute pressure in atmospheres
                current_ip_pressure_target = EBPP + max_bp_pres_dif / (1 + EBPP / 14.7)
                l_temp = regpos_from_p(current_ip_pressure_target)
                ' 6.71.22 begin
                If l_temp > 4000 Then
                    If debugRunCPass Then Print #mainDebugFile, "38     RUNNING: " + str$(RUNNING) + "     regnum: " + str$(regnum)
                
                    If dualregulator And using_low_regulator Then
                        If debugRunCPass Then Print #mainDebugFile, "39     RUNNING: " + str$(RUNNING) + "     regnum: " + str$(regnum)
                    
                        If REGPOS > second_regulator_starting_point Then
                            lower_reg REGPOS - second_regulator_starting_point
                            waitseconds 3
                        End If
                        If (air_inlets = 2) Then
                            Move_Valve 15, "O"
                            current_air_inlet = 2
                        End If

                        Move_Valve 16, "O"
                        waitseconds 10
                        regnum = 1
                        fifty_or_seven = 7
                        SBPP = SBPP2
                        SHFP = SHFP2
                        using_low_regulator = False
                        l_temp = regpos_from_p(current_ip_pressure_target)
                        If l_temp < REGPOS Then lower_reg REGPOS - l_temp
                    End If
                    If l_temp > 4000 Then l_temp = 4000
                End If
                If REGPOS < l_temp Then inc_reg l_temp - REGPOS
            Else
                If debugRunCPass Then Print #mainDebugFile, "40"
            
                ' increase the regulator to sbpp past the current position
                ' This routine will probably never be used because we always
                ' use the i/p regulator with the low flow controller
                l_temp = REGPOS
                While REGPOS < SBPP + l_temp: inc_reg 1: Wend '  initial pressure
            End If
            If reverse_flow_controller = False And SkipFlowStabilize = False Then
                If debugRunCPass Then Print #mainDebugFile, "41"
            
                ' wait for 10 seconds or until the low flow reading goes above
                ' the 2 cc/min value.  This will happen because we increased
                ' the pressure in the regulator and this causes a false increase
                ' on the flow sensor
                T = Timer
                Do
                    local_time = Timer
                    If local_time + 0.1 < T Then T = T - 86400
                    If local_time - T > 10 Then Exit Do
                    ReadXReturnX4 0 ' read low flow meter
                    progress.Line25.Caption = ts$(82) + ": " + ts$(270) + " 1: f=" + Xformat(x5, "##0.000") ' "Waiting for low flow controller to stabilize: phase 1
                Loop Until x5 > 2
                ' now wait for the low flow readings to fall back down to below
                ' 0.1 cc/min (or 30 seconds maximum wait)
                ' It will be artificially high due to the recent increase in pressure
                ' though there is no actual flow going through the controller
                T = Timer
                Do
                    local_time = Timer
                    If local_time + 0.1 < T Then T = T - 86400
                    If local_time - T > 30 Then Exit Do
                    ReadXReturnX4 0 ' read low flow meter
                    progress.Line25.Caption = ts$(82) + ": " + ts$(270) + " 2: f=" + Xformat(x5, "##0.000")    ' "Waiting for low flow controller to stabilize: phase 2: f="
                Loop Until x5 < 0.1
                ' now set the low flow controller to the bublflow value
                ' and wait for it to reach at least 50% of that value
                ' This will eventually cause some pressure increase at the sample, which is why you need to set the
                ' min_pressure a little low due to this slight overshoot
                set_low_flow_rate BUBLFLOW
                num_times_kicked_flow = 0 ' we haven't kicked up the flow because it was too low yet
                T = Timer
                
                Do
                    local_time = Timer
                    If local_time + 0.1 < T Then T = T - 86400
                    If local_time - T > 30 Then Exit Do
                    ReadXReturnX4 0 ' read low flow meter
                    progress.Line25.Caption = ts$(82) + ": " + ts$(270) + " 3: f=" + Xformat(x5, "##0.000")     ' "Waiting for low flow controller to stabilize: phase 3: f="
                Loop Until x5 > BUBLFLOW / 2
            Else ' reverse_flow_controller is true
                If SkipFlowStabilize = False Then
                    If debugRunCPass Then Print #mainDebugFile, "42     RUNNING: " + str$(RUNNING) + "     regnum: " + str$(regnum)
                
                    ' since this is a reverse flow controller, the flow rate won't go
                    ' up just because we increased the pressure on the regulator
                    ' so we don't need the steps used above.
                    ' Instead, since the flow controller starts controlling faster
                    ' the higher the flow set point is, we want to start out at a higher
                    ' set point until it starts reacting (unless the bublflow value is already
                    ' high).
                    set_low_flow_rate BUBLFLOW
                    If lfcpos < 1000 Then set_lfctrl 1000
                    ' wait for flow to reach at least 50% of bublflow value
                    ' This will eventually cause some pressure increase at the sample, which is why you need to set the
                    ' min_pressure a little low due to this slight overshoot
                    num_times_kicked_flow = 0 ' we haven't kicked up the flow because it was too low yet
                    T = Timer
                    Do
                        local_time = Timer
                        If local_time + 0.1 < T Then T = T - 86400
                        If local_time - T > 30 Then Exit Do
                        ReadXReturnX4 0 ' read low flow meter
                        progress.Line25.Caption = ts$(82) + ": " + ts$(270) + " 1: f=" + Xformat(x5, "##0.000")     ' "Waiting for low flow controller to stabilize: phase 1: f="
                    Loop Until x5 > BUBLFLOW / 2
                    ' set the flow target back to what we really want
                    set_low_flow_rate BUBLFLOW
                    ' wait 5 seconds
                    T = Timer
                    Do
                        local_time = Timer
                        If local_time + 0.1 < T Then T = T - 86400
                        ReadXReturnX4 0 ' read low flow meter
                        progress.Line25.Caption = ts$(82) + ": " + ts$(270) + " 2: f=" + Xformat(x5, "##0.000")    ' "Waiting for low flow controller to stabilize: phase 2: f="
                    Loop Until local_time - T > 10
                    ' wait 30 seconds or until flow is within target/2 and target*1.5
                    T = Timer
                    Do
                        local_time = Timer
                        If local_time + 0.1 < T Then T = T - 86400
                        If local_time - T > 30 Then Exit Do
                        ReadXReturnX4 0 ' read low flow meter
                        progress.Line25.Caption = ts$(82) + ": " + ts$(270) + " 3: f=" + Xformat(x5, "##0.000")     ' "Waiting for low flow controller to stabilize: phase 3: f="
                    Loop Until (x5 > BUBLFLOW / 2) And (x5 < BUBLFLOW * 1.5)
                End If
            End If
            'AW
            
            
        End If
    Else
        If debugRunCPass Then Print #mainDebugFile, "43"
    
        If REGPOS < 0 Then REGPOS = 0
        Debug.Print "EBPP <= 0"
        ' newreg is only for version 6, so we don't have to worry with dac variables
        If newreg Then
            If debugRunCPass Then Print #mainDebugFile, "44"
            
            If SBPP - 100 < reg_cl Or hfbp Then
                reg_goto (SBPP)
            Else
                reg_goto (SBPP - 100)
            End If
        Else
            If debugRunCPass Then Print #mainDebugFile, "45"
        
            If ip_reg_enable Then
'                ' first, set the regulator at the maximum pressure for this test
'                i% = regpos_from_p(0) ' get the zero point of the regulator
'                If i% < 0 Then i% = 0
'                i% = regpos_from_p(Maxpres) + SBPP - i%
                ' set the regulator to the max_bp_pres_dif value
                l_temp = regpos_from_p(max_bp_pres_dif)
                ' this can't set it high enough to switch regulators
                current_ip_pressure_target = max_bp_pres_dif
                If l_temp > 4000 Then l_temp = 4000
                
                If REGPOS < l_temp Then inc_reg l_temp - REGPOS
            Else
                While REGPOS < SBPP: inc_reg 1: Wend   '  initial pressure
            End If
        End If
        If low_flow_controller And hfbp = False Then
            If debugRunCPass Then Print #mainDebugFile, "46"
        
            ' start with the controller at 0.
            zero_lfctrl
            ' for low flow controller, we want to keep venting the system
            ' until the low flow controller stabilizes.
'???
            Move_Valve 2, "O"
            If reverse_flow_controller = False And SkipFlowStabilize = False Then
                If debugRunCPass Then Print #mainDebugFile, "47"
            
                Debug.Print "reverse_flow_controller = False" 'AJB 10-05-09
                ' wait for 10 seconds or until the low flow reading goes above
                ' the 2 cc/min value.  This will happen because we increased
                ' the pressure in the regulator and this causes a false increase
                ' on the flow sensor
                T = Timer
                Do
                    local_time = Timer
                    If local_time + 0.1 < T Then T = T - 86400
                    If local_time - T > 10 Then Exit Do
                    ReadXReturnX4 0 ' read low flow meter
                    progress.Line25.Caption = ts$(82) + ": " + ts$(270) + "rfc 1: f=" + Xformat(x5, "##0.000")     ' "Waiting for low flow controller to stabilize: phase 1: f="
                Loop Until x5 > 2
                ' now wait for the low flow readings to fall back down to below
                ' 0.1 cc/min (or 30 seconds maximum wait)
                T = Timer
                Do
                    local_time = Timer
                    If local_time + 0.1 < T Then T = T - 86400
                    If local_time - T > 10 Then Exit Do
                    ReadXReturnX4 0 ' read low flow meter
                    progress.Line25.Caption = ts$(82) + ": " + ts$(270) + " 2: f=" + Xformat(x5, "##0.000")     '"Waiting for low flow controller to stabilize: phase 2: f="
                Loop Until x5 < 0.1
                ' now set the low flow controller to the bublflow value
                ' and wait for it to reach at least 50% of that value
                set_low_flow_rate BUBLFLOW
                num_times_kicked_flow = 0
                T = Timer
                Do
                    local_time = Timer
                    If local_time + 0.1 < T Then T = T - 86400
                    If local_time - T > 10 Then Exit Do
                    ReadXReturnX4 0 ' read low flow meter
                    progress.Line25.Caption = ts$(82) + ": " + ts$(270) + " 3: f=" + Xformat(x5, "##0.000")     ' "Waiting for low flow controller to stabilize: phase 3: f="
                Loop Until x5 > BUBLFLOW / 2
'???
            Else ' reverse_flow_controller is true
                
                If debugRunCPass Then Print #mainDebugFile, "48"
            
                ' since this is a reverse flow controller, the flow rate won't go
                ' up just because we increased the pressure on the regulator
                ' so we don't need the steps used above.
                ' Instead, since the flow controller starts controlling faster
                ' the higher the flow set point is, we want to start out at a higher
                ' set point until it starts reacting (unless the bublflow value is already
                ' high).
                Move_Valve 2, "O" 'AJB 10-05-09 added to make sure V3 is open.
                set_low_flow_rate BUBLFLOW
                If lfcpos < 1000 Then set_lfctrl 1000
                ' wait for flow to reach at least 50% of bublflow value
                num_times_kicked_flow = 0 ' we haven't kicked up the flow because it was too low yet
                'If SkipFlowStabilize = False Then
                T = Timer
                Do
                    local_time = Timer
                    If local_time + 0.1 < T Then T = T - 86400
                    If local_time - T > 10 Then Exit Do 'AJB 10-05-09 was 30
                    ReadXReturnX4 0 ' read low flow meter
                    progress.Line25.Caption = ts$(82) + ": " + ts$(270) + " 1: f=" + Xformat(x5, "##0.000")     ' "Waiting for low flow controller to stabilize: phase 1: f="
                Loop Until x5 > BUBLFLOW / 2
                ' set the flow target back to what we really want
                set_low_flow_rate BUBLFLOW
                ' wait for 5 seconds for control change to take effect
                T = Timer
                Do
                    local_time = Timer
                    If local_time + 0.1 < T Then T = T - 86400
                    If local_time - T > 10 Then Exit Do
                    ReadXReturnX4 0 ' read low flow meter
                    progress.Line25.Caption = ts$(82) + ": " + ts$(270) + " 2: f=" + Xformat(x5, "##0.000")    ' "Waiting for low flow controller to stabilize: phase 2: f="
                Loop Until local_time - T > 2 'AJB 10-05-09 was 5
                fmin = x5
                ' wait for lowest reading in 5 seconds
                T = Timer
                fmin = x5
                Do
                    local_time = Timer
                    If local_time + 0.1 < T Then T = T - 86400
                    If local_time - T > 10 Then Exit Do
                    ReadXReturnX4 0 ' read low flow meter
                    progress.Line25.Caption = ts$(82) + ": " + ts$(270) + " 2: f=" + Xformat(x5, "##0.000")    ' "Waiting for low flow controller to stabilize: phase 2: f="
                    If x5 < fmin Then
                        fmin = x5
                        T = local_time
                    End If
                Loop Until local_time - T > 2 'AJB 10-05-09 was 10
                ' wait 30 seconds or until flow is within target/2 and target*1.5
                T = Timer
                Do
                    local_time = Timer
                    If local_time + 0.1 < T Then T = T - 86400
                    If local_time - T > 10 Then Exit Do 'AJB 10-05-09 was 30
                    ReadXReturnX4 0 ' read low flow meter
                    progress.Line25.Caption = ts$(82) + ": " + ts$(270) + " 3: f=" + Xformat(x5, "##0.000")    ' "Waiting for low flow controller to stabilize: phase 3: f="
                Loop Until (x5 > BUBLFLOW / 2) And (x5 < BUBLFLOW * 1.5)
            End If
'???
            ' close the venting valve - all is well
            Move_Valve 2, "C"
        End If
    End If

    If hfbp Then
        If debugRunCPass Then Print #mainDebugFile, "49"
    
        ' for high flow bubble point, open valve 2 in stages until the flow is greater than or equal to the
        ' bublflow value
        V2POS = SV2P ' initial position
        OpenV2Pos   '1
        ' if we had an estimated bubble point pressure, we need to increment
        ' the regulator at this point
        If EBPP > 0 Then
            inc_reg 10
            ' also, set the toggle so that we know that we just incremented the regulator
            hfbp_ebpp_toggle = True
        End If
        Do
            ' wait while flow is increasing
            lastf = -8888 ' dummy value
            Do
                ReadXReturnX4 FUSE%
                ReadXReturnX4 2
                P = x5
                If autocompress And compression_pressure <> 0 And Compression_Increase_Factor > 0 Then test_compression_pressure P - P0
                UpdateLine25 usingWetSample
                If f <= lastf Or f >= BUBLFLOW Then Exit Do
                lastf = f
            Loop
            ' if flow is high enough, exit the loop
            If f >= BUBLFLOW Then Exit Do
            ' open the valve a little
            ReadXReturnX4 3
            ' only allow the valve to open 10% more than the initial position
            If x4 > SV2P + (oLimit - cLimit) / 10 Then
                ' otherwise, increase the regulator
                inc_reg 10
            Else
                If EBPP > 0 Then
                    ' when we have an estimated bubble point, we alternate between opening
                    ' the valve and incrementing the regulator
                    If hfbp_ebpp_toggle Then
                        V2POS = x4 + 5
                        OpenV2Pos  '2
                        hfbp_ebpp_toggle = False
                    Else
                        inc_reg 10
                        hfbp_ebpp_toggle = True
                    End If
                Else
                    ' if we didn't have an estimated bubble point, we just open the valve
                    V2POS = x4 + 5 ' open the valve as little as possible
                    OpenV2Pos  '3
                End If
            End If
        Loop
    End If

    If debugRunCPass Then Print #mainDebugFile, "50     RUNNING: " + str$(RUNNING) + "     regnum: " + str$(regnum)

    hittimes% = 0 ' number of times we have hit the point in a row
    possibleErrorHits% = 0 ' number of times we may have hit an error point in a row
    ReadXReturnX4 2
    lastp = x5
    ReadXReturnX4 FUSE%
    lastflow = x5
    X = Timer
    LastFlowTime = X
    LastFIncTime = X
    pt = X
    SP = lastp
    fsum = 0
    FlowN = 0
    flowmin = -9999
    If BPTLEnable Then
        If debugRunCPass Then Print #mainDebugFile, "51"
    
        BPTLFirstPointTime = X
        BPTLLastPointTime = X
        BPTLNumPoints = 1
        fn4 = FreeFile
        Open EXE_Path$ + "BPTL_Log.txt" For Output As #fn4
        Write #fn4, 0, lastp - P0, lastflow
        Close #fn4
    End If
    
    If diffpgflow(current_unit%) Then
        If debugRunCPass Then Print #mainDebugFile, "52"
    
        Move_Valve 13, "C"
        ReadXReturnX4 13 + dpgplus%
        diffpgbase% = x4
        diffp0 = x5
    End If
    DoEvents
    user_keypress = 0
    If debugRunCPass Then Print #mainDebugFile, "53A     RUNNING: " + str$(RUNNING)
    
    BP_Points = 0
    BP_Array.s = 100
    ReDim BP_Array.a(100)
    lastFPT = -1
    lastFPTTime = -1
    startFPT = Timer
    possibleBP = False
    BP_MaxFPT = 0
    BP_MaxDeltaFPT = 0
    
    prevXLabel = progress.Label2.Caption
    prevYLabel = progress.Label1.Caption
    prevXMax = progress.X_Max.Caption
    prevYMax = progress.Y_Max.Caption
    progress.PictureBP.Visible = True
    progress.Picture1.Visible = False
    'If Not First_Curve Then
    '    Scr_Refresh first_array
    'End If
    
    
    If BP_UsePressureVsTime Then
        BP_Y_Max = P - P0
        If (BP_Y_Max < 0.001) Then BP_Y_Max = 0.01 ' to avoid zero value
    Else
        BP_Y_Max = BUBLTIME
    End If
    
    BP_X_Max = 60
    'AW
    progress.Line26.Caption = "Waiting for timeout: " + str$(bubWaitTime) + " seconds"
    
    If bubPressOnWait Then openv2completely
    Dim THIS&, that&
    that = CLng(bubWaitTime)
    THIS = (that * 1000)
    'Make the timer count down in the auto test progress screen
    'AW 9/21/2015
    Dim startTimep&, currentTimep&, elapsedTimep&
    Dim bubTimep&
    bubTimep& = that
    startTimep& = Timer
    Do: DoEvents
        currentTimep& = Timer
        elapsedTimep& = currentTimep& - startTimep&
        progress.Line26.Caption = "Waiting for timeout: " + str$(bubTimep& - elapsedTimep) + " seconds"
    Loop Until elapsedTimep& >= that

    'Waitms THIS, False
    If bubPressOnWait Then close_v2_completely
    
    
    If BP_AutoDetectMethod = 0 Then
        If BP_UsePressureVsTime Then
            progress.Label1.Caption = "P (Psi)"
        Else
            progress.Label1.Caption = "F/PT"
        End If

        progress.PictureBP.Scale (0, BP_Y_Max)-(BP_X_Max, 0)
    Else
        progress.Label1.Caption = "Delta F/PT"
        progress.PictureBP.Scale (0, BP_Y_Max)-(BP_X_Max, -BP_Y_Max)
        progress.Y_Zero.Caption = Format$(-BP_Y_Max)
    End If
    progress.Label2.Caption = "Time (s)"
    progress.Y_Max.Caption = Format$(BP_Y_Max)
    progress.X_Max.Caption = Format$(BP_X_Max)
    
    
    If (TType%(current_unit%) = 2 And m_bBPCreateLogFile) Then
        Dim filenameBase$
        filenameBase$ = Left$(OutFilename$(current_unit%), Len(OutFilename$(current_unit%)) - 4)


        Dim fnLog As Integer
        fnLog = FreeFile
        Open OutLogFileName$(current_unit%) For Output As #fnLog
        Dim strHead As String
        strHead = "Time(sec) Pressure(Psi)  Flow(cc/min)   spread (Psi)   meanP (Psi)   "
        Print #fnLog, strHead
        
    End If
    
BLOOP:
'If x4 >= DAC_two And X = 2 And Pres% > 0 And RUNNING And ExtraPG Then
    If debugRunCPass Then Print #mainDebugFile, "53     Pres: " + str$(Pres%) + "     last_pres: " + str$(last_pres%)

    last_pres% = Pres% ' remember gauge range before we call ReadXReturnX4, which may change this because of switching ranges
    ReadXReturnX4 2
    P = x5
    If debugRunCPass Then Print #mainDebugFile, "53B     x4: " + str$(x4) + "     DAC_two: " + str$(DAC_two) + "     RUNNING: " + str$(RUNNING) + "     extraPG: " + str$(ExtraPG)
    
    ' Re-range P2 AGAIN to catch strange, non-regularly reproducable, and inexplicable pressure changes since the last time.
    ' (Originally re-ranged in Load_Sample)
    ' - Mix
    If NeedP20 And ExtraPG Then
        ReRangeP2 (real_atm)
        NeedP20 = False
    End If
    
    ' Reduce the flow if we've hit our target - Mix
    If NeedToWatchPressForReduction And P - P0 >= ReduceFlowPressureTarget Then
    
        ' Only do this once
        NeedToWatchPressForReduction = False

        ' Set flow to 1/4
        oldBloop = BUBLFLOW
        set_low_flow_rate BUBLFLOW / 4
        
        ' For debugging, change back color to show we hit it
        If progress.Visible Then progress.Frame1.BackColor = &H8000FF
        
        'reset flow average and flow average count
        fsum = 0
        FlowN = 0
        alreadyDidThat = True
    End If
    
    ' 6.71.33 begin
    If Pres% <> last_pres% Then
        ReadXReturnX4 2
        P = x5
        If debugRunCPass Then Print #mainDebugFile, "54     x4: " + str$(x4) + "     x5: " + str$(x5)
        
        ' if we switched gauge ranges, reset our pressure watch variables
        SP = P ' new starting pressure
        lastp = P ' new highest pressure reading we have seen
        pt = Timer ' new starting pressure time
        fsum = 0 ' reset flow averager
        FlowN = 0 ' reset flow averager count
    End If
    ' 6.71.33 end
    'edc 06-11-07 this is to get a real time for the bubble point test ==============
   'THIS
    If x4 = DAC_over Then
        endPassCause = 9
        MsgBox str$(x4) + "=" + str$(DAC_over)
        GoTo END_PASS
    End If
    If P - P0 > Maxpres Then
        endPassCause = 10
        MsgBox "Test has exceeded maximum pressure (" + str$(Maxpres) + " set by user!"
        GoTo END_PASS
    End If
    
        BPEndTime = Timer
        BPCurrentTime = Timer
    If (TType%(current_unit%) = 2 And m_bBPFindingForCartridge) Then
        InsertNewValue m_fBPPressureArray(), (P - P0), m_nBPPressureArraySize, m_nBPPressurePointCounter
        
        ' it is not safe for long test to use 16 bits integer, lets stop increasing it when it exceed the 5 times array size
        If (m_nBPPressurePointCounter < 5 * m_nBPPressureArraySize) Then
            m_nBPPressurePointCounter = m_nBPPressurePointCounter + 1
        End If
        
 ' lets be sure that stack is full, which  allow to avoid taking BP at the begining of the test,
 ' when pressure increases (this is happening below 0.1 Psi and nothing to do with real BP)
        If (m_nBPPressurePointCounter > m_nBPPressureArraySize) Then
            m_fBPCurrentMeanPressure = getMeanValue(m_fBPPressureArray(), m_nBPPressureArraySize, m_nBPPressurePointCounter)
            m_fBPCurrentStandardDeviation = getStandardDeviation(m_fBPPressureArray(), m_nBPPressureArraySize, m_nBPPressurePointCounter)

' Use mean pressure to detect BP for cartridge type samples
'            If (m_fBPCurrentMeanPressure > m_fBPMaxMeanPressure) Then
'                m_fBPMaxMeanPressure = m_fBPCurrentMeanPressure
'                m_fBPPressureUsingMean = m_fBPPressureArray(0)
'            End If
            
' Use pressure spread (standard deviation) to detect BP for cartridge type samples
            If (m_fBPCurrentStandardDeviation > m_fBPMaxStandardDeviation And _
                m_fBPCurrentStandardDeviation > m_fBPPreviousStandardDeviation) Then
                m_fBPMaxStandardDeviation = m_fBPCurrentStandardDeviation
                m_fBPPressureUsingSpread = m_fBPPressureArray(m_nBPPressureArraySize / 2)
            End If
            
            m_fBPPreviousStandardDeviation = m_fBPCurrentStandardDeviation
            
            
        End If
        
    End If
    
    If (TType%(current_unit%) = 2 And m_bBPCreateLogFile) Then
        Print #fnLog, Xformat$((BPCurrentTime - BPStartTime), "######0.0") + "   " + Xformat$(P - P0, "####0.000") _
                + "  " + Xformat$(f, "#######0.00") _
                + "  " + Xformat$(m_fBPCurrentStandardDeviation, "####0.00000") _
                + "  " + Xformat$(m_fBPCurrentMeanPressure, "#####0.0000")
    End If
    
    If diffpgflow(current_unit%) Then
        If debugRunCPass Then Print #mainDebugFile, "55"
    
      ReadXReturnX4 13 + dpgplus%
      diffp = x5 - diffp0
      P = P - diffp
      If x4 - diffpgbase% >= DAC_span / 100 Then
        If debugRunCPass Then Print #mainDebugFile, "56"
      
        Possible_BP_Pressure = P
        Move_Valve 13, "O"
        progress.Line26.Caption = ts$(271) + "..."          '"Possible through flow - checking"
        If Not hfbp Then
            Move_Valve 0, "C"
            If low_flow_controller Then zero_lfctrl
        End If
        Rem wait 2 seconds
        'T = Timer
        'Do
        '  local_time = Timer
        '  If (local_time + 0.1 < T) Then T = T - 86400
        '  DoEvents
        'Loop While (local_time - T) < 2
        waitseconds 2
        ' close the vent valve
        Move_Valve 13, "C"
        ' read the initial pressure on the differential pressure gauge
        '  and record the time.
        ReadXReturnX4 13 + dpgplus%
        diffpgbase% = x4
        T = Timer
        ' wait for the differential pressure gauge to go up 200 counts
        ' or 30 seconds, whichever comes first
        ' If it goes up 200 counts, we have our bubble point
        ' if not, we continue
        Do
          DoEvents
          ReadXReturnX4 13 + dpgplus%
          local_time = Timer
          If (local_time + 0.1 < T) Then T = T - 86400
        Loop While (local_time - T < 30) And (x4 - diffpgbase% < DAC_span / 100)
        If x4 - diffpgbase% >= DAC_span / 100 Then
          Move_Valve 13, "O"
          HKey$ = "B"
          progress.Line26.Caption = ts$(272)        ' "Possible through flow - found"
        Else
            If Not hfbp Then
                Move_Valve 0, "O"
                If low_flow_controller Then set_low_flow_rate BUBLFLOW
            End If
        End If
      End If
    End If

    If debugRunCPass Then Print #mainDebugFile, "57"

    ReadXReturnX4 FUSE%
    f = x5
    X = Timer

    fsum = fsum + (X - LastFlowTime) * (f + lastflow) / 2
    FlowN = FlowN + (X - LastFlowTime)
    LastFlowTime = X
    lastflow = f
    If autocompress And compression_pressure <> 0 And Compression_Increase_Factor > 0 Then test_compression_pressure P - P0
    UpdateLine25 usingWetSample
    If BPTLEnable Then
        If debugRunCPass Then Print #mainDebugFile, "58"
    
        If X + 1 < BPTLFirstPointTime Then BPTLFirstPointTime = BPTLFirstPointTime - 86400
        If X + 1 < BPTLLastPointTime + 1 Then BPTLLastPointTime = BPTLLastPointTime - 86400
        If (X - BPTLLastPointTime) * 10 >= BPTLInterval Then
            If debugRunCPass Then Print #mainDebugFile, "59"
        
            BPTLNumPoints = BPTLNumPoints + 1
            BPTLLastPointTime = BPTLLastPointTime + (BPTLInterval / 10#)
            fn4 = FreeFile
            Open EXE_Path$ + "BPTL_Log.txt" For Append As #fn4
            Write #fn4, X - BPTLFirstPointTime, P - P0, f
            Close #fn4
        End If
    End If
    ' only update BBHigh if we haven't hit a possible bubble point yet
    If P > BBHigh And hittimes% = 0 Then BBHigh = P
    DoEvents
    If TType%(current_unit%) = 2 And TMode%(current_unit%) = 3 And externalhydrohead And user_keypress = 32 Then HKey$ = "B" ' trigger hydrohead reached upon keypress
    If Aborted Or HKey$ = "B" Then GoTo 3250    '  found bubble point
    If f >= BUBLFLOW And low_flow_controller Then LastFIncTime = Timer
'stopped here ???
    
    'Is the current flow less than the desired bubble point flow?
    If f <= BUBLFLOW Then
        If debugRunCPass Then Print #mainDebugFile, "60"
    
        If f > (1.1 * flowmin) Then  ' if flow has gone up by > 10% then reset timer and continue looping
            If debugRunCPass Then Print #mainDebugFile, "61"
        
            flowmin = f '  flow went up by more than 10% while staying below zero point
            LastFIncTime = Timer
        Else  ' flow is below bublflow and falling if we get here !
        
        
            If debugRunCPass Then Print #mainDebugFile, "62"
        
            If Timer + 0.1 < LastFIncTime Then LastFIncTime = LastFIncTime - 86400! '  take care of day switch
            ' 6.71.22b
            If (low_flow_controller And hfbp = False And _
                     ((Timer - LastFIncTime >= 10) Or _
                      ((REGPOS = 4000) And dualregulator And using_low_regulator))) Or _
               ((low_flow_controller = False Or hfbp = True) And (Timer - LastFIncTime >= ZEROTIME)) Then
            'If (low_flow_controller And (Timer - LastFIncTime >= 10)) Or ((Not low_flow_controller) And (Timer - LastFIncTime >= ZEROTIME)) Then
                '  now increase pressure slightly
                Rem  new part added by jsd - increments regulator based on distance from bublflow
                Rem this is primarily to speed achieving bublflow when entering an estimated bubble pressure
                Rem only do this if regulator has already clicked 5 times
                Rem also only do this if using the motorized regulator
                If newreg And f < 0.25 * BUBLFLOW And REGPOS >= 5 Then
                    If debugRunCPass Then Print #mainDebugFile, "63"
                    inc_reg 10
                    inc_reg 10
                    inc_reg 10
                    DoEvents
                    LastFIncTime = Timer
                    flowmin = -9999
                ElseIf newreg And f < 0.5 * BUBLFLOW And REGPOS >= 5 Then
                    If debugRunCPass Then Print #mainDebugFile, "64"
                    inc_reg 10
                    inc_reg 10
                    DoEvents
                    LastFIncTime = Timer
                    flowmin = -9999
                ElseIf low_flow_controller And hfbp = False Then
                    If debugRunCPass Then Print #mainDebugFile, "65"
                
                    ' if we haven't kicked up the flow controller yet, we will try this first
                    ' 6.71.22b don't kick it up if we are at the limit of reg1
                    If ((REGPOS = 4000) Or (P >= reg1pmax)) And dualregulator And using_low_regulator Then num_times_kicked_flow = 4 ' force it to switch regulators
                    If num_times_kicked_flow < 2 Then
                        If debugRunCPass Then Print #mainDebugFile, "66"
                        inc_lfctrl 20
                        num_times_kicked_flow = num_times_kicked_flow + 1
                        DoEvents
                        LastFIncTime = Timer
                        flowmin = -9999
                    Else
                        If debugRunCPass Then Print #mainDebugFile, "67"
                    
                        ' prepare to increment the regulator
                        zero_lfctrl ' stop all flow through the controller
                        ' increase the regulator by the max_bp_pres_dif
                        ' derate max_bp_pres_dif by atmospheres
                        current_ip_pressure_target = current_ip_pressure_target + max_bp_pres_dif / (1 + current_ip_pressure_target / 14.7)
                        l_temp = regpos_from_p(current_ip_pressure_target)
                        ' 6.71.22 begin
                        If l_temp > 4000 Or (P - P0 > reg1pmax) Then
                            If debugRunCPass Then Print #mainDebugFile, "68"
                        
                            ' see if we need to switch regulators
                            If dualregulator And using_low_regulator Then
                                If debugRunCPass Then Print #mainDebugFile, "69" + "     regnum: " + str$(regnum)
                                ' close valve 1 to start
                                Move_Valve 0, "C"
                                If REGPOS > second_regulator_starting_point Then
                                    lower_reg REGPOS - second_regulator_starting_point
                                    waitseconds 3
                                End If
                                Move_Valve 16, "O"
                                If (air_inlets = 2) Then
                                    Move_Valve 15, "O"
                                    current_air_inlet = 2
                                End If
                                waitseconds 10
                                regnum = 1
                                fifty_or_seven = 7
                                using_low_regulator = False
                                SBPP = SBPP2
                                SHFP = SHFP2
                                l_temp = regpos_from_p(current_ip_pressure_target)
                                If REGPOS > l_temp Then lower_reg REGPOS - l_temp
                                ' open valve 1 back up
                                Move_Valve 0, "O"
                            End If
                            If l_temp > 4000 Then l_temp = 4000
                        End If
                        ' 6.71.22 end
                        If REGPOS < l_temp Then inc_reg l_temp - REGPOS
                        ' wait for 10 seconds or until the low flow reading goes above
                        ' the 2 cc/min value.  This will happen because we increased
                        ' the pressure in the regulator and this causes a false increase
                        ' on the flow sensor
                        T = Timer
                        Do
                            local_time = Timer
                            If local_time + 0.1 < T Then T = T - 86400
                            If local_time - T > 10 Then Exit Do
                            If Aborted Then Exit Do
                            ReadXReturnX4 0 ' read low flow meter
                            progress.Line25.Caption = ts$(82) + ": " + ts$(270) + " 1: f=" + Xformat(x5, "##0.000")  ' "Waiting for low flow controller to stabilize: phase 1
                        Loop Until x5 > 2
                        ' now wait for the low flow readings to fall back down to below
                        ' 0.1 cc/min (or 30 seconds maximum wait)
                        ' It will be artificially high due to the recent increase in pressure
                        ' though there is no actual flow going through the controller
                        T = Timer
                        Do
                            local_time = Timer
                            If local_time + 0.1 < T Then T = T - 86400
                            If local_time - T > 10 Then Exit Do
                            If Aborted Then Exit Do
                            ReadXReturnX4 0 ' read low flow meter
                            progress.Line25.Caption = ts$(82) + ": " + ts$(270) + " 2: f=" + Xformat(x5, "##0.000")     ' "Waiting for low flow controller to stabilize: phase 2: f="
                        Loop Until x5 < 0.1
                        ' now set the low flow controller to the bublflow value
                        If alreadyDidThat = True Then
                            set_low_flow_rate (BUBLFLOW / 4)
                        Else
                            set_low_flow_rate BUBLFLOW
                        End If
                        ' now wait for the low flow readings to get back to 20% of
                        ' bublflow (or 30 seconds maximum wait)
                        T = Timer
                        Do
                            local_time = Timer
                            If local_time + 0.1 < T Then T = T - 86400
                            If local_time - T > 10 Then Exit Do
                            If Aborted Then Exit Do
                            ReadXReturnX4 0 ' read low flow meter
                            progress.Line25.Caption = ts$(82) + ": " + ts$(270) + " 2: f=" + Xformat(x5, "##0.000")    ' "Waiting for low flow controller to stabilize: phase 2: f="
                        Loop Until x5 > BUBLFLOW / 5
                        If debugRunCPass Then Print #mainDebugFile, "70"
                        
                        num_times_kicked_flow = 0 ' we haven't kicked up the flow because it was too low yet
                        DoEvents
                        LastFIncTime = Timer
                        flowmin = -9999
                        ' reset timing since we just messed with things
                        ReadXReturnX4 2
                        P = x5
                        SP = P
                        lastp = P
                        pt = Timer
                        fsum = 0
                        FlowN = 0
                    End If
                Else
                    If debugRunCPass Then Print #mainDebugFile, "71"
                    inc_reg 10
                    DoEvents
                    LastFIncTime = Timer
                    flowmin = -9999
                End If
            End If
        End If
    End If
    
    If lastp < P Then
        If debugRunCPass Then
            Print #mainDebugFile, "71A     P: " + str$(P) + "     lastp: " + str$(lastp)
        End If
        lastp = P
    ElseIf debugRunCPass Then
            Print #mainDebugFile, "71B     P: " + str$(P) + "     lastp: " + str$(lastp)
    End If
    
    ' this causes false flow readings unless the flow controller is reversed
    If low_flow_controller And ip_reg_enable And reverse_flow_controller And hfbp = False Then
        If debugRunCPass Then Print #mainDebugFile, "72"
    
        ' make sure the regulator is high enough to maintain a constant
        ' presure drop accross the flow controller
        ' calculate the current pressure setting of the regulator
        ' based on the current regulator position minus the starting
        ' bubble point pressure value.  If this is less than the current
        ' pressure, then we want to increment the regulator just a bit
        If P + max_bp_pres_dif / (1 + P / 14.7) > current_ip_pressure_target Then
            inc_reg 1
            current_ip_pressure_target = p_from_regpos(REGPOS)
        End If
    End If
    
    ' 6.71.97 could cause a divide by zero error without extra test
    If runAsPassFail(current_unit%) And (P - P0 > 0) Then
        If Check_PassFail(0.58042 * tfactor * surfTen(current_unit%) / (P - P0)) = -1 Then
            If debugRunCPass Then Print #mainDebugFile, "73"
        
        ' Below the minimum pore size, so test cannot be redeemed!
            failed = True
            progress.Label4.ForeColor = vbRed
            progress.Label4.BackColor = vbBlack
            progress.Label4.Caption = ts$(175)      ' "Failed"
            progress.Label4.Visible = True
            progress.sadface.Visible = True
            progress.happyface.Visible = False
            If stopTestOnFail(current_unit%) Then           ' User wants test to end if it fails
                MsgBox ts$(450) + vbCrLf + ts$(451), 0, "Test Failed"     ' "Test failed. Bubble point was outside the specified range."/test will now abort"
                HKey$ = "A"
                Aborted = True
            End If
        Else
            If debugRunCPass Then Print #mainDebugFile, "74"
        
            failed = False
            progress.Label4.ForeColor = vbGreen
            progress.Label4.BackColor = vbBlack
            progress.Label4.Caption = ts$(174)      ' "Failed"
            progress.Label4.Visible = True
            progress.sadface.Visible = False
            progress.happyface.Visible = True
        End If
    End If
    
    If Timer + 0.1 < pt Then pt = pt - 86400! '  take care of day switch
    curtime = Timer
    elapsed = curtime - pt
    'AJB 11-16-09 augemented below b/c the program is not detecting quick bubble points.
    'If elapsed < 2.5 Then
    If elapsed < 2.5 Then
        If debugRunCPass Then Print #mainDebugFile, "75A"
        GoTo BLOOP ' exp by jsd
    End If
    
    If curtime + 0.1 < LastFIncTime Then
        If debugRunCPass Then Print #mainDebugFile, "75B"
        LastFIncTime = LastFIncTime - 86400
    End If
    
    If (curtime - LastFIncTime < PulseDelay) And (low_flow_controller = False Or hfbp = True) Then
        If debugRunCPass Then Print #mainDebugFile, "75C"
        GoTo BLOOP
    End If
    
    If FlowN = 0 Then
        If debugRunCPass Then Print #mainDebugFile, "75D"
        GoTo BLOOP ' just in case
    End If
    
    If elapsed < 2 And (fsum / FlowN) < (BUBLFLOW / 2) Then
        If debugRunCPass Then Print #mainDebugFile, "75E"
        GoTo BLOOP ' used to be 10 jsd exp
    End If
    
    DoEvents
    If debugRunCPass Then Print #mainDebugFile, "75"
    
    'JF 2-11-10
    'Check here for minbppress getting hung up if actual bubble point is less than user
    'defined min bubble point pressure
    'AJB 11-16-09
    If lastp - SP = 0 And elapsed < 2 Then
        If debugRunCPass Then Print #mainDebugFile, "76A"
        GoTo BLOOP
    End If
    
    If lastp <= SP Then
        If debugRunCPass Then Print #mainDebugFile, "76"
    
        x5 = 9999999
        'Attempting to avoid any divide by zero errors
        If FlowN > 0 Then
            EF = fsum / FlowN
        Else
            EF = 9999999
        End If
    Else
        If debugRunCPass Then Print #mainDebugFile, "77"
    
        x5 = fsum / FlowN * elapsed / (lastp - SP) / 760# * 14.7
        EF = (x5 - BUBLTIME) * (lastp - SP) / elapsed / 14.7 * 760#
        If EF > fsum / FlowN Then EF = fsum / FlowN
    End If
    
    currFPT = x5
    currFPTTime = curtime
    If currFPT > BP_MaxFPT Then
        BP_MaxFPT = currFPT
    End If
    
    If lastFPT > -1 Then
        'deltaFPT = (currFPT - lastFPT) / (currFPTTime - lastFPTTime)
        If lastp > BP_Array.a(BP_Points).pr Then
            deltaFPT = (currFPT - lastFPT) / (lastp - BP_Array.a(BP_Points).pr)
            If deltaFPT > BP_MaxDeltaFPT Then
                BP_MaxDeltaFPT = deltaFPT
            End If
        End If
    End If
    
    Debug.Print "F/PT: " + str$(x5) + " Pressure: " + Xformat$((lastp - SP) * 60# * 27.7076 * 2.54 / elapsed, "####0.00")
    Debug.Print "Delta F/PT: " + str$(deltaFPT)
    
    If EF < 0 Then EF = 0
    Rem Average Flow = FSum / Flown cc/min
    Rem Change in Pressure = (LastP - SP) * 760 / 14.7 Torr
    Rem Time Interval = elapsed sec
    Rem ESTIMATED FLOW THROUGH SAMPLE = EF cc/min
    
    fn5 = FreeFile
    Open EXE_Path$ + "PreBPdata.dat" For Append As #fn5
    
    If TMode%(current_unit%) = 3 Then
        If debugRunCPass Then Print #mainDebugFile, "78"
        If BP_AutoDetectMethod = 0 Then
            progress.Line26.Caption = ts$(273) + ": " + Xformat$(fsum / FlowN, "##0.0000") + "  " + ts$(274) + "=" + Xformat$((lastp - SP) * 60# * 27.7076 * 2.54 / elapsed, "####0.00") + " cm H2O/" + ts$(75) + ",  F/PT " + ts$(275) + ": " + Xformat$(currFPT, "######0.00") + ",  " + ts$(276) + ": " + Xformat$(EF, "###0.0000") ' "Ave. Flow In"/"P Change"/"cm"/"min"/"Factor"/"Est. Thru Flow"
        Else
            progress.Line26.Caption = ts$(273) + ": " + Xformat$(fsum / FlowN, "##0.0000") + "  " + ts$(274) + "=" + Xformat$((lastp - SP) * 60# * 27.7076 * 2.54 / elapsed, "####0.00") + " cm H2O/" + ts$(75) + ",  Delta F/PT " + ts$(275) + ": " + Xformat$(deltaFPT, "######0.00") + ",  " + ts$(276) + ": " + Xformat$(EF, "###0.0000") ' "Ave. Flow In"/"P Change"/"cm"/"min"/"Factor"/"Est. Thru Flow"
        End If
        
        Print #fn5, ztempFlow$ + "," + ztempPressure$ + "," + ztempDiam$ + "," + Xformat$(fsum / FlowN, "##0.0000") + "," + _
            Xformat$(EF, "###0.0000") + "," + Xformat$((lastp - SP) * 60# * 27.7076 * 2.54 / elapsed, "####0.00") + "," + _
            Xformat$(currFPT, "######0.00")
        'Print #fn5, ts$(273) + ":"; vbTab; Xformat$(fsum / FlowN, "##0.0000"); vbTab; ts$(274) + ":"; vbTab; Xformat$((lastp - SP) * 60# * 27.7076 * 2.54 / elapsed, "####0.00"); vbTab; "cm H2O/" + ts$(75); vbTab; "F/PT " + ts$(275) + ":"; vbTab; Xformat$(currFPT, "######0.00"); vbTab; ts$(276) + ":"; vbTab; Xformat$(EF, "###0.0000"); _
        '    vbTab; ztempPressure$; vbTab; ztempFlow$; vbTab; ztempDiam$
    Else
        If debugRunCPass Then Print #mainDebugFile, "79"
    
        If BP_AutoDetectMethod = 0 Then
            progress.Line26.Caption = ts$(273) + ": " + Xformat$(fsum / FlowN, "##0.0000") + ",  " + ts$(274) + "=" + Xformat$((lastp - SP) * 760# / 14.7, "####0.00") + " Torr,  F/PT " + ts$(275) + ": " + Xformat$(currFPT, "######0.00") + ",  " + ts$(276) + ": " + Xformat$(EF, "###0.0000") ' "Ave. Flow In"/"P Change"/"Torr"/"Factor"/"Est. Thru Flow"
        Else
            progress.Line26.Caption = ts$(273) + ": " + Xformat$(fsum / FlowN, "##0.0000") + ",  " + ts$(274) + "=" + Xformat$((lastp - SP) * 760# / 14.7, "####0.00") + " Torr,  Delta F/PT " + ts$(275) + ": " + Xformat$(deltaFPT, "######0.00") + ",  " + ts$(276) + ": " + Xformat$(EF, "###0.0000") ' "Ave. Flow In"/"P Change"/"Torr"/"Factor"/"Est. Thru Flow"
        End If
        
        Print #fn5, ztempFlow$ + "," + ztempPressure$ + "," + ztempDiam$ + "," + Xformat$(fsum / FlowN, "##0.0000") + "," + _
            Xformat$(EF, "###0.0000") + "," + Xformat$((lastp - SP) * 60# * 27.7076 * 2.54 / elapsed, "####0.00") + "," + _
            Xformat$(currFPT, "######0.00") + "," + Xformat$(deltaFPT, "#####0.00")
        'Print #fn5, ts$(273) + ":"; vbTab; Xformat$(fsum / FlowN, "##0.0000"); vbTab; ts$(274) + ":"; vbTab; Xformat$((lastp - SP) * 60# * 27.7076 * 2.54 / elapsed, "####0.00"); vbTab; "Torr"; vbTab; "F/PT " + ts$(275) + ":"; vbTab; Xformat$(currFPT, "######0.00"); vbTab; "Delta F/PT: "; vbTab; Xformat$(deltaFPT, "#####0.00"); vbTab; ts$(276) + ":"; vbTab; Xformat$(EF, "###0.0000"); _
        '    vbTab; ztempPressure$; vbTab; ztempFlow$; vbTab; ztempDiam$
    End If
    progress.Line26.Refresh
    Close #fn5
    
     ' 6.71.33 end
    
    'Write to debug log here
    'Format of each line is: MonthDay HourMinute, Timer, Pressure, Ave. flow in, pressure change in torr, F/PT factor, est. through flow
    If debugBP Then
        Open "BPdebuglog.txt" For Append As #12
        Print #12, Format(str$(now), "mm/dd hh:mm"); " "; Format(Timer, "#####"); " "; Format(P - P0, "###.###"); Xformat$(fsum / FlowN, "##0.0000"); " "; Xformat$((lastp - SP) * 760 / 14.7, "####0.00"); " "; Xformat$(x5, "####0.00"); " "; Xformat$(EF, "###0.0000")
        Close #12
    End If
    '*******
    
    If BP_AutoDetectMethod = 0 Then
        If currFPT > BUBLTIME Then
            possibleBP = True
        Else
            possibleBP = False
        End If
    Else
        If deltaFPT > BUBLTIME Then
            possibleBP = True
        Else
            possibleBP = False
        End If
    End If
    
    'JF 2-11-10
    'Also check here for minbppress
    '    If x5 > BUBLTIME And P - P0 >= minbppres Then
    'If x5 > BUBLTIME Then
    
    ' stop the test after certain amount of time if minimum BP set to above 0.

    'aw 3/26/2015
    If minbppres > 0 And (BPEndTime - BPStartTime) > BPTestStopTimeInterval Then 'And (BPEndTime - BPStartTime) > bubWaitTime Then
        ' this is some kind of imitation that we have detected maximum number of the BP
        hittimes% = BP_PointDetectionCount
        hitpoint = P
        hitpoint = m_fBPPressureUsingSpread + P0
        GoTo 3250
    ElseIf minbppres > 0 Then
          
    End If
        
'SHIT HERE
    If possibleBP Then
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'        Dim asdf As Long
''        asdf = REGPOS
''        Zero_Reg
'        If BPPrePressure = True Then
'            'inc_reg BPPrePressureCounts
'            Call Move_Valve(1, "O")
'           ' Call Waitms((BPPrePressureTime * 1000), False)
'           Call Waitms(250, False)
'            Call Move_Valve(1, "C")
'            Waitms 1000, False
'        End If
''        Zero_Reg
''        inc_reg (CInt(asdf))
        If debugRunCPass Then Print #mainDebugFile, "80"
        If P - P0 >= minbppres Then
            If debugRunCPass Then Print #mainDebugFile, "81"
            hittimes% = hittimes% + 1
            If hittimes% = BP_PointDetectionCount And man_bp_detect Then hittimes% = 2
            '???
           'exits Here
            If hittimes% = BP_PointDetectionCount Then P = hitpoint: GoTo 3250
            If hittimes% = 1 Then hitpoint = P
        
        
'            commented entire block
'        Else
'            If debugRunCPass Then Print #mainDebugFile, "82"

'            possibleErrorHits% = possibleErrorHits + 1
'            If possibleErrorHits% = 1 Then hitpoint = P
'            If possibleErrorHits% = BP_PointDetectionCount Then
'                usermsgres = MsgBox("The actual bubble point is lower than the user-defined minimum bubble point.  Would you like to continue recording this value?  If you click No the test will abort.", vbYesNo)
'                If usermsgres = vbYes Then
'                    P = hitpoint
'                    GoTo 3250
'                Else
'                    Aborted = True
'                    endPassCause = 11
'                    GoTo END_PASS
'                End If
'            End If
        End If
        ' stop the test here in case there is a leakage

        
        
    Else
        
        hittimes% = 0
        possibleErrorHits% = 0

    End If
    
    If debugRunCPass Then Print #mainDebugFile, "83A"
    If NeedToWatchPressForReduction = False Then
       BP_Points = BP_Points + 1
       dat_size_check BP_Array, BP_Points
       BP_Array.a(BP_Points).time = curtime - startFPT
       BP_Array.a(BP_Points).fl = currFPT
       BP_Array.a(BP_Points).fl2 = deltaFPT
       BP_Array.a(BP_Points).pr = lastp
       BP_Scr_Refresh BP_Array
       If debugBP Then
          Print #12, Format(BP_Points, "#####0"); " "; Format((P - P0), "###0.000"); " "; Format(BP_Array.a(BP_Points).time, "####.0")
       End If
    
       SP = lastp
       pt = curtime
       fsum = 0
       FlowN = 0
       lastFPT = currFPT
       lastFPTTime = currFPTTime
       progress.Refresh
    End If
    DoEvents
    GoTo BLOOP
3250
    ' write cartridge test final parameters
    If (TType%(current_unit%) = 2 And m_bBPCreateLogFile) Then
        Print #fnLog, " "
        Print #fnLog, "Using mean pressure method:"
        Print #fnLog, "Bubble Point pressure is  " + Xformat$(m_fBPPressureUsingMean, "##0.000") + " Psi"
        '
        Print #fnLog, " "
        Print #fnLog, "Using pressure spread method:"
        Print #fnLog, "Bubble Point pressure is  " + Xformat$(m_fBPPressureUsingSpread, "##0.000") + " Psi"
        ' this is your BP pressure with cartridge test
        P = P0 + m_fBPPressureUsingSpread

        Close #fnLog
    End If
    
    If debugRunCPass Then Print #mainDebugFile, "83"
    
    progress.Label1.Caption = prevYLabel
    progress.Label2.Caption = prevXLabel
    progress.Y_Max.Caption = prevYMax
    progress.X_Max.Caption = prevXMax
    progress.Y_Zero.Caption = "0.0"
       
    progress.Picture1.Visible = True
    progress.PictureBP.Visible = False
'    If Not First_Curve Then
'        progress.Picture1.Cls
'        progress.Picture1.Refresh
'        First_Curve = False
'        Scr_Refresh first_array
'        First_Curve = True
'        progress.Picture1.Refresh
'    End If

    If debugRunCPass Then Print #mainDebugFile, "84"
    ' Round out BP log if appropriate
    If debugBP Then
        If debugRunCPass Then Print #mainDebugFile, "85"
        Open "BPdebuglog.txt" For Append As #12
        Print #12, " "
        Close #12
    End If
    
    If diffpgflow(current_unit%) Then
        If debugRunCPass Then Print #mainDebugFile, "86"
        'MsgBox "opening diffpg venting valve"
        Move_Valve 13, "O"
        EF = 0.000001 ' microflow samples can't have bubble point flows that are too high
    End If
    If EF <= 0 Then EF = 0.001
    f = EF
    points = points + 1
    dat_size_check x_array, points
    x_array.a(points).fl = EF
    ' 6.71.20
    x_array.a(points).fl2 = EF ' just in case
    x_array.a(points).pr = P
    If debugRunCPass Then
        Print #mainDebugFile, "87"
    End If
    
    'AJB 10-20-09 6.71.130
    If dryChamberTemperature <> 0 Then x_array.a(points).temp1 = readNewTemperature(dryChamberTemperature)
    If airTemperature <> 0 Then x_array.a(points).temp2 = readNewTemperature(airTemperature)
    'AJB 10-20-09 6.71.130
    
    If hasHumidityControls And enableHumidityControlForAutoTests Then
        If debugRunCPass Then Print #mainDebugFile, "88"
        
        goToTargetHumidity
        
        'ReadXReturnX4 1 're-read current flow
        'x_array.a(points).fl = x5
        
        'ReadXReturnX4 2 're-read current pressure
        'x_array.a(points).pr = x5
        
        x_array.a(points).humidity = lastGoodHumidity
        
        Print #55, x_array.a(points).fl & Chr(9) & x_array.a(points).pr & Chr(9) & x_array.a(points).humidity & Chr(9) & Format$(getBubblerMVPosition(), "##0.00%") & Chr(9) & goToHumidityCounter & Chr(9); goToHumidityWaitTimeCounter & Chr(9) & REGPOS & Chr(9) & Format$(getMV2Position(), "##0.00%") & Chr(9) & lfcpos
        
    ElseIf hasHumidityControls And recordHumidityForAutoTests Then
        'just read humidity sensor and record the point, don't try to correct the humidity by calling goToTargetHumidity
        If debugRunCPass Then Print #mainDebugFile, "89"
        x_array.a(points).humidity = readHumiditySensor
    End If
    
    If use_fluid_sensor Then
        If debugRunCPass Then Print #mainDebugFile, "90"
    
        ReadXReturnX4 27
        x_array.a(points).fluid = x5 - fluid_sensor_0
    End If
    If BBHigh > x_array.a(points).pr Then x_array.a(points).pr = BBHigh
    
    ' If we use cartridge samples, then we want to record the pressure,
    ' which coressponds to the largest pressure spread.
    If m_bBPFindingForCartridge Then x_array.a(points).pr = P0 + m_fBPPressureUsingSpread
    
    BUBBLEPT = x_array.a(points).pr
    
       
    If debugRunCPass Then Print #mainDebugFile, "91"
    
    If hasHumidityControls And enableHumidityControlForAutoTests And Not afterBubblePoint And Not Aborted Then
        If debugRunCPass Then Print #mainDebugFile, "92"
        Move_Valve 2, "C" 'close the damn vent valve
        'Waitms 2000, False
        Move_Valve 3, "C" 'set bubbler enable
    End If
    afterBubblePoint = True
    
    time_to_bubble = Timer - RunTimer
    While time_to_bubble < -0.1
        time_to_bubble = time_to_bubble + 86400
    Wend
    If debugRunCPass Then Print #mainDebugFile, "93"
    x_array.a(points).eqd = 0
    x_array.a(points).time = Timer
    
    If debugRunCPass Then
       Print #mainDebugFile, Format(points, "#####0"); " "; Format((P - P0), "###0.000"); " "; Format(x_array.a(points).time, "####.0")
    End If

    took_point_time = Timer
    Scr_Refresh x_array
    progress.mainmenu(5).Visible = False
    ' calculate FResult with regular Format function as opposed to Xformat
    ' since we don't need to add in spaces to keep things lines up.
    ' Xformat pads out the figures so that when the screen is updated multiple
    ' times, the changing numbers don't bounce around, but in the final result
    ' window these padded spaces make the result harder to read.
    If TType%(current_unit%) = 2 And TMode%(current_unit%) = 3 Then
        If debugRunCPass Then Print #mainDebugFile, "94"
        Dim strTestName As String
        Select Case penetrometer_select
            Case mullen_penetrometer
                strTestName = ts$(523) ' Mullen
            Case burst_penetrometer
                strTestName = ts$(526) ' Burst
            Case Else
                strTestName = ts$(83)  'Hydrohead
        End Select
        
'        FResult = ts$(83) + " " + ts$(229) + ": " + Format$((BUBBLEPT - P0) * PCNV, "###0.000  ") + PU$ ' "HydroHead Pressure"
        FResult = strTestName & " " & ts$(229) & ": " & Format$((BUBBLEPT - P0) * PCNV, "###0.000  ") & PU$ ' "HydroHead Pressure"
        'progress.Line26.Caption = "HydroHead Pressure: " + Xformat$((BUBBLEPT - P0) * PCNV, "###0.000  ") + PU$
        progress.Line26.Caption = FResult
    Else
        If (BUBBLEPT - P0) <> 0 Then
            If debugRunCPass Then Print #mainDebugFile, "95"
            FResult = ts$(127) + " " + ts$(229) + ": " + Format$((BUBBLEPT - P0) * PCNV, "###0.000  ") + "(" + PU$ + "), " + ts$(277) + ": " + Format$(0.58042 * tfactor * surfTen(current_unit%) / (BUBBLEPT - P0), "######0.000") + " (" + ts$(278) + "), " + ts$(74) + "=" + Format$(time_to_bubble, "####0.#") + " " + ts$(245) ' "Bubble Point Pressure"/"Diam"/"microns"/"time"/"seconds"
            'progress.Line26.Caption = "Bubble Point Pressure: " + Xformat$((BUBBLEPT - P0) * PCNV, "###0.000  ") + PU$ + "   Diam: " + Xformat$(0.58042 * tfactor * surften(current_unit%) / (BUBBLEPT - P0), "######0.000") + " microns, time=" + Format$(time_to_bubble, "####0.#") + " seconds"
            progress.Line26.Caption = FResult
            logFileResults(1) = 0.58042 * tfactor * surfTen(current_unit%) / (BUBBLEPT - P0)
            switchingToCapFlowSide = True
        End If
    End If
    
    If runAsPassFail(current_unit%) Then
        If debugRunCPass Then Print #mainDebugFile, "96"
        If Check_PassFail(0.58042 * tfactor * surfTen(current_unit%) / (BUBBLEPT - P0)) <> 0 Then
            If stopTestOnFail(current_unit%) Then           ' User wants test to end if it fails
                MsgBox ts$(450) + vbCrLf + ts$(451), 0, "Test Failed"     ' "Test failed. Bubble point was outside the specified range."/"test will now abort"
                HKey$ = "A"
                Aborted = True
                progress.sadface.Visible = True
                progress.happyface.Visible = False
            Else                                            ' Don't end test, but alert user to failure
                progress.Label4.Visible = True
                progress.Label4.ForeColor = vbRed
                progress.Label4.BackColor = vbBlack
                progress.Label4.Caption = ts$(175)      ' "Failed"
                progress.sadface.Visible = True
                progress.happyface.Visible = False
            End If
        Else
            progress.Label4.Visible = True
            progress.Label4.ForeColor = vbGreen
            progress.Label4.BackColor = vbBlack
            progress.Label4.Caption = ts$(174)      ' "Passed"
            progress.sadface.Visible = False
            progress.happyface.Visible = True
        End If
    End If
    
    lock_p0 = True
    progress.Line26.Refresh


    If LoopingDemo And (TType%(current_unit%) = 2) Then           '  looping BP demo test
        If debugRunCPass Then Print #mainDebugFile, "97"
        temp1 = (BUBBLEPT - P0) * PCNV
        temp2 = 0.58042 * tfactor * surfTen(current_unit%) / (BUBBLEPT - P0)
        fn1 = FreeFile
        Open "BubblePointDemo.txt" For Append As #fn1
        Print #fn1, Format$(str$(temp1), "###.###") + " " + PU$ + Space$(7) + Format$(str$(temp2), "####.###") + " microns" + Space$(7) + Format$(str$(now), "mm/dd/yy hh:mm")
        Close #fn1
        progress.Picture1.Cls
        waitseconds 15
        'time = Timer
        'While (Timer - time) < 15: Wend
        progress.List1.Visible = False
        progress.Picture1.Visible = True
        endPassCause = 12
        GoTo END_PASS
    End If
    
    If debugRunCPass Then Print #mainDebugFile, "98"
    If P - P0 > Maxpres Or f > MAXFLOW Or Aborted Then
        endPassCause = 13
        If P - P0 > Maxpres Then
            MsgBox "Current system pressure is greater than the maximum pressure set by the user!"
        End If
        If f > MAXFLOW Then
            MsgBox "Current flow is greater than MAXFLOW set by the user!"
        End If
        GoTo END_PASS
    End If
    If TType%(current_unit%) = 2 Then
        pass = 1
        endPassCause = 14
        GoTo END_PASS
    End If
    If debugRunCPass Then Print #mainDebugFile, "99"

    Rem new low flow wet curve portion
'JF Commenting out 8-2-11    If Not advanced_low_flow Then GoTo WDONE
    Rem we no longer use the advanced_low_flow
    'While EF < MaxLowFlow * 0.95 And HKey2$ <> "T"
    '    SP = lastp
    '    PT = curtime
    '    fsum = 0
    '    FlowN = 0
    '    progress.Refresh
    '    DoEvents
    '    If EF > BUBLFLOW * 0.25 Then BUBLFLOW = EF * 5
    '    If BUBLFLOW > MaxLowFlow Then BUBLFLOW = MaxLowFlow
    'WLOOP:
    '    ReadXReturnX4 2
    '    P = X5
    '    If X4 = 23000 Then GoTo END_PASS
    '    If P - P0 > Maxpres Then GoTo END_PASS
    '    ReadXReturnX4 FUSE%
    '    f = X5
    '    x = Timer
    '    fsum = fsum + (x - LastFlowTime) * (f + lastflow) / 2
    '    FlowN = FlowN + (x - LastFlowTime)
    '    LastFlowTime = x
    '    lastflow = f
    '    UpdateLine25
    '    If P > BBHigh Then BBHigh = P
    '    DoEvents
    '    If Aborted Then GoTo WDONE
    '    If f <= BUBLFLOW Then
    '        If f > flowmin Then
    '            flowmin = f '  flow went up while staying below zero point
    '            LastFIncTime = Timer
    '        Else
    '            If Timer < LastFIncTime Then LastFIncTime = LastFIncTime - 86400!  '  take care of day switch
    '            If Timer - LastFIncTime >= ZEROTIME Then
    '                '  now increase pressure slightly
    '                inc_reg 1
    '                DoEvents
    '                LastFIncTime = Timer
    '            End If
    '        End If
    '    End If
    '    If lastp < P Then lastp = P
    '    If Timer < PT Then PT = PT - 86400!  '  take care of day switch
    '    curtime = Timer
    '    elapsed = curtime - PT
    '    test_record
    '    If elapsed < 5 And HKey$ <> "R" Then GoTo WLOOP
    '    If curtime < LastFIncTime Then LastFIncTime = LastFIncTime - 86400
    '    If curtime - LastFIncTime < PulseDelay And HKey$ <> "R" Then GoTo WLOOP
    '    DoEvents
    '    Rem Average Flow = FSum / Flown cc/min
    '    Rem Change in Pressure = (LastP - SP) * 760 / 14.7 Torr
    '    Rem Time Interval = elapsed sec
    '    test_record
    '    If lastp - SP < 0.1 And elapsed < 10 And HKey$ <> "R" Then GoTo WLOOP
    '    If lastp <= SP Then
    '        X5 = 99999
    '        EF = fsum / FlowN
    '    Else
    '        X5 = fsum / FlowN * elapsed / (lastp - SP) / 760# * 14.7
    '        EF = (X5 - BUBLTIME) * (lastp - SP) / elapsed / 14.7 * 760#
    '        If EF > fsum / FlowN Then EF = fsum / FlowN
    '    End If
    '    Rem ESTIMATED FLOW THROUGH SAMPLE = EF cc/min
    '    If EF <= 0 Then EF = 0.001
    '    If TMode%(current_unit%) = 3 Then
    '       progress.Line26.Caption = "Ave. Flow In: " + Xformat$(fsum / FlowN, "##0.0000") + "  P Change=" + Xformat$((lastp - SP) * 60# * 27.7076 / elapsed, "####0.00") + " inH2O/min,  F/PT Factor: " + Xformat$(X5, "####0.00") + ",  Est. Thru Flow: " + Xformat$(EF, "###0.0000")
    '    Else
    '       progress.Line26.Caption = "Ave. Flow In: " + Xformat$(fsum / FlowN, "##0.0000") + ",  P Change=" + Xformat$((lastp - SP) * 760# / 14.7, "####0.00") + " Torr,  F/PT Factor: " + Xformat$(X5, "####0.00") + ",  Est. Thru Flow: " + Xformat$(EF, "###0.0000")
    '    End If
    '    'Progress.Line26.Caption = "Ave. Flow In: " + Xformat$(FSum / FlowN, "###0.00") + "  P Change=" + Xformat$((LastP - SP) * 760# / 14.7, "####0.00") + "  Bubltime Factor: " + Xformat$(X5, "####0.00") + "    Est. Thru Flow: " + Xformat$(EF, "####0.00")
    '    progress.Line26.Refresh
    '    f = EF
    '    pfdat.fl = EF
    '    pfdat.pr = P
    '    If use_fluid_sensor Then
    '       ReadXReturnX4 27
    '       pfdat.fluid = X5 - fluid_sensor_0
    '    End If
    '    points = points + 1
    '    If BBHigh > pfdat.pr Then pfdat.pr = BBHigh
    '    pfdat.eqd = 0
    '    Put #fn, points, pfdat
    '    took_point_time = Timer
    '    Scr_Refresh fn
    '    HKey$ = ""
    '    progress.mainmenu(5).Visible = False
    '    If P - P0 > Maxpres Or f > MAXFLOW Or Aborted Then GoTo END_PASS
    'Wend
WDONE:
    HKey2$ = ""
    'progress.Line26.Caption = "Bubble Point Pressure: " + Xformat$((BUBBLEPT - P0) * PCNV, "###0.000  ") + PU$ + "   Diam: " + Xformat$(0.58042 * TFactor * SURFTEN(current_unit%) / (BUBBLEPT - P0), "######0.00") + " microns"
    'progress.Line26.Refresh
3251
    'dw.addDebugStatement "Position 84A"
    'dw.addDebugStatement ts$(315) + " " + Xformat$(REGPOS, "####0") + " " + ts$(231)  ' "Regulator"/"counts"
    If debugRunCPass Then Print #mainDebugFile, "100"

    If bubbler_enable And bubbler_selected Then
        ' we need to open valve 25
        If debugRunCPass Then Print #mainDebugFile, "101"
        Move_Valve 24, "O"
        waitseconds 5
    End If
    
    'JF 1-26-2011 - Added in the third clause to the IF statement for Frazier tests
    '   so that they wouldn't open the motor valve all the way.
    If (PS_usingList Or runGP_SinglePoint) And Not TMode%(current_unit%) = 20 Then
        If debugRunCPass Then Print #mainDebugFile, "102"
        PULSEWIDTH = 0
        V2INCR = 100
    End If
    
    If pass = 0 Then                       ' First half of test
        pass = 1                           ' Second half of test
        If TType%(current_unit%) = 2 Then
            endPassCause = 15
            GoTo END_PASS         ' Bubble point/integrity/hydrohead only has one pass
        End If
    End If
    'If TType%(current_unit%) = 2 And TMode%(current_unit%) = 2 Then
    '    For REGOUT = 1 To PREGINC: Inc_Reg 1: Next REGOUT
    '    GoTo 3200
    'End If
    'dw.addDebugStatement "Position 84"
    'dw.addDebugStatement ts$(315) + " " + Xformat$(REGPOS, "####0") + " " + ts$(231)  ' "Regulator"/"counts"
    If debugRunCPass Then Print #mainDebugFile, "103"
    ReadXReturnX4 3
    DoEvents
    'If X4 > OLIMIT Then Test_Done
    FLAST = f
    plast = P
    If Not hfbp Then V2POS = SV2P
    If REGPOS < 0 Then REGPOS = 0
    If PULSEWIDTH = 0 Or v2solenoid Then
        If debugRunCPass Then Print #mainDebugFile, "104"
    
    'dw.addDebugStatement "Position 85"
    'dw.addDebugStatement ts$(315) + " " + Xformat$(REGPOS, "####0") + " " + ts$(231)  ' "Regulator"/"counts"
        Zero_Reg
        Rem set valve to desired starting position
        If Not (runGP_SinglePoint And useNewSinglePointRoutine) Then
            If debugRunCPass Then Print #mainDebugFile, "105"
            V2POS = cLimit + (oLimit - cLimit) * V2INCR / 100
            If V2INCR >= 100 Then
                V2POS = oLimit
                openv2completely
            Else
                OpenV2Pos  '4
            End If
        Else
            If debugRunCPass Then Print #mainDebugFile, "106"
            close_v2_completely
            Call Zero_Reg
        End If
    'End If
    ElseIf (Not hfbp) And pass = 1 And (Not ip_reg_enable) Then
        If debugRunCPass Then Print #mainDebugFile, "107"
        ' after normal bubble point, decrease regulator until less than 1 cc/min
        ' don't lower more than 30 times
        i% = 30
        Do
            lower_reg 20
            ReadXReturnX4 0
            If x5 < 1# Then Exit Do
            ReadXReturnX4 2
            i% = i% - 1
        Loop While (x5 >= BUBBLEPT) And (i% > 0)
        ' increment the regulator just once
        inc_reg 20
        ' set REGPOS as if we are at the proper point
        If REGPOS < SHFP Then REGPOS = SHFP
    End If
    If newreg Then
        If debugRunCPass Then Print #mainDebugFile, "108"
        ' this will go to whichever is greater - the SHFP or SBPP or the
        ' current regulator position.
        reg_goto_up (SHFP)
        reg_goto_up (SBPP)
    ElseIf PULSEWIDTH <> 0 And v2solenoid = False Then
        If debugRunCPass Then Print #mainDebugFile, "109"
        If ip_reg_enable Then
            If debugRunCPass Then Print #mainDebugFile, "110"
            ' if the regulator is too low, set it to at least SBPP
            ' we may want this to be the SHFP instead if this leads to too much starting
            ' pressure in the dry curve.
            ' 6.71.83 scales between SBPP and SHFP
            preg_start_point = (first_flow_starting_point_percent - 10) / 90 * (SBPP - SHFP) + SHFP
            If preg_start_point < 0 Then preg_start_point = 0
            If preg_start_point > 4000 Then preg_start_point = 4000
            If REGPOS < preg_start_point Then inc_reg preg_start_point - REGPOS
            ' if the regulator is too high (like we just finished the bubble point)
            '  set regulator down to the bubble point pressure plus a little more
            ' This requires that we have an actual bubble point already known
            If BUBBLEPT > P0 Then
                If debugRunCPass Then Print #mainDebugFile, "111"
                l_temp = regpos_from_p(0)
                If l_temp < 0 Then l_temp = 0
                l_temp = regpos_from_p(BUBBLEPT - P0) + preg_start_point - l_temp
                If l_temp > 4000 Then l_temp = 4000
                If l_temp < 0 Then l_temp = 0
                If REGPOS > l_temp Then lower_reg REGPOS - l_temp
            End If
        Else
            While REGPOS < SHFP: inc_reg 1: Wend   '  initialize regulator
        End If
    ElseIf v2solenoid = True And ip_reg_enable = True Then
        If debugRunCPass Then Print #mainDebugFile, "112"
        ' set the regulator to bubblepoint pressure point
        l_temp = regpos_from_p(BUBBLEPT - P0)
        If l_temp < 0 Then l_temp = 0
        If l_temp > 4000 Then l_temp = 4000
        If REGPOS > l_temp Then lower_reg REGPOS - l_temp
    End If
    'End If
    '  first, set to use high flow meter
    FUSE% = 1
   
    Move_Valve 0, "C"
    If low_flow_controller Then zero_lfctrl
    'vpos(1) = 0
    FUSE% = 1
   
    ' 6.71.20 begin
    hfmin% = 0: HFLOW% = 1 ' always use low range of hflow1 to start for now
    If debugRunCPass Then Print #mainDebugFile, "113"
    If xhflow And MAXFLOW > MaxHighFlow Then
        If debugRunCPass Then Print #mainDebugFile, "114"
        If switch_high_flow_enabled Then
            If debugRunCPass Then Print #mainDebugFile, "115"
            using_hflow1 = True
        Else
            If debugRunCPass Then Print #mainDebugFile, "116"
            using_hflow1 = False
            hfmin% = 2: HFLOW% = 3
        End If
    Else
        'hfmin% = 0: HFLOW% = 1
        If debugRunCPass Then Print #mainDebugFile, "117"
        using_hflow1 = False ' we are actually using hflow1, but this means we don't switch to hflow2 later on
    End If
    hflow1_max_index = 0 ' we haven't recorded any secondary flow data yet
    suspend_v10 = False ' move v10 normally -just in case
    ' 6.71.20 end
    'end of bubble point routine

    '  3300 is alternate entrance for continuation of a test.
    ' before this, we check to see if we need to close the integrity bypass valve
3299
    'dw.addDebugStatement "Position 90"
    'dw.addDebugStatement ts$(315) + " " + Xformat$(REGPOS, "####0") + " " + ts$(231)  ' "Regulator"/"counts"
    If integrity_porometry Then
        If debugRunCPass Then Print #mainDebugFile, "118"
        Move_Valve 19, "C"
        FUSE% = 0
     
        lflow% = 1
    End If
    ' 2-7-07 if there are no data points yet, insert a 0,0 data point
    ' so the dry curve always starts at the origin
    If points = 0 Then
        If debugRunCPass Then Print #mainDebugFile, "119"
        points = points + 1
        dat_size_check x_array, points
        x_array.a(points).fl = 0
        x_array.a(points).fl2 = 0 ' just in case
        x_array.a(points).pr = P0
        
        'AJB 10-20-09 6.71.130
        If dryChamberTemperature <> 0 Then x_array.a(points).temp1 = readNewTemperature(dryChamberTemperature)
        If airTemperature <> 0 Then x_array.a(points).temp2 = readNewTemperature(airTemperature)
        'AJB 10-20-09 6.71.130
        
        If hasHumidityControls And enableHumidityControlForAutoTests Then
            If debugRunCPass Then Print #mainDebugFile, "120"
                
            goToTargetHumidity
            
            'ReadXReturnX4 1 're-read current flow
            'x_array.a(points).fl = x5
            
            'ReadXReturnX4 2 're-read current pressure
            'x_array.a(points).pr = x5
            
            x_array.a(points).humidity = lastGoodHumidity
            
            Print #55, x_array.a(points).fl & Chr(9) & x_array.a(points).pr & Chr(9) & x_array.a(points).humidity & Chr(9) & Format$(getBubblerMVPosition(), "##0.00%") & Chr(9) & goToHumidityCounter & Chr(9); goToHumidityWaitTimeCounter & Chr(9) & REGPOS & Chr(9) & Format$(getMV2Position(), "##0.00%") & Chr(9) & lfcpos
            
        ElseIf hasHumidityControls And recordHumidityForAutoTests Then
            'just read humidity sensor and record the point, don't try to correct the humidity by calling goToTargetHumidity
            If debugRunCPass Then Print #mainDebugFile, "121"
            x_array.a(points).humidity = readHumiditySensor
        End If
        
        If use_fluid_sensor Then
            ReadXReturnX4 27
            x_array.a(points).fluid = x5 - fluid_sensor_0
        End If
        x_array.a(points).eqd = 0
        x_array.a(points).time = Timer
        took_point_time = Timer
        Scr_Refresh x_array
    End If
3300
    If debugRunCPass Then Print #mainDebugFile, "122"
    'dw.addDebugStatement "Position 91"
    'dw.addDebugStatement ts$(315) + " " + Xformat$(REGPOS, "####0") + " " + ts$(231)  ' "Regulator"/"counts"
    If skipincrease Then
        skipincrease = False ' only skip one increase
        If stability_debug Then stabilitydebug.Label1.Caption = "Skipping the increase"
        GoTo 3309
    End If
    If V2INCR < 0 Then
        GoTo 3305
    ElseIf PULSEWIDTH = 0 Then
        GoTo 3302
    End If
    If debugRunCPass Then Print #mainDebugFile, "123"
    
    V2POS = V2POS + V2INCR * V2FACTR * ver1or3
    ReadXReturnX4 3
    If x4 >= V2POS Then V2POS = x4 + 1
    If V2POS >= oLimit Then
        If debugRunCPass Then Print #mainDebugFile, "124"
        If hasMultipleMVs And numberOfMotorValves = 3 And motorValveIndex = 1 And Not switchingMVs Then
            switchToMv3
        Else
            V2POS = oLimit
            openv2completely
            GoTo 3302
        End If
    End If
    
    OpenV2Pos  '5
    If stability_debug Then stabilitydebug.Label1.Caption = "Increasing valve 2"
    GoTo 3309
3302
    If debugRunCPass Then Print #mainDebugFile, "125"
    'dw.addDebugStatement "Position 92"
    'dw.addDebugStatement ts$(315) + " " + Xformat$(REGPOS, "####0") + " " + ts$(231)  ' "Regulator"/"counts"
    If PS_usingList Or runGP_SinglePoint Then GoTo 3309
    
''''''''''''''''''geopore stuff here
    If f > geoFlow And geoPoreValve = True And geoPoreStuff = False Then
        Call Send_RS232("SB")
        Waitms 250, False
        geoRegCounts = REGPOS
        Zero_Reg
      
        Waitms 250, False
        Move_GeoValves "O"
        geoValveClosed = False
        Waitms 250, False
        inc_reg 100
        geoPoreStuff = True
    End If
    
    If special_pulse Then
        If debugRunCPass Then Print #mainDebugFile, "126"
        inc_reg 10
    Else
        If ip_reg_enable Then
            If debugRunCPass Then Print #mainDebugFile, "127"
            REGOUT = Int(preginc * preg_fact * fifty_or_seven)
            inc_reg REGOUT
        Else
            If debugRunCPass Then Print #mainDebugFile, "128"
            manrunning = True
            For REGOUT = 1 To preginc * preg_fact - 1
                inc_reg 1
            Next REGOUT
            manrunning = False
            inc_reg 1
        End If
    End If
    If stability_debug Then stabilitydebug.Label1.Caption = "Pulsing the regulator"
    GoTo 3309
3305
    If debugRunCPass Then Print #mainDebugFile, "129"
'DRYDOWN
    If ip_reg_enable Then 'And Not geoPoreValve Then
        If debugRunCPass Then Print #mainDebugFile, "130"
        ' for dry down, decrement the regulator by the amount in the parameter
        ' file
        REGOUT = Int(preginc * fifty_or_seven)
        lower_reg REGOUT
        lowered = lowered + 1
'        If geoPoreValve And f < geoFlow And geoValveClosed = False Then
        If lowered >= geoIncrease And geoPoreValve And Not (TType(current_unit%) = 1 And (TMode(current_unit%) = 1 Or TMode(current_unit%) = 5)) Then
            Zero_Reg
            Move_GeoValves "C"
            If geoFlowMeterSwitch = True Then
                FUSE% = 0
          
            End If
            inc_reg geoRegCounts
            Waitms 1000, False
            geoValveClosed = True
        End If
        ' and also close valve 2 an amount that will bring it to the close limit
        ' in the same number of iterations as are left on the regulator
        ' The number of iterations left on the regulator is REGPOS/preginc
        ' The current position of valve 2 is v2pos
        ' the close limit of valve 2 is climit
        ' so we want to lower v2pos by (v2pos-climit)/(regpos/preginc)
        ' if regpos is already 0, we want to set v2pos to the close limit
        If geoValveClosed And geoPoreValve Then
            If REGPOS = 0 Then
                V2POS = cLimit
            Else
                V2POS = V2POS - (V2POS - cLimit) / (REGPOS / preginc / fifty_or_seven)
            End If
            Move2V2Pos
        End If
        
    Else
        If debugRunCPass Then Print #mainDebugFile, "131"
    
        manrunning = True
        For REGOUT = 1 To preginc - 1
            lower_reg 1
        Next REGOUT
        manrunning = False
        lower_reg 1
    End If
    If REGPOS > 0 Or PULSEWIDTH = 0 Then
        GoTo 3309
    Else
        If debugRunCPass Then Print #mainDebugFile, "132"
        If V2POS >= oLimit Then
            If debugRunCPass Then Print #mainDebugFile, "133"
            '  close valve 2 until flow drops by 5%
            ReadXReturnX4 2
            P = x5
            ReadXReturnX4 FUSE%
            f = x5
            UpdateLine25 usingWetSample
            If P > BBHigh Then BBHigh = P
            PStart = P: FSTART = f
            Do
            If geoValveClosed Then
                V2POS = V2POS - DAC_span / 20
                Move2V2Pos
            End If
                ReadXReturnX4 2
                P = x5
                ReadXReturnX4 FUSE%
                f = x5
                'for geopore
                If geoPoreValve And f < geoFlow Then
                    Move_GeoValves "C"
                    'CHANGING FLOW METER FOR GEOPORE
                    If geoFlowMeterSwitch = True Then
                        FUSE% = 0
                      
                    End If
                    geoValveClosed = True
                End If
                DoEvents
                UpdateLine25 usingWetSample
                If P > BBHigh Then BBHigh = P
            Loop While (f > FSTART * 0.95) And (P > PStart * 0.95) And V2POS > cLimit + (oLimit - cLimit) / 100
            V2POS = V2POS + DAC_span / 20
            OpenV2Pos  '6
            P = PStart: f = FSTART
            UpdateLine25 usingWetSample
            If P > BBHigh Then BBHigh = P
        End If
    End If
    V2POS = V2POS + V2INCR * V2FACTR * ver1or3
    If V2POS <= cLimit + (oLimit - cLimit) / 100 Then
        If debugRunCPass Then Print #mainDebugFile, "134"
        endPassCause = 16
        GoTo END_PASS
    End If
    Move2V2Pos
    If V2FACTR > 0.5 Then V2FACTR = V2FACTR - 0.1
    
    
3309
    If debugRunCPass Then Print #mainDebugFile, "135"
    ' JF START WORK HERE for Gurley
    
    ' If we're using a pressure list, make sure we've reached our next value.
    ' The meat of the step list routine is in this section. Note that raising the pressure
    ' is done very slowly to avoid overshoot. This should be improved if possible, or at
    ' least make the tolerances and delays adjustable.
    If PS_usingList Or runGP_SinglePoint Then
        If debugRunCPass Then Print #mainDebugFile, "136"
        If runGP_SinglePoint And useNewSinglePointRoutine Then
            If debugRunCPass Then Print #mainDebugFile, "137"
            Run_GP_SinglePoint x_array
            endPassCause = 160
            GoTo END_PASS
        Else
            If debugRunCPass Then Print #mainDebugFile, "138"
            ' If we've taken the last point, exit the pass
            If (step_index > pressure_steps.count) Then
                If debugRunCPass Then Print #mainDebugFile, "139"
                If bubbler_enable Then
                    Move_Valve 24, "C"
                    waitseconds 5
                End If
                Zero_Reg
                endPassCause = 17
                GoTo END_PASS
            End If
            
            ' 6.71.68: This block is copied from elsewhere in run_c_pass: does a regulator
            ' switch if we're using a dual regulator system and we've maxed out the first one.
            If ip_reg_enable And REGPOS >= 4000 Then
                If debugRunCPass Then Print #mainDebugFile, "140"
                ' if we are already at 4000 counts, see if we can switch regulators
                If dualregulator And using_low_regulator Then
                    If debugRunCPass Then Print #mainDebugFile, "141"
                    '' decrease regulator to the second_regulator_starting_point
                    'lower_reg 4000 - second_regulator_starting_point
                    ' now, decrease regulator to reg2_high_flow_switch_count
                    'lower_reg 4000 - reg2_high_flow_switch_count
                    'waitseconds 3
                    'Move_Valve 16, "O"
                    'waitseconds 10
                    'regnum = 1
                    'fifty_or_seven = 7
                    'SBPP = SBPP2
                    'SHFP = SHFP2
                    'using_low_regulator = False
                    If debugRunCPass Then
                        Print #mainDebugFile, "Switch Regulators 2"
                    End If
                    SwitchRegulators "2"
               '     GoTo 4600 ' skip next pressure regulator increment
                Else
                    If debugRunCPass Then Print #mainDebugFile, "142"
                    ' we might as well end the test since we can't go up any more
                    HKey$ = " "
                    HKey2$ = " "
                    If bubbler_enable Then
                        Move_Valve 24, "C"
                        waitseconds 5
                    End If
                    Zero_Reg
                    endPassCause = 18
                    GoTo END_PASS
                End If
            End If
            
            If debugRunCPass Then Print #mainDebugFile, "143"
            ' Get flow and pressure, then correct for lohm
            ReadXReturnX4 2
            P = x5
            ReadXReturnX4 FUSE%
            
            f = x5
        
            P = CVcalc(P, f)
            UpdateLine25 usingWetSample
            ' If we're not there yet, loop back to v2 and preg increments
            If (P - P0) < pressure_steps.values(step_index) Then
                If debugRunCPass Then Print #mainDebugFile, "144"
                ' move_motorized_regulator_to_pressure (pressure_steps.values(step_index) - 0.15)
                ' 10-24-06 changed from absolute 0.15 PSI to .15% of full scale of main pressure gauge
                If newreg Then
                    move_motorized_regulator_to_pressure (pressure_steps.values(step_index) - (0.0015 * (PY2(0) - P0)))
                End If
                    
                waitseconds 5
                ReadXReturnX4 2
                P = x5
                ReadXReturnX4 FUSE%
                f = x5
                P = CVcalc(P, f)
                
                regulator_increment_value = Int(preginc * fifty_or_seven)
                pressure_increase = pressure_steps.values(step_index)
                target_pressure = pressure_increase + P0
                
                ' regulator_initial_value = regpos_from_p(pressure_increase)
                regulator_initial_value = new_regpos_from_p(pressure_increase)
                inc_reg regulator_initial_value
                
                If debugRunCPass Then Print #mainDebugFile, "145"
                
                While (P - P0) < (0.999 * pressure_increase)
                
                    ' 6.71.68: This block is copied from elsewhere in run_c_pass: does a regulator
                    ' switch if we're using a dual regulator system and we've maxed out the first one.
                    If ip_reg_enable And REGPOS >= 4000 Then
                        ' if we are already at 4000 counts, see if we can switch regulators
                        If dualregulator And using_low_regulator Then
                            If debugRunCPass Then Print #mainDebugFile, "146"
                            '' decrease regulator to the second_regulator_starting_point
                            'lower_reg 4000 - second_regulator_starting_point
                            ' now decrease regulator to reg2_high_flow_switch_count
                            'lower_reg 4000 - reg2_high_flow_switch_count
                            'waitseconds 3
                            'Move_Valve 16, "O"
                            'waitseconds 10
                            'regnum = 1
                            'fifty_or_seven = 7
                            'SBPP = SBPP2
                            'SHFP = SHFP2
                            'using_low_regulator = False
                            If debugRunCPass Then Print #mainDebugFile, "Switch Regulators 3"
                            SwitchRegulators "3"
                       '     GoTo 4600 ' skip next pressure regulator increment
                        Else
                            If debugRunCPass Then Print #mainDebugFile, "147"
                        
                            ' we might as well end the test since we can't go up any more
                            HKey$ = " "
                            HKey2$ = " "
                            If bubbler_enable Then
                                Move_Valve 24, "C"
                                waitseconds 5
                            End If
                            Zero_Reg
                            endPassCause = 19
                            GoTo END_PASS
                        End If
                    End If
                    
                    'Check if the last increment size is too big for the next increment and adjust it
                    frazierDelayTime = 1
                    If runGP_SinglePoint Then
                        ' start work here.  increase by 10's, then 5's, then 1's
                        If (P - P0) < (0.5 * pressure_increase) Then

                            inc_reg 10
                            frazierDelayTime = 1
                        ElseIf (P - P0) < (0.85 * pressure_increase) Then
                            inc_reg 5
                            frazierDelayTime = 5
                        Else
                            inc_reg 1
                            frazierDelayTime = 10
                        End If
                    Else
                        inc_reg regulator_increment_value
                    End If
                    waitseconds frazierDelayTime
                    ReadXReturnX4 2
                    P = x5
                    ReadXReturnX4 FUSE%
                    f = x5
                
                    P = CVcalc(P, f)
                    UpdateLine25 usingWetSample
                Wend
            End If
            step_index = step_index + 1
            
            ' Wait for the target temperature - Mix
            If Athena1InTest And Not Athena1NeverInTest Then
                WaitForAthenaTemp Athena1Channel, Athena1Target
            End If
            If Athena2InTest And Not Athena2NeverInTest Then
                WaitForAthenaTemp Athena2Channel, Athena2Target
            End If
            
            '**** here *****
            ' If we're doing a single point gas perm test (for Sam Bo, originally), then
            ' bring up our special form, run the test, and exit
            If runGP_SinglePoint Then
                If debugRunCPass Then Print #mainDebugFile, "148"
                singlePointGasTest.Show 0
                do_average_test P0, diffPAtmos, x_array
                Unload singlePointGasTest
                GoTo 3309
            End If
        End If
    End If          ' Pressure step routine
                
    ' remove any lingering "Record" button keypresses since we have just started a new point
    DoEvents
    HKey$ = " "
    took_point_time = Timer

    If runefdjump Then
        EFD_Jump
        runefdjump = False
    End If
3310
    If debugRunCPass Then Print #mainDebugFile, "149"

    ' return stable pressure and flow rate with new 0 and 1 type eq
    PSR.n = 0
    eqdone% = -1 ' none set yet
    ReadXReturnX4 FUSE% ' read flow rate first and store it in F
    f = x5
   
    ReadXReturnX4 2 ' now read in the pressure and leave the value in x5
                    ' because that is what the remaining code is expecting
    If autocompress And compression_pressure <> 0 And Compression_Increase_Factor > 0 Then test_compression_pressure x5 - P0
    ' skip stability and data storage if under minimum pressure
    ' and we are going up
    ' and we are not calling this as a subroutine from integrity test
    ' and we are not at the limit of the ip regulator
    ' and we are using the minimum pressure for the dry curve
    If V2INCR > 0 And PROGRAMCTRL <> 4600 And _
       (ip_reg_enable = False Or REGPOS < 4000) And _
       ((x5 - P0 < minp_set(current_unit%) And use_min_pressure_in_dry) Or _
       (f < min_flow_in_dry And use_min_flow_in_dry)) Then
        If debugRunCPass Then Print #mainDebugFile, "150"
         
        If stability_debug Then stabilitydebug.Label1.Caption = "Stability Method skipped - pressure or flow too low"
        
        If x5 - P0 < best_seen_low_pressure + max_p_drop_seen Then
            inc_reg Int(fifty_or_seven / 2.5) ' was 20
        ' if we are already more than 5% past the starting valve 2 position
        ' then increase the regulator anyway
        ElseIf V2POS > SV2P + DAC_span / 20 Then
            inc_reg Int(fifty_or_seven / 2.5) ' was 20
        End If
        If x5 - P0 > best_seen_low_pressure Then
            best_seen_low_pressure = x5 - P0
        ElseIf x5 - P0 < best_seen_low_pressure - max_p_drop_seen Then
            max_p_drop_seen = best_seen_low_pressure - (x5 - P0)
        End If
        P = x5
        P = CVcalc(P, f)
        UpdateLine25 usingWetSample
        GoTo 3300
    End If
    X1FIRST = x4
    x1first_lockin = False
    T = Timer
    DoEvents
    If AVEITER = 0 Then
        If debugRunCPass Then Print #mainDebugFile, "151"
    
        ' read flow twice and note direction it is going in
        ' wait until it changes direction eqiter number of times
        ' or until time elapsed=mineqtime
        ' 1) read first flow into F1
        ' also read pressure twice and note direction it is going in
        ' and do same thing with it, but if this is the wet curve, don't
        ' let the pressure fall too much.  (Call the pressure stable if it
        ' falls more than 10 counts from maximum so far.)
        ReadXReturnX4 FUSE%
        f = x5: f1 = f
   
        If x4 = DAC_over Then GoTo ENDOFSTABILITY2
        ReadXReturnX4 2
        P = x5
        If autocompress And compression_pressure <> 0 And Compression_Increase_Factor > 0 Then test_compression_pressure P - P0
        max_count_p = x4
        If x4 = DAC_over Then GoTo ENDOFSTABILITY2
        P = CVcalc(P, f)
        max_val_p = P
        p1 = P
        UpdateLine25 usingWetSample
        If P > BBHigh Then BBHigh = P
        DoEvents
        ' 2) read second flow into F2 (and make sure it is different from F1)
        Do
            ReadXReturnX4 FUSE%
            f = x5: f2 = f
   
            If x4 = DAC_over Then GoTo ENDOFSTABILITY2
            ReadXReturnX4 2
            P = x5
            If autocompress And compression_pressure <> 0 And Compression_Increase_Factor > 0 Then test_compression_pressure P - P0
            If x4 = DAC_over Then GoTo ENDOFSTABILITY2
            P = CVcalc(P, f)
            p2 = P
            UpdateLine25 usingWetSample
            If P > BBHigh Then BBHigh = P
            DoEvents
            test_record
        Loop Until HKey$ = "R" Or Aborted Or HKey2$ = "T" Or f2 <> f1 Or p2 <> p1
        num_times_reversed% = 0
        num_times_reversed_p% = 0
        Do
            ' exit if time has elapsed
            If Timer - T > mineqtime Then GoTo ENDOFSTABILITY2
            If EQITER <= num_times_reversed% And EQITER <= num_times_reversed_p% Then GoTo ENDOFSTABILITY2
            ReadXReturnX4 FUSE%
            f = x5
            
            ' exit if maximum flow reached
            If x4 = DAC_over Then GoTo ENDOFSTABILITY2
            ReadXReturnX4 2
            P = x5
            If autocompress And compression_pressure <> 0 And Compression_Increase_Factor > 0 Then test_compression_pressure P - P0
            ' exit if maximum pressure reached
            If x4 = DAC_over Then GoTo ENDOFSTABILITY2
            P = CVcalc(P, f)
            UpdateLine25 usingWetSample
            If P > BBHigh Then BBHigh = P
            If x4 >= max_count_p Then max_count_p = x4: max_val_p = P
            If pass = 1 And x4 < max_count_p - 10 * ver1or3 Then
                P = max_val_p
                GoTo ENDOFSTABILITY2
            End If
            DoEvents
            If Sgn(f1 - f2) <> Sgn(f2 - f) Or f1 = f2 Then
                num_times_reversed% = num_times_reversed% + 1
                ' now last direction is based on F2 and F so
                f1 = f2 ' first flow = last flow
            End If
            f2 = f  ' last flow = current flow
            If Sgn(p1 - p2) <> Sgn(p2 - P) Or p1 = p2 Then
                num_times_reversed_p% = num_times_reversed_p% + 1
                ' now last direction is based on P2 and P so
                p1 = p2 ' first pressure = last pressure
            End If
            p2 = P  ' last pressure = current pressure
            DoEvents
            test_record
            If HKey$ = "R" Or Aborted Then HKey$ = " ": GoTo ENDOFSTABILITY2
        Loop
        If debugRunCPass Then Print #mainDebugFile, "152"
        
    ElseIf diffpgflow(current_unit%) Then
        If debugRunCPass Then Print #mainDebugFile, "153"
    
        ' use differential pressure gauge to get the flow rate
        ' if we incremented, wait 4 seconds for things to stabilize a bit
        If Not skipincrease Then
            waitseconds 10
        End If
        ' real first, read the initial pressure on the pressure gauge
        ReadXReturnX4 2
        p1 = x5
        
        ' Jumps back to pressure increase if the current pressure is less than the BP
        If p1 < BUBBLEPT Then
            skipincrease = False
            GoTo 3300
        End If
        
        ' calculate out how much pressure has been added to the top chamber
        currentPressureIncrease = p1 - P0
        initAbsP = p1
        ' then read the real initial pressure on the differential pressure gauge
        ' so we know how much the pressure really goes up for back pressure
        ReadXReturnX4 13 + dpgplus%
        f0 = x5
        ' then, close the vent valve
        'MsgBox "Closing venting valve to start flow measurement"
        Move_Valve 13, "C"
        ' third, read the initial pressure on the differential pressure gauge
        '  and record the time.
        ReadXReturnX4 13 + dpgplus%
        f1 = x5
        initDiffP0 = f1
        T = Timer
        ' fourth, wait for the differential pressure gauge to get to 0.5 PSI
        '  or 30 seconds, whichever comes first, and record the final pressure
        '  on the differential pressure gauge and the elapsed time
        initial_offset% = 0
        Do
            DoEvents
            ReadXReturnX4 13 + dpgplus%
            local_time = Timer
            f2 = x5
            
            If x4 = DAC_over Then HKey$ = "T"
            
            If (local_time + 0.1 < T) Then
                T = T - 86400
            End If
            
            If (local_time - T > 2) And (initial_offset% = 0) Then
                initial_offset% = 1
                F_at_2 = x5
                T_at_2 = local_time
            End If
            
            If (local_time - T > 4) And (initial_offset% = 1) Then
                f1 = F_at_2
                T = T_at_2
                initial_offset% = 2
            End If
            
            If (local_time - T > 2) Then
                ReadXReturnX4 2
                P = x5 - (f2 - f0)
                f = (f2 - f1) / (local_time - T) * 60 / 14.7 * Diff_Volume(manuallySelectedChamber + Current_Microflow_Volume_Index - 1)
                diffp = f2 - f1
                UpdateLine25 usingWetSample
            End If
        Loop While (local_time - T < 30) And (f2 - f1 < 0.5 * (PY2(4) - PY1(4))) And _
                   (f2 - diffPAtmos) < (currentPressureIncrease * 0.9) And _
                   (Not Aborted) And _
                   ((f2 - PY1(4)) < 0.95 * (PY2(4) - PY1(4)))
        ' fifth, read the final pressure on the pressure gauge
        ReadXReturnX4 2
        p2 = x5 - (f2 - f0)
        
        initDiffP = f1
        finalAbsP = x5
        finalDiffP = f2
        
        diffAbsP = finalAbsP - initAbsP
        diffDiffP = finalDiffP - initDiffP
                
        ' sixth, open the vent valve and calculate the flow and the average
        '  pressure as a stable value
        Move_Valve 13, "O"
        If debugRunCPass Then Print #mainDebugFile, "154"
        
        If currentPressureIncrease > ((PY2(4) - PY1(4)) * 0.01) Then
            If debugRunCPass Then Print #mainDebugFile, "155"
        
            If (local_time - T) < 1 Then
                If threestagetest(current_unit%) Then
                    diffpgflow(current_unit%) = False
                Else
                    HKey2$ = "T"
                    f = 99999
                End If
                If microFlowUseAllVolumes Then
                    select_next_microflow_volume
                    progress.lblMicroflowVolume.Caption = "Volume " + str(Current_Microflow_Volume_Index)
                End If
            ElseIf local_time - T < 5 Then
                If microFlowUseAllVolumes Then
                    select_next_microflow_volume
                    progress.lblMicroflowVolume.Caption = "Volume " + str(Current_Microflow_Volume_Index)
                End If
            Else
                f = (f2 - f1) / (local_time - T) * 60 / 14.7 * Diff_Volume(manuallySelectedChamber + Current_Microflow_Volume_Index - 1)
            End If
        Else
            If debugRunCPass Then Print #mainDebugFile, "156"
        
            f = (f2 - f1) / (local_time - T) * 60 / 14.7 * Diff_Volume(manuallySelectedChamber + Current_Microflow_Volume_Index - 1)
        End If
        
        ' If the pressure rose by too much, we mark the flag so that we don't
        '  increase the valve or regulator any for the next data point.
        If (p2 - p1) * Sgn(V2INCR) > MAXPDIF Then
            If debugRunCPass Then Print #mainDebugFile, "157"
        
            skipincrease = True 'MsgBox "Pressure rose too much - skipincrease turned on"
        Else
            If debugRunCPass Then Print #mainDebugFile, "158"
            skipincrease = False 'MsgBox "Pressure did not rise too much - skipincrease turned off"
        End If
        P = (p1 + p2) / 2
        diffp = f2 - f1
        UpdateLine25 usingWetSample
        
        'JF Micro Debug
        timediff = local_time - T
        If mfDebugFile <> -1 Then
            Print #mfDebugFile, str$(timediff) + vbTab + str$(initDiffP0) + vbTab + str$(initDiffP) + vbTab + str$(finalDiffP) + vbTab + str$(diffDiffP) + _
                vbTab + str$(initAbsP) + vbTab + str$(finalAbsP) + vbTab + str$(diffAbsP) + vbTab + str$(f) + _
                str$(Diff_Volume(manuallySelectedChamber + Current_Microflow_Volume_Index - 1)) + vbTab + _
                str$(Current_Microflow_Volume_Index)
        End If
        
        GoTo ENDOFRETSTABLEPRES
    ElseIf EQITER = 1 Then
        If debugRunCPass Then Print #mainDebugFile, "159"
    
        '  fast stability system for when eqiter=1
        ReadXReturnX4 2
        p1 = x5: P1X4 = x4
        ReadXReturnX4 FUSE%
        f1X4 = x4: f1 = x5
        ReadXReturnX4 2
        p2 = x5: P2X4 = x4
        Do
            ReadXReturnX4 FUSE%
            f2 = x5: f2X4 = x4
            ReadXReturnX4 2
            P3 = x5
            P3X4 = x4
            If autocompress And compression_pressure <> 0 And Compression_Increase_Factor > 0 Then test_compression_pressure P3 - P0
            If P3X4 = DAC_over Then GoTo ENDOFSTABILITY1
            If f2X4 = DAC_over Then x4 = DAC_over: GoTo ENDOFSTABILITY1
            P = (p1 + p2 + P3) / 3
            f = (f1 + f2) / 2
            P = CVcalc(P, f)
            UpdateLine25 usingWetSample
            If P > BBHigh Then BBHigh = P
            DoEvents
            If Timer - T > mineqtime Then GoTo ENDOFSTABILITY1
            'If pass = 1 And (P - P0) < ((plast - P0) * .8) Then GoTo ENDOFSTABILITY1
            If pass = 1 And (plast - P) > 0.5 Then GoTo ENDOFSTABILITY1
            test_record
            If HKey$ = "R" Or Aborted Then HKey$ = " ": GoTo ENDOFSTABILITY1
            If Abs(P1X4 - P2X4) <= PRESSLEW * ver1or3 And Abs(f1X4 - f2X4) <= flowslew * ver1or3 And Abs(P1X4 - P3X4) <= PRESSLEW * ver1or3 And Abs(P2X4 - P3X4) <= PRESSLEW * ver1or3 Then GoTo ENDOFSTABILITY1
            p1 = p2
            f1 = f2
            p2 = P3
            P1X4 = P2X4
            P2X4 = P3X4
            f1X4 = f2X4
        Loop
ENDOFSTABILITY1:
        If debugRunCPass Then Print #mainDebugFile, "160"

    ElseIf EQITER = 0 Then
        If debugRunCPass Then Print #mainDebugFile, "161"
    
        ReadXReturnX4 2
        p1 = x5
        P1X4 = x4
        Do
            ReadXReturnX4 FUSE%
            f = x5
            If x4 = DAC_over Then GoTo ENDOFSTABILITY2
            ReadXReturnX4 2
            p2 = x5
            P2X4 = x4
            If autocompress And compression_pressure <> 0 And Compression_Increase_Factor > 0 Then test_compression_pressure p2 - P0
            DoEvents
            If P2X4 = DAC_over Then GoTo ENDOFSTABILITY2
            P = (p1 + p2) / 2
            P = CVcalc(P, f)
            DoEvents
            UpdateLine25 usingWetSample
            If P > BBHigh Then BBHigh = P
            DoEvents
            If Timer - T > mineqtime Then GoTo ENDOFSTABILITY2
            'If pass = 1 And (P - P0) < ((plast - P0) * .8) Then GoTo ENDOFSTABILITY2
            If pass = 1 And (plast - P) > 0.5 Then GoTo ENDOFSTABILITY2
            test_record
            If HKey$ = "R" Or Aborted Then HKey$ = " ": GoTo ENDOFSTABILITY2
            If Abs(P1X4 - P2X4) <= PRESSLEW * ver1or3 Then GoTo ENDOFSTABILITY2
            p1 = p2
            P1X4 = P2X4
        Loop
ENDOFSTABILITY2:
        If debugRunCPass Then Print #mainDebugFile, "162"

    End If
    Rem line 15010 is only called from below to restart the loop
    Rem therefore the first time we reach 15010 for any given stability
    Rem point will always be from above.
    Rem this variable marks that the pressure hasn't fallen back this time yet
    flow_at_last_pressure_fall_back = 0
15010
    ReadXReturnX4 FUSE% ' changed jsd for stability on  lohm calcs
    
    
    X0 = x4
    f = x5
    ReadXReturnX4 2
    x1 = x4
    If x4 > X1FIRST And Not x1first_lockin Then X1FIRST = x4
    Rem changed jsd - causing problems with cv routine
    Rem must read flow first, then find pressure corrected for lohm
    P = x5
    'ReadXReturnX4 FUSE%
    'X0 = X4
    i% = 0
    eqstarttime = Timer
    'f = X5
    P = CVcalc(P, f)
    DoEvents
    UpdateLine25 usingWetSample
    If P > BBHigh Then BBHigh = P
    DoEvents
    If debugRunCPass Then Print #mainDebugFile, "163"

    test_record
    If (AVEITER = 0) And (HKey2$ <> "T") Then HKey$ = "R"
    If HKey$ = "R" Or Aborted Then
        HKey$ = " "
        eqdone% = 3
        GoTo ENDOFRETSTABLEPRES
    End If
    If Timer - T > mineqtime Then
        If debugRunCPass Then Print #mainDebugFile, "164"
    
        If stability_debug Then stabilitydebug.Label1.Caption = "Stability Method Used: Averaging (method 2)"
TOPOFSTABILITY3:
        Rem again get flow first and then corrected pressure
        ReadXReturnX4 FUSE%
        f = x5
        ReadXReturnX4 2
        P = x5
        If x4 > X1FIRST And Not x1first_lockin Then X1FIRST = x4
        If autocompress And compression_pressure <> 0 And Compression_Increase_Factor > 0 Then test_compression_pressure P - P0
        'ReadXReturnX4 FUSE%
        'f = X5
        P = CVcalc(P, f)
        DoEvents
        UpdateLine25 usingWetSample
        If P > BBHigh Then BBHigh = P
        PSUM = P
        'fsum = jeff_flow
        fsum = f
        PMin = P
        PMax = P
        'fmin = jeff_flow
        'fmax = jeff_flow
        fmin = f
        fmax = f
        i% = 1
        eqstarttime = Timer
15130
        ReadXReturnX4 2
        'P = X5
        'x1 = X4
        'If X4 < X1FIRST And Not x1first_lockin% Then X1FIRST = X4
        If debugRunCPass Then Print #mainDebugFile, "165"
        ReadXReturnX4 FUSE%
        f = x5
        ReadXReturnX4 2
        P = x5
        x1 = x4
        If x4 < X1FIRST And Not x1first_lockin Then X1FIRST = x4
        If x1 = DAC_over Or x4 = DAC_over Then x4 = DAC_over: GoTo ENDOFSTABILITY3
        If autocompress And compression_pressure <> 0 And Compression_Increase_Factor > 0 Then test_compression_pressure P - P0
        P = CVcalc(P, f)
        UpdateLine25 usingWetSample
        If P > BBHigh Then BBHigh = P
        PSUM = PSUM + P
        fsum = fsum + f
        If P < PMin Then PMin = P Else If P > PMax Then PMax = P
        If f < fmin Then fmin = f Else If f > fmax Then fmax = f
        DoEvents
        test_record
        If update_PSR(P, f) Then
            P = PSR.SumP / PSR.n
            f = PSR.SumF / PSR.n
            eqdone% = 2
            GoTo ENDOFSTABILITY3
        End If
        If HKey$ = "R" Or Aborted Then
            HKey$ = " "
            eqdone% = 3
            GoTo ENDOFSTABILITY3
        End If
        'If pass = 1 And P < plast And X1FIRST - X1 > 20 Then GoTo ENDOFSTABILITY3
        If pass = 1 And X1FIRST - x1 > DAC_span / 1000 Then GoTo PressureFellBack
        'If pass = 1 And (P - P0) < ((plast - P0) * .8) Then GoTo ENDOFSTABILITY3
        If pass = 1 And (plast - P) > 0.5 Then GoTo ENDOFSTABILITY3
        i% = i% + 1
        local_time = Timer
        If local_time + 0.1 < eqstarttime Then eqstarttime = eqstarttime - 86400
        'If i% < AVEITER Then GoTo 15130
        If (local_time - eqstarttime) < AVEITER / 10# Then GoTo 15130
        P = PSUM / i%
        f = fsum / i%
        If stability_debug Then
            stabilitydebug.Label4(0).Caption = "Average pressure=" + str$(P)
            stabilitydebug.Label4(1).Caption = "Average flow=" + str$(f)
            stabilitydebug.Label4(2).Caption = "Pdif=" + str$(PMax - PMin)
            stabilitydebug.Label4(3).Caption = "Fdiv=" + str$(fmax - fmin)
        End If
        If (PMax - PMin > MAXPDIF) Or (fmax - fmin > MAXFDIF) Then
            If stability_debug Then stabilitydebug.Label1.Caption = "Stability Method Used: Restarting averaging, num readings=" + str$(i%)
            GoTo TOPOFSTABILITY3
        End If
        eqdone% = 1
ENDOFSTABILITY3:
    If debugRunCPass Then Print #mainDebugFile, "166"

        GoTo ENDOFRETSTABLEPRES
    End If
    If stability_debug Then stabilitydebug.Label1.Caption = "Stability Method Used: Method 1"
15020
    If debugRunCPass Then Print #mainDebugFile, "167"

    ReadXReturnX4 2
    tempval = x4
    tempPres = x5
    If autocompress And compression_pressure <> 0 And Compression_Increase_Factor > 0 Then test_compression_pressure x5 - P0
    Rem I think we we shoud read flow again, to get accurate cv
    If x4 = DAC_over Then
        If debugRunCPass Then Print #mainDebugFile, "168"
        GoTo ENDOFRETSTABLEPRES
    Else
        If debugRunCPass Then Print #mainDebugFile, "169"
        ReadXReturnX4 FUSE%
        f = x5
        P = tempPres
        P = CVcalc(P, f)
        x4 = tempval
    End If
    'If pass = 1 And P < plast And X1FIRST - X1 > 20 Then GoTo ENDOFRETSTABLEPRES
    If pass = 1 And X1FIRST - x1 > DAC_span / 1000 Then GoTo PressureFellBack
    'If pass = 1 And (P - P0) < ((plast - P0) * .8) Then GoTo ENDOFRETSTABLEPRES
    If pass = 1 And (plast - P) > 0.5 Then GoTo ENDOFRETSTABLEPRES
    PX4 = x4
    ReadXReturnX4 FUSE%
    DoEvents
    ' remove test for DAC_over - let the high flow stabilize if it will go down on its own
'   If X4 = DAC_over Then
'       GoTo ENDOFRETSTABLEPRES
'   Else
    f = x5
'   End If
    If update_PSR(P, f) Then
        If debugRunCPass Then Print #mainDebugFile, "170"
    
        P = PSR.SumP / PSR.n
        f = PSR.SumF / PSR.n
        eqdone% = 2
        GoTo ENDOFRETSTABLEPRES
    End If
    If stability_debug Then
        If debugRunCPass Then Print #mainDebugFile, "171"
    
        stabilitydebug.Label4(0).Caption = "Flow slew=" + str$(Abs(x4 - X0))
        stabilitydebug.Label4(1).Caption = "Pressure slew=" + str$(Abs(PX4 - x1))
    End If
    If Abs(x4 - X0) > flowslew * ver1or3 Then GoTo 15010
    If Abs(PX4 - x1) > PRESSLEW * ver1or3 Then GoTo 15010
    i% = i% + 1
    local_time = Timer
    If local_time + 0.1 < eqstarttime Then eqstarttime = eqstarttime - 86400
    If stability_debug Then stabilitydebug.Label4(2).Caption = "Time=" + str$(local_time - eqstarttime)
    If (local_time - eqstarttime) < EQITER / 10# Then GoTo 15020
    'If i% < EQITER Then GoTo 15020
    eqdone% = 0
    GoTo ENDOFRETSTABLEPRES
PressureFellBack:
    If debugRunCPass Then Print #mainDebugFile, "172"

    Rem do something about it
    Rem maybe we can't do anything about it
    If ip_reg_enable And REGPOS >= 4000 Then GoTo 3351
    ReadXReturnX4 3
    Rem don't bother opening valve 2 if running integrity
    If x4 < oLimit And lflow% <> 1 Then
        If debugRunCPass Then Print #mainDebugFile, "173"
        If stability_debug Then stabilitydebug.Label1.Caption = "Opening valve 2 a bit due to pressure fall back"
        V2POS = x4 + 2 * ver1or20 ' need a bigger boost to valve 2 opening for faster machines
        OpenV2Pos  '7
        If f <= flow_at_last_pressure_fall_back Then
            ' don't increase regulator if we aren't at least 200 counts
            ' above the starting valve 2 position
            If V2POS > SV2P + DAC_span / 100 Then inc_reg Int(fifty_or_seven / 2.5) ' was 20
        End If
    Else
        If debugRunCPass Then Print #mainDebugFile, "174"
        inc_reg Int(fifty_or_seven / 2.5) ' was 20
    End If
    flow_at_last_pressure_fall_back = f
    x1first_lockin = True
    T = Timer
    GoTo 15010

ENDOFRETSTABLEPRES:
    If debugRunCPass Then Print #mainDebugFile, "175"

    If PROGRAMCTRL = 4600 Then Return
'    If x4 = DAC_over Then If V2INCR > 0 Then GoTo END_PASS Else GoTo 3300
    If x4 = DAC_over Then
        brokenCrap = brokenCrap + 1
        Waitms 1000, False
        
        If brokenCrap > 10 Then
            If debugRunCPass Then Print #mainDebugFile, "176"
            If V2INCR > 0 Then
                endPassCause = 20
                GoTo END_PASS
            Else
                GoTo 3300
            End If
        End If
    End If
    If Aborted Then
        endPassCause = 21
        GoTo END_PASS
    End If

    '  if we get here 100 times without any improvement, call it quits
    NOWHERE% = NOWHERE% + 1
    Rem new NOWHERE% special case of still really improving
    Rem might have to change these for jsd
    If NOWHERE% = 2 Then
        If debugRunCPass Then Print #mainDebugFile, "177"
        Rem on 9, record current flow and pressure
        flow_at_2 = f
        pres_at_2 = P
    ElseIf NOWHERE% > 2 And V2INCR > 0 Then
        If debugRunCPass Then Print #mainDebugFile, "178"
        If f > flow_at_2 Then
            flow_at_2 = f
            NOWHERE% = 2
        End If
        If P > pres_at_2 Then
            pres_at_2 = P
            NOWHERE% = 2
        End If
    End If
    DoEvents
    If NOWHERE% > 299 Or HKey2$ = "T" Then
        If debugRunCPass Then Print #mainDebugFile, "179"
        endPassCause = 22
        GoTo END_PASS 'MsgBox "Stopping because of turn or nowhere=300"
    End If
    If NOWHERE% > 15 And REGPOS * ver1or20 > 150 And points > 2 And PULSEWIDTH = 0 Then
        If debugRunCPass Then Print #mainDebugFile, "180"
        endPassCause = 23
        GoTo END_PASS 'MsgBox "Stopping because nowhere=6"
    End If
    If V2INCR > 0 And V2POS < oLimit And PULSEWIDTH > 0 And Not v2solenoid Then
        If debugRunCPass Then Print #mainDebugFile, "181"
        If f <= FLAST And P <= plast Then
            V2FACTR = V2FACTR * 1.4
            NOWHERE% = 0
            GoTo 3351
        End If
    End If
    If V2INCR > 0 Then
        If debugRunCPass Then Print #mainDebugFile, "182"
        If f <= FLAST And P <= plast Then
            GoTo ENDOFINFINITESLOPE
        End If
        
        If P <= plast Then
            If debugRunCPass Then Print #mainDebugFile, "183"
            If justSwitchedRegulators Then GoTo ENDOFINFINITESLOPE
            '  experimental infinite slope system
            If BADINDEX% > 100 Or points < 1 Then
                GoTo ENDOFINFINITESLOPE
            ElseIf BADINDEX% > 1 Then
                If BadFlow(BADINDEX% - 1) >= f Then GoTo ENDOFINFINITESLOPE
            End If
            BadFlow(BADINDEX%) = f
            BADINDEX% = BADINDEX% + 1
ENDOFINFINITESLOPE:
            If V2POS > SV2P + DAC_span / 100 Then inc_reg Int(fifty_or_seven / 2.5) ' was 20
            GoTo 3351
        Else
            If debugRunCPass Then Print #mainDebugFile, "184"
        
            If switchingToCapFlowSide Then
                If debugRunCPass Then Print #mainDebugFile, "185"
                Status.Visible = True
                Status.Label1.Caption = "PLEASE WAIT"
                Status.Label2.Caption = "Waiting for flow to normalize"
                Status.Label3.Caption = ""
                'waitseconds mineqtime
                WaitSecondsNoHang mineqtime
                Unload Status
            End If
            
            If BADINDEX% > 1 And BADINDEX% < 100 And _
                Not justSwitchedRegulators And Not switchingToCapFlowSide Then
                If debugRunCPass Then Print #mainDebugFile, "186"
                If (f - FLAST) * 0.9 < (BadFlow(BADINDEX% - 1) - FLAST) Then
                    If debugRunCPass Then Print #mainDebugFile, "187"
                    For REGOUT = 1 To BADINDEX% - 1
                        points = points + 1
                        dat_size_check x_array, points
                        x_array.a(points).fl = BadFlow(REGOUT)
                        If x_array.a(points).fl <= 0 Then x_array.a(points).fl = 0
                        ' 6.71.20
                        x_array.a(points).fl2 = x_array.a(points).fl ' just in case
                        x_array.a(points).pr = (P - plast) / BADINDEX% * REGOUT + plast
                        x_array.a(points).eqd = 3
                        x_array.a(points).time = Timer
                        'If using_watlow Then read_temperature (points)
                     
                        'AJB 10-20-09 6.71.130
                        If dryChamberTemperature <> 0 Then x_array.a(points).temp1 = readNewTemperature(dryChamberTemperature)
                        If airTemperature <> 0 Then x_array.a(points).temp2 = readNewTemperature(airTemperature)
                        'AJB 10-20-09 6.71.130
                        
                        If hasHumidityControls And enableHumidityControlForAutoTests Then
                            
                            goToTargetHumidity
                            
                            'ReadXReturnX4 1 're-read current flow
                            'x_array.a(points).fl = x5
                            
                            'ReadXReturnX4 2 're-read current pressure
                            'x_array.a(points).pr = x5
                            
                            x_array.a(points).humidity = lastGoodHumidity
                            
                            Print #55, x_array.a(points).fl & Chr(9) & x_array.a(points).pr & Chr(9) & x_array.a(points).humidity & Chr(9) & Format$(getBubblerMVPosition(), "##0.00%") & Chr(9) & goToHumidityCounter & Chr(9); goToHumidityWaitTimeCounter & Chr(9) & REGPOS & Chr(9) & Format$(getMV2Position(), "##0.00%") & Chr(9) & lfcpos
                            
                        ElseIf hasHumidityControls And recordHumidityForAutoTests Then
                            'just read humidity sensor and record the point, don't try to correct the humidity by calling goToTargetHumidity
                            x_array.a(points).humidity = readHumiditySensor
                        End If
                        
                        'AJB 10-18-09 start
                        'If dryChamberTemperature <> 0 Then read_temperature points, False
                        If dryChamberTemperature <> 0 And airTemperature <> 0 Then
                            read_two_temperatures points
                        ElseIf dryChamberTemperature <> 0 Then
                            read_temperature points, False
                        End If
                        'AJB 10-19-09 end
                        'Scr_Refresh fn
                    Next REGOUT
                    If points > 32000 Then HKey2$ = "T"
                End If
            End If
            
            If switchingToCapFlowSide Then
                switchingToCapFlowSide = False
            End If
            If debugRunCPass Then Print #mainDebugFile, "188"
            
            BADINDEX% = 1
        End If
    End If
    If debugRunCPass Then Print #mainDebugFile, "189"
    
    If V2INCR < 0 Then If f >= FLAST Or P >= plast Then GoTo 3300
    DoEvents
    justSwitchedRegulators = False
    points = points + 1
    dat_size_check x_array, points
    x_array.a(points).fl = f
    If x_array.a(points).fl <= 0 Then x_array.a(points).fl = 0
    If points > 32000 Then HKey2$ = "T"
    ' 6.71.20 begin
    If using_hflow1 And Not switch_high_flow_enabled Then
        If debugRunCPass Then Print #mainDebugFile, "190"
        x_array.a(points).fl2 = x_array.a(points).fl ' store hflow1 data in secondary flow storage area
        hflow1_max_index = points
        ' read low range of hflow2
        suspend_v10 = True
        temp_hflow% = HFLOW%
        HFLOW% = 3
        ReadXReturnX4 1
        suspend_v10 = False
        HFLOW% = temp_hflow%
        If x5 < 0 Then x5 = 0
        f = x5
        x_array.a(points).fl = x5
    End If
    ' 6.71.20 end
    If debugRunCPass Then Print #mainDebugFile, "191"
    x_array.a(points).pr = P
    x_array.a(points).eqd = eqdone%
    x_array.a(points).time = Timer
    'If using_watlow Then read_temperature (points)
    'AJB 10-19-09 start
    'If dryChamberTemperature <> 0 Then read_temperature points, False
    If dryChamberTemperature <> 0 And airTemperature <> 0 Then
        read_two_temperatures points
    ElseIf dryChamberTemperature <> 0 Then
        read_temperature points, False
    End If
    'AJB 10-19-09 end
    
    'AJB 10-20-09 6.71.130
    If dryChamberTemperature <> 0 Then x_array.a(points).temp1 = readNewTemperature(dryChamberTemperature)
    If airTemperature <> 0 Then x_array.a(points).temp2 = readNewTemperature(airTemperature)
    'AJB 10-20-09 6.71.130
    If debugRunCPass Then Print #mainDebugFile, "192"
    
    If hasHumidityControls And enableHumidityControlForAutoTests Then
        If debugRunCPass Then Print #mainDebugFile, "193"
        
        goToTargetHumidity
        
        'ReadXReturnX4 1 're-read current flow
        'x_array.a(points).fl = x5
        
        'ReadXReturnX4 2 're-read current pressure
        'x_array.a(points).pr = x5
        
        x_array.a(points).humidity = lastGoodHumidity
        
        Print #55, x_array.a(points).fl & Chr(9) & x_array.a(points).pr & Chr(9) & x_array.a(points).humidity & Chr(9) & Format$(getBubblerMVPosition(), "##0.00%") & Chr(9) & goToHumidityCounter & Chr(9); goToHumidityWaitTimeCounter & Chr(9) & REGPOS & Chr(9) & Format$(getMV2Position(), "##0.00%") & Chr(9) & lfcpos
        
    ElseIf hasHumidityControls And recordHumidityForAutoTests Then
        'just read humidity sensor and record the point, don't try to correct the humidity by calling goToTargetHumidity
        If debugRunCPass Then Print #mainDebugFile, "194"
        x_array.a(points).humidity = readHumiditySensor
    End If
        
    If use_fluid_sensor Then
        If debugRunCPass Then Print #mainDebugFile, "195"
        ReadXReturnX4 27
        x_array.a(points).fluid = x5 - fluid_sensor_0
    End If
    took_point_time = Timer
    If debugRunCPass Then Print #mainDebugFile, "196"
    Scr_Refresh x_array
    If V2INCR < 0 Then
        GoTo 3350
    ElseIf PWFACTR < 1.5 Then
        If maxdflow < f - FLAST Then maxdflow = f - FLAST
    End If
    If (f - FLAST) < maxdflow Then GoSub 3450
3350
    If debugRunCPass Then Print #mainDebugFile, "197"
    If p5 <> 0 Then
        If FLAST > f And plast > P Then
            preg_fact = (p5 / (P - plast) + f5 / (f - FLAST)) / 2
            If preg_fact <= 1.01 Then preg_fact = 1.01
            If preg_fact > 10 Then preg_fact = 10
        End If
    End If
    FLAST = f
    plast = P
    If dryChamberTemperature <> 0 Then
        If debugRunCPass Then Print #mainDebugFile, "198"
        'AJB 10-19-09 start
        If airTemperature <> 0 Then
            Print #fn3, P; vbTab; f; vbTab; readNewTemperature(dryChamberTemperature); vbTab; readNewTemperature(airTemperature);
        Else
            Print #fn3, P; vbTab; f; vbTab; readNewTemperature(dryChamberTemperature);
        End If
        'AJB 10-19-09 end
        
        'Print #fn3, P; vbTab; f; vbTab; readNewTemperature(dryChamberTemperature)
        'If using_watlow Then
        '    Print #fn3, P; vbTab; f; vbTab; watlow_last_temperature
        'ElseIf temperature% > 0 Then
        '    If temperature% > 1 Then
        '        ReadXReturnX4 30
        '    Else
        '        ReadXReturnX4 27
        '    End If
        '    Print #fn3, P; vbTab; f; vbTab; x5
    End If
3351
    If debugRunCPass Then Print #mainDebugFile, "199"
    ' 6.71.20 begin
    ' check to see if regulator has gone over and we need to switch
    If ip_reg_enable And REGPOS >= 4000 And V2INCR > 0 Then
        If debugRunCPass Then Print #mainDebugFile, "200"
        ' if we are already at 4000 counts, see if we can switch regulators
        If dualregulator And using_low_regulator Then
            If debugRunCPass Then Print #mainDebugFile, "201"
            '' decrease regulator to the second_regulator_starting_point
            'lower_reg 4000 - second_regulator_starting_point
            ' now decrease regulator to reg2_high_flow_switch_count
            'lower_reg 4000 - reg2_high_flow_switch_count
            'waitseconds 3
            'Move_Valve 16, "O"
            'waitseconds 10
            'regnum = 1
            'fifty_or_seven = 7
            'SBPP = SBPP2
            'SHFP = SHFP2
            'using_low_regulator = False
            If debugRunCPass Then Print #mainDebugFile, "Switch Regulators 4"
            SwitchRegulators "4"
            skipincrease = True ' skip next pressure increase
            justSwitchedRegulators = True
        Else
            If debugRunCPass Then Print #mainDebugFile, "202"
            ' we might as well end the test since we can't go up any more
            HKey$ = " "
            HKey2$ = "T"
            endPassCause = 24
            GoTo END_PASS
        End If
    End If
    ' 6.71.20 end
    If debugRunCPass Then Print #mainDebugFile, "203"
    If V2INCR < 0 And stop_at_bp And P < BUBBLEPT Then HKey2$ = "T"
    If HKey2$ = "T" Then
        endPassCause = 25
        GoTo END_PASS
    End If
    If V2INCR < 0 Then GoTo 3400
    Rem if they are going backwards, allow pressure and flow to be over max since they
    Rem should be coming down on subsequent points
    If P - P0 > Maxpres Or f > MAXFLOW Then
        If debugRunCPass Then Print #mainDebugFile, "204"
        If Not switchingToCapFlowSide Then
            endPassCause = 26
            GoTo END_PASS
        End If
    End If
    If Pres% = 1 Then TPoint = P
    If HFLOW% = 1 Or HFLOW% = 3 Then FTPOINT = f
    NOWHERE% = 0
    If points > 2 And special_pulse Then special_pulse = False
    If points >= 4 And p5 = 0 And (PULSEWIDTH = 0 Or V2POS >= oLimit) Then
        p5 = (P - P0) / points
        f5 = f / points
    End If
    DoEvents
    GoTo 3300
3400
    If debugRunCPass Then Print #mainDebugFile, "205"
    If Pres% = 0 Then
        If P < TPoint Then
            If debugRunCPass Then Print #mainDebugFile, "206"
            Pres% = 1
            'k = Timer
            'While (Timer - k < 0.3) And (Timer >= k)
            'DoEvents
            'Wend
            ' this .3 second wait was on version 5.1 and 5.2 machines to wait for the
            ' relay that changed ranges to have time to move.  It is not needed in
            ' currently supported hardware versions
        End If
    End If
    If HFLOW% = 2 Or HFLOW% = 0 Then
        If f < FTPOINT Then
            If debugRunCPass Then Print #mainDebugFile, "207"
            HFLOW% = HFLOW% + 1
            'k = Timer
            'While (Timer - k < 0.3) And (Timer >= k)
            'DoEvents
            'Wend
        End If
    End If
    If P <= P0 Or f <= FY1(0, 0) Then
        endPassCause = 27
        GoTo END_PASS
    End If
    NOWHERE% = 0
    DoEvents
    GoTo 3300
3450
    If debugRunCPass Then Print #mainDebugFile, "208"

    ' given f,flast, maxdflow; calculate how much to increase v2factr and pwfactr
    If f <= FLAST Then
        CHFACTR = 1.5
    Else
        CHFACTR = maxdflow / (f - FLAST)
        If CHFACTR > 1.5 Then CHFACTR = 1.5
    End If
    If V2POS >= oLimit Or PULSEWIDTH = 0 Then Return
    V2FACTR = V2FACTR * CHFACTR
    PWFACTR = PWFACTR + 0.1
    If V2FACTR > 10 And V2POS > SV2P + DAC_span / 100 Then inc_reg 10
    Return
3500
    If debugRunCPass Then Print #mainDebugFile, "209"

    ' set to initial estimated bubble point pressure
    If EBPP + P0 < PY2(2) And ExtraPG Then
       Move_Valve 10, "O"
       Pres% = 2
    Else
       Move_Valve 10, "C"
       Pres% = 1
    End If
    ' increase compression pressure if necessary before we increase pressure quickly
    If autocompress And compression_pressure <> 0 And Compression_Increase_Factor > 0 Then
        move_compression_regulator_to_pressure (compression_pressure + EBPP * Compression_Increase_Factor)
    End If
    ' only open valve 1 if we are doing low flow meter bubble point
    If Not hfbp Then
        Move_Valve 0, "O"
        If low_flow_controller Then
            'set_low_flow_rate BUBLFLOW
            zero_lfctrl
        End If
    End If
    'vpos(1) = 1
    '  open valve 2 all the way
    OPENV2MOSTLY
    
    If P > BBHigh Then BBHigh = P
    
    If debugRunCPass Then Print #mainDebugFile, "210"
    ' clear regulator and then set it to ebpp
    ' assume regulator is already cleared
    If reg_table_size%(regnum) = 0 Or (Not (newreg Or ip_reg_enable)) Then GoTo 3590 ' can't use the following if not vers.6 or 7 or no calib table
    ' added 95% of EBPP to reduce overshooting on EBPP (JSD)
    ' move_motorized_regulator_to_pressure now works with i/p regulator as well
    If regnum = 0 Then
        If debugRunCPass Then Print #mainDebugFile, "211"
        If reg_table_pres!(reg_table_size%(0)) < EBPP Then  ' for case of EBPP higher than cal pres
            move_motorized_regulator_to_pressure (BBPP)    ' this is just the max calibrated pressure
        Else
            move_motorized_regulator_to_pressure (0.975 * EBPP)
        End If
    Else
        If debugRunCPass Then Print #mainDebugFile, "212"
        If reg_table_pres2!(reg_table_size%(1)) < EBPP Then  ' for case of EBPP higher than cal pres
            move_motorized_regulator_to_pressure (BBPP)    ' this is just the max calibrated pressure
        Else
            move_motorized_regulator_to_pressure (0.975 * EBPP)
        End If
    End If
3590
    If debugRunCPass Then Print #mainDebugFile, "213"
    ReadXReturnX4 2
    waitseconds 3
    'T = Timer
    'While (Timer - T) < 3: DoEvents: Wend
    P = x5
    If autocompress And compression_pressure <> 0 And Compression_Increase_Factor > 0 Then test_compression_pressure P - P0
    UpdateLine25 usingWetSample
    If P > BBHigh Then BBHigh = P
    Rem The following added by JSD to speed up estimated bubble point tests
    Rem where the est. pressure is relatively high.  Use old code for lower
    Rem est bubble points to aviod overshoot
    Rem The select case code is easier to follow (I think)
    ' The select case code was not written properly - rewritten to if/else
    If P < 0.975 * (EBPP + P0) Then
    'AW
    
    
    
        If ip_reg_enable And REGPOS >= 4000 And dualregulator And using_low_regulator Then
            SwitchRegulators "derp"
        End If
        If debugRunCPass Then Print #mainDebugFile, "214"
        'Select Case X5 < EBPP + P0
        '   Case Not Aborted And X5 < 0.25 * (EBPP + P0)
        '       For i% = 1 To 4
        '           inc_reg 10
        '        Next i%
        '        GoTo 3590
        '   Case Not Aborted And X5 < 0.75 * (EBPP + P0)
        '        For i% = 1 To 2
        '            inc_reg 10
        '         Next i%
        '         GoTo 3590
        '   Case Not Aborted And X5 < 0.98 * (EBPP + P0)
        '        inc_reg 10
        '        GoTo 3590
        'End Select
        If Not Aborted And x5 < 0.25 * (EBPP + P0) Then
            For i% = 1 To 4
                inc_reg 10
            Next i%
            GoTo 3590
        ElseIf Not Aborted And x5 < 0.75 * (EBPP + P0) Then
            For i% = 1 To 2
                inc_reg 10
            Next i%
            GoTo 3590
        ElseIf Not Aborted And x5 < 0.98 * (EBPP + P0) Then
            inc_reg 10
            GoTo 3590
        End If
    End If
    
    'If (EBPP + p0) < PY2(1) And Not aborted Then  'make sure ebpp is high enough to use new speedy routine
    'If Not aborted And X5 < .25 * (EBPP + p0) Then
    'inc_reg 1
    'inc_reg 1
    'inc_reg 1
    'inc_reg 1
    'GoTo 3590
    
    'ElseIf Not aborted And X5 < .75 * (EBPP + p0) Then    'very far from ebpp
    'inc_reg 1
    'inc_reg 1
    'inc_reg 1
    'GoTo 3590

    'ElseIf Not aborted And X5 < .95 * (EBPP + p0) Then   'almost there, don't overshoot
    'inc_reg 1
    'GoTo 3590
    'End If
    
    ' now close valve 2 and return
    
    'JF 9-30-2010 Should I comment this out??
    Send_RS232 ("C" + mv1_index_char)

3620
    If debugRunCPass Then Print #mainDebugFile, "215"
    ReadXReturnX4 3
    If P > BBHigh Then BBHigh = P
    If (cLimit + DAC_span / 2000) < x4 Then GoTo 3620

    ' customer requested delay here, not sure how much or why
    ' put in 5 second delay
    waitseconds 5
    'T = Timer
    'Do
    '    If T > Timer + 0.01 Then T = T - 86400
    '    DoEvents
    'Loop While (Timer - T) < 5

    If (Not low_flow_controller) Or hfbp Then
        If debugRunCPass Then Print #mainDebugFile, "216"
        ' now wait for flow meter to stabilize
        waitseconds 10
        'T = Timer
        'While (Timer - T) < 10: DoEvents: Wend
3660
        ReadXReturnX4 FUSE%
        f = x5
        ReadXReturnX4 2
        P = x5
        UpdateLine25 usingWetSample
        If P > BBHigh Then BBHigh = P
        If Not Aborted And f > 1.5 * BUBLFLOW Then
            ' don't lower the regulator if we are using the high flow bubble point
            If Not hfbp Then lower_reg 1
            GoTo 3660
        End If
    End If

    If debugRunCPass Then Print #mainDebugFile, "217"
    Return

END_PASS:

'If geoPoreValve Then
   ' close_v2_completely
    'Move_Valve GeoExtraValve, "C"
    'Call Zero_Reg
'End If


    If debugRunCPass Then Print #mainDebugFile, "218"

'dw.addDebugStatement "Position 113"
'dw.addDebugStatement ts$(315) + " " + Xformat$(REGPOS, "####0") + " " + ts$(231)  ' "Regulator"/"counts"
    If debugRunCPass Then
        Close #mainDebugFile
    End If
        
    If hasHumidityControls And enableHumidityControlForAutoTests Then
        Close #55
    End If
    
    ' Turn the Athenas off - Mix
    If Athena1InTest Then Set_Athena Athena1Channel, 0
    If Athena2InTest Then Set_Athena Athena2Channel, 0
    
    If bubbler_enable Then
        Move_Valve 24, "C"
        waitseconds 5
    End If
    ' 6.71.60: added zeroTempAtEndOfTest as condition for sending command
    
    'If zeroTempAtEndOfTest And dryChamberTemperature <> 0 And recirculation = False Then setNewTemperature dryChamberTemperature, 0
    'If zeroTempAtEndOfTest And airTemperature <> 0 And recirculation = False Then setNewTemperature airTemperature, 0
    If dryChamberTemperature <> 0 Then Close #fn3
    ' open valve 20 if it is there and it is closed
    If AirTop And v20_exists And Vpos(20) = 0 And (dont_reopen_valve_20 = False) Then
        Move_Valve 19, "O"
    End If
    HKey$ = " "
    HKey2$ = " "
    
        ' 6.71.20 begin
    If using_hflow1 = True And hflow1_max_index = points Then
        If debugRunCPass Then Print #mainDebugFile, "219"
        ' use the fl2 data exclusively
        'MsgBox "Using fl2 data for this test"
        For i = 1 To points
            x_array.a(i).fl = x_array.a(i).fl2
        Next i
    Else
        ' use the fl data and ignore the fl2 data
        ' this may incorporate the fl2 data up to the hflow1-max_index
        ' but that is for later
        'MsgBox "Using fl data for this test"
    End If
    ' 6.71.20 end
    
    If showEndPassCause Then
        MsgBox "End Pass Cause: " + str$(endPassCause)
    End If
    
'dw.addDebugStatement "Function Ended: Run_C_Pass"
    If mfDebugFile <> -1 Then
        'MsgBox "End Pass Cause: " + str(endPassCause)
    
        Print #mfDebugFile, "End Pass Cause: " + str$(endPassCause)
        Close #mfDebugFile
        mfDebugFile = -1 ' just in case
    End If
End Sub

Sub checkSampleChamberDiverterValve()
    If sampleChamberDiverterValve >= 0 Then
        If divertSampleChamber Then
            Move_Valve sampleChamberDiverterValve, "O"
        Else
            Move_Valve sampleChamberDiverterValve, "C"
        End If
    End If
End Sub

Sub readPandF()
    ReadXReturnX4 2
    P = x5
    ReadXReturnX4 FUSE%
    f = x5
    P = CVcalc(P, f)
End Sub

Sub Run_GP_SinglePoint(X As dat_array)
    Dim delayTime As Integer
    Dim p_sum As Single
    Dim f_sum As Single
    Dim p_avg As Single
    Dim f_avg As Single
    Dim rCount As Long
    Dim startTime As Long
    Dim phaseLength As Long
    Dim elapsedTime As Long
    Dim regulator_increment_value As Integer
    Dim regulator_initial_value As Integer
    Dim pressure_increase As Single
    Dim target_pressure As Single
    Dim i As Integer
    Dim currentTemp As Single
    
    phaseLength = GP_duration / 2
    
    'Determine the proper position for the motor valve
    UpdateLine26 "Setting MV2 Position: "
    inc_reg 4000
    V2POS = cLimit + V2INCR
    OpenV2Pos
    readPandF
    While P < ((GP_target * 1.5) + P0)
        V2POS = V2POS + V2INCR
        OpenV2Pos
        readPandF
        UpdateLine26 "MV2 Position: " + Xformat$((((V2POS - cLimit) / (oLimit - cLimit)) * 100), "###.0") + "%     " + _
                     "Pressure: " + Xformat$((P - P0) * PCNV, "###0.000  ") + PU$
    Wend
    Zero_Reg
    
    If newreg Then
        move_motorized_regulator_to_pressure (GP_target)
    End If
    
    delayTime = 5
    Zero_Reg
    For i = 1 To delayTime
        waitseconds 1
        readPandF
        UpdateLine25 False
    Next i
    
    regulator_increment_value = Int(preginc * fifty_or_seven)
    pressure_increase = GP_target
    target_pressure = pressure_increase + P0
    
    regulator_initial_value = new_regpos_from_p(pressure_increase)
    If regulator_initial_value > 0 Then
        inc_reg regulator_initial_value
        For i = 1 To delayTime
            waitseconds 1
            readPandF
            UpdateLine25 False
        Next i
    Else
        UpdateLine26 "Rapidly increasing pressure towards target..."
        While (P - P0) < (pressure_increase * 0.9)
            If ip_reg_enable And REGPOS >= 4000 Then
                SwitchRegulators
            End If
            inc_reg regulator_increment_value
            For i = 1 To delayTime
                waitseconds 1
                readPandF
                UpdateLine25 False
                UpdateLine26 "Rapidly Increasing Pressure - Reg Pos: " + Xformat$(REGPOS, "####")
            Next i
        Wend
    End If
    
' How do I handle the motor valve correctly?
    
    'First we check if we are below the target and increase quickly until we are over it.
    'This will close the gap if for some reason we are way below the target.
    delayTime = 3
    UpdateLine26 "Coarsely increasing pressure..."
    While (P - P0) < pressure_increase
        If ip_reg_enable And REGPOS >= 4000 Then
            SwitchRegulators
        End If
        inc_reg 10
        For i = 1 To delayTime
            waitseconds 1
            readPandF
            UpdateLine25 False
            UpdateLine26 "Coarsely Increasing Pressure - Reg Pos: " + Xformat$(REGPOS, "####")
        Next i
    Wend
    
    'Next we decrease quickly until we are under the pressure.
    'This will close the gap if for some reason we are way over the target.
    UpdateLine26 "Coarsely decreasing pressure..."
    While (P - P0) > pressure_increase
        If ip_reg_enable And REGPOS >= 4000 Then
        
            SwitchRegulators

        End If
        lower_reg 10
        For i = 1 To delayTime
            waitseconds 1
            readPandF
            UpdateLine25 False
            UpdateLine26 "Coarsely Decreasing Pressure - Reg Pos: " + Xformat$(REGPOS, "####")
        Next i
    Wend
    
    'Now we increase at a medium rate until we are over the pressure.
    delayTime = 5
    UpdateLine26 "Finely increasing pressure..."
    While (P - P0) < pressure_increase
        If ip_reg_enable And REGPOS >= 4000 Then
        
            SwitchRegulators
        End If
        inc_reg 5
        For i = 1 To delayTime
            waitseconds 1
            readPandF
            UpdateLine25 False
            UpdateLine26 "Finely Increasing Pressure - Reg Pos: " + Xformat$(REGPOS, "####")
        Next i
    Wend
    
    'Finally we decrease at a slow rate until we are just under the pressure target.
    delayTime = 5
    UpdateLine26 "Finely decreasing pressure..."
    While (P - P0) > pressure_increase
        If ip_reg_enable And REGPOS >= 4000 Then
            SwitchRegulators
        End If
        lower_reg 5
        For i = 1 To delayTime
            waitseconds 1
            readPandF
            UpdateLine25 False
            UpdateLine26 "Finely Decreasing Pressure - Reg Pos: " + Xformat$(REGPOS, "####")
        Next i
    Wend
    
    'Now we take readings and average them to get the correct flow for just under the pressure.
    p_sum = 0
    f_sum = 0
    rCount = 0
    UpdateLine26 "Taking readings below target..."
    startTime = Timer
    While (Timer - startTime) < phaseLength
        readPandF
        UpdateLine25 False
        p_sum = p_sum + P
        f_sum = f_sum + f
        rCount = rCount + 1
    Wend
    p_avg = p_sum / rCount
    f_avg = f_sum / rCount
    X.a(2).pr = CVcalc(p_avg, f_avg)
    X.a(2).fl = f_avg
    
    'Then we increase the regulator at a slow rate until we are just over the pressure target.
    UpdateLine26 "Finely increasing pressure..."
    While (P - P0) < pressure_increase
        If ip_reg_enable And REGPOS >= 4000 Then
            SwitchRegulators
        End If
        inc_reg 5
        For i = 1 To delayTime
            waitseconds 1
            readPandF
            UpdateLine25 False
            UpdateLine26 "Finely Increasing Pressure - Reg Pos: " + Xformat$(REGPOS, "####")
        Next i
    Wend
    
    'Now we take readings and average them to get the correct flow for just over the pressure.
    p_sum = 0
    f_sum = 0
    rCount = 0
    UpdateLine26 "Taking readings above target..."
    startTime = Timer
    While (Timer - startTime) < phaseLength
        readPandF
        UpdateLine25 False
        p_sum = p_sum + P
        f_sum = f_sum + f
        rCount = rCount + 1
    Wend
    p_avg = p_sum / rCount
    f_avg = f_sum / rCount
    X.a(3).pr = CVcalc(p_avg, f_avg)
    X.a(3).fl = f_avg
    
    points = 3
    
    UpdateLine26 "Ending test"
    Zero_Reg
End Sub

Sub SwitchRegulators(Optional extraInfo As String)
    UpdateLine26 "Switching Regulators..." & extraInfo
    Zero_Reg

    waitseconds 3
    
    If (air_inlets = 2) Then
        Move_Valve 15, "O"
        current_air_inlet = 2
    End If

    Move_Valve 16, "O"
    waitseconds 5
    regnum = 1

    fifty_or_seven = 7
    
    inc_reg second_regulator_starting_point
    'lower_reg 4000 - second_regulator_starting_point
    waitseconds 3
    
    SBPP = SBPP2
    SHFP = SHFP2
    using_low_regulator = False
    UpdateLine26 ""
    'Waitms 5000, False
End Sub

Sub Run_Resin_Test()
    Dim P0 As Double
    Dim h As Double
    Dim volume As Double
    Dim v0 As Double
    Dim P As Double
    Dim target_pressure As Single
    Dim points As Integer
    Dim T As Single
    Dim t0 As Single
    Dim filenum As Integer
    
    Aborted = False
    progress.List1.clear
    progress.List1.AddItem ("Test Initializing")
    Move_Valve Resin_Diverter_Valve - 1, "C"
    Move_Valve 10, "C"
    MsgBox "Open and empty all sample chambers"
    Zero_Reg
    Move_Valve 2, "O" ' open valve 3 (vent)
    Pres% = 0 ' force high range of high pressure gauge
    ReadXReturnX4 2
    P0 = x5
    Move_Valve 3, "O" ' this really closes valve 4, which is always backwards for historical reasons
    Move_Valve 2, "C"
    Move_Valve 11, "O"
    Move_Valve 12, "O"
    Do
        ReadXReturnX4 4
        h = x5
        progress.Line25.Caption = "Filling 1: Height = " + Xformat$(h, "##0.00") + " cm"
        If Aborted Then Exit Do
    Loop Until h >= Resin_Fill_Height
    Move_Valve 12, "C"
    If Aborted Then GoTo resin_done
    waitseconds (3)
    Move_Valve Resin_Diverter_Valve - 1, "O"
    waitseconds (3)
    Move_Valve 12, "O"
    Do
        ReadXReturnX4 4
        h = x5
        progress.Line25.Caption = "Filling 2: Height = " + Xformat$(h, "##0.00") + " cm"
        If Aborted Then Exit Do
    Loop Until h >= Resin_Fill_Height
    Move_Valve 12, "C"
    If Aborted Then GoTo resin_done
    waitseconds (3)
    Move_Valve Resin_Diverter_Valve - 1, "C"
    waitseconds (3)
    If Aborted Then GoTo resin_done
    MsgBox "Load sample and seal chamber"
    MsgBox "Apply vacuum"
    MsgBox "Wait for vacuum to be good"
    MsgBox "Remove vacuum"
    Move_Valve Resin_Diverter_Valve - 1, "O"
    waitseconds (3)
    Move_Valve 12, "O"
    Do
        ReadXReturnX4 4
        h = x5
        progress.Line25.Caption = "Filling 3: Height = " + Xformat$(h, "##0.00") + " cm"
        If Aborted Then Exit Do
    Loop Until h >= Resin_Start_Height
    Move_Valve 12, "C"
    If Aborted Then GoTo resin_done
    waitseconds (3)
    Move_Valve 22, "O"
    Do
        ReadXReturnX4 4
        h = x5
        progress.Line25.Caption = "Settling: Height = " + Xformat$(h, "##0.00") + " cm"
        If Aborted Then Exit Do
    Loop Until h <= Resin_Start_Height
    Move_Valve 22, "C"
    If Aborted Then GoTo resin_done
    Rem main part of test goes here
    OPENV2MOSTLY
    If Aborted Then GoTo resin_done
    Move_Valve 8, "O"
    target_pressure = Resin_Start_Pressure
    points = 0
    filenum = FreeFile
    Open EXE_Path$ + "lastdata.cft" For Output As filenum
    Print #filenum, "EXTENDED"
    Print #filenum, 2
    Print #filenum, "Operator="; operator$(current_unit%)
    Print #filenum, "Lot Number="; lot_number$(current_unit%)
    Print #filenum, "RESIN"
    Print #filenum, date$
    Print #filenum, Line1$(current_unit%)
    Print #filenum, Line2$(current_unit%)
    Print #filenum, Liquid$(current_unit%)
    Print #filenum, sid$(current_unit%)
    If cyl_len(current_unit%) = 0 Then
        Print #filenum, str$(Diam(current_unit%))
    Else
        Print #filenum, 0
        Print #filenum, str$(Diam(current_unit%)); ","; str$(cyl_len(current_unit%))
    End If
    Print #filenum, str$(thick(current_unit%))
    Print #filenum, str$(P0)
    Do While points < Resin_Number_Points
        move_motorized_regulator_to_pressure (target_pressure)
        ' wait Resin_Stable_Seconds while showing p and h on the status line
        t0 = Timer
        Do
            ReadXReturnX4 2
            P = x5 - P0
            ReadXReturnX4 4
            h = x5
            progress.Line25.Caption = "p=" + Xformat$(P * PCNV, "###0.000 ") + PU$ + ",  h=" + Xformat$(h, "##0.00") + " cm"
            T = Timer
            If T + 0.1 < t0 Then t0 = t0 - 86400!
            If Aborted Then Exit Do
        Loop Until (T - t0) >= Resin_Stable_Seconds
        If Aborted Then Exit Do
        volume = -h * CSECAREA
        If points = 0 Then
            v0 = volume
        End If
        progress.List1.AddItem ("p=" + Xformat$(P * PCNV, "###0.000 ") + PU$ + ",  h=" + Xformat$(h, "##0.00") + " cm,  vol=" + Xformat$(volume - v0, "###0.00") + " cc")
        Print #filenum, str$(P + P0); ","; str$(volume)
        points = points + 1
        pass = 1 ' signal that we have at least one good data point to avoid "invalid" error message
        target_pressure = target_pressure + Resin_Increment_Pressure
    Loop
    Print #filenum, "-1,-1"
    Close #filenum
    progress.List1.AddItem ("Test finished")
resin_done:
    Move_Valve 8, "C"
    Zero_Reg
    close_v2_completely
    Move_Valve 3, "C" ' this opens valve 4, which is always backwards
    Move_Valve 2, "O"
    MsgBox "Open sample chamber, remove sample, clean chamber, leave chamber open"
    Move_Valve 22, "O"
    progress.List1.AddItem ("Draining resin sample chamber - please wait")
    waitseconds (Resin_Drain_Seconds)
    Move_Valve Resin_Diverter_Valve - 1, "C"
    progress.List1.AddItem ("Draining main system - please wait")
    waitseconds (Resin_Drain_Seconds)
    Move_Valve 22, "C"
    progress.List1.AddItem ("Draining finished")
End Sub

Sub run_cyclic_compression()
    Dim i As Integer, T As Single, lt As Single
    If (safetydown = True And safetydowndoor = False) Or _
            (safetyup = True And safetyupdoor = False) Then
        ' note: don't bother to translate this - it should never be possible to display
        ' this message because the menu item that calls this is invisible in this case
        MsgBox "Can't run cyclic compression with safety keypress feature"
        Unload info_form
        Exit Sub
    End If
    If (safetydown = True And safetydowndoor = True) Or _
            (safetyup = True And safetyupdoor = True) Then
        check_safety_door True
        If safety_canceled = True Then
            Unload info_form
            Exit Sub
        End If
    End If
    If status_lights_enable Then setStatusLights 2
    info_form.Label1 = ts$(128)         ' "Setting Compression Pressure"
    info_form.Label2 = ts$(228)         ' "Please Wait"
    info_form.Caption = ts$(129)        ' "Cyclic Pressure Initializing"
    If autocompress Then move_compression_regulator_to_pressure (cyclic_compression_pressure)
    Unload info_form
    cyclic_compression_status.Show 0
    With cyclic_compression_status
        If autopiston Then .Label1.Caption = ts$(130)   ' "Pressure Not Available"
        .Command1.Enabled = True
        For i = 1 To cyclic_compression_numcycles
            ' read compression pressure value and show it just so they will know what it is
            If autocompress Then
                ReadXReturnX4 35
                .Label1.Caption = ts$(131) + ":" + str$(x5 * PCNV) + " " + PU$      ' "Comp. Press."
            End If
            .Label2.Caption = ts$(132) + ":" + str$(i) + " " + ts$(235) + str$(cyclic_compression_numcycles) ' "Cycle Number"/"of"
            DoEvents
            ' compress piston
            If autopiston Or (safetydown = True And safetydowndoor = True) Then
                If (RSEcho("R@", ver1or2) And 1) = 1 Then
                    MsgBox ts$(279)         ' "Test aborting because safety cover has been opened"
                    Exit For
                End If
            End If
            move_piston "O"
            T = Timer
            .Label3.Caption = ts$(280)      ' "Compressing"
            Do
                DoEvents
                lt = Timer
                If lt + 0.1 < T Then T = T - 86400
                If (lt - T) >= cyclic_compression_timedown Or Aborted Then Exit Do
                ' no sense in updating the display more often than once every 0.1 seconds
                waitseconds 0.1
                .Label3.Caption = ts$(280) + " - " + ts$(281) + ":" + str$(cyclic_compression_timedown - (lt - T))   ' "Compressing - Seconds Left"
            Loop
            ' decompress piston
            ' autopiston does not check door on up stroke, only down
            ' compression can check on up stroke due to pinch point
            If safetyup = True And safetyupdoor = True Then
                If (RSEcho("R@", ver1or2) And 1) = 1 Then
                    MsgBox ts$(279) '"Test aborting because safety cover has been opened"
                    Exit For
                End If
            End If
            move_piston "C"
            T = Timer
            .Label3.Caption = ts$(282)      ' "Decompressing"
            Do
                DoEvents
                lt = Timer
                If lt + 0.1 < T Then T = T - 86400
                If (lt - T) >= cyclic_compression_timeup Or Aborted Then Exit Do
                waitseconds 0.1
                .Label3.Caption = ts$(282) + " - " + ts$(281) + ":" + str$(cyclic_compression_timeup - (lt - T))    ' "Decompressing - Seconds Left"
            Loop
            If Aborted Then Exit For
        Next i
        If status_lights_enable Then setStatusLights 1
        If Aborted Then
            MsgBox ts$(283)         ' "Test Aborted"
        Else
            MsgBox ts$(284)         ' "Compression Cycles Completed"
        End If
    End With
    Unload cyclic_compression_status
End Sub

Sub Run_Elev_LqPerm(x_array As dat_array)

    Dim P As Single                 ' First pressure reading
    Dim T As Single                 ' Timer reading
    Dim t2 As Single                ' Second timer reading
    Dim h As Single                 ' Height reading
    Dim h2 As Single                ' Second height reading
    Dim p2 As Single                ' Second pressure reading
    Dim VOL As Single               ' Calculated volume
    Dim lastpinctime As Single      ' Placeholder for time from one fill to the next
    Dim lastx4 As Long              ' Last DAC reading
    Dim fn As Integer               ' File placeholder for debug file
    Dim debug_i As Integer          ' index of points between stored data points for debug file
    Dim nowString$
    Dim a$
    Dim difftime As Double          ' Differential time between timer readings
    ' Next three variables are used to hold the result of calls to the performance counter
    Dim timestamp1 As LARGE_INTEGER, timestamp2 As LARGE_INTEGER
    Dim startTime As LARGE_INTEGER
    Dim fn2 As Integer
    Dim backup_x4 As Long
    Dim last2730readstatus As Boolean
    Dim last2730readtime As Single
    Dim single_pressure_sum_pressure As Single
    Dim single_pressure_sum_flow As Single
    Dim single_pressure_sum_n As Integer
    Dim pushing_penetrometer As Boolean ' true if we are pushing extra pressure to the
                                        ' penetrometer to try to get to the first data point
    Dim using_overshoot_from_last_time As Boolean
    Dim f As Double         ' override global f with double precision for very low flow
    Dim PS_pointsDone As Integer        ' Count of pressure step points that have been taken so far.

' **********
' Begin code inserted by search for Tim Richards on Monday 6/14/04
' change     Msgform.Label.Caption = Format$(x5, "#0.00 \c\m   ") + Format$(x4, "####0 " + ts$(432))  ' "\c\m"/"\c\o\u\n\t\s"
'
    Dim s_local_BalanceNotPenet_gm_cm As String
    Dim s_local_BalanceNotPenet_Height_Mass As String
    Dim r_mean_pressure As Single           'TAR040621
    Dim r_mean_pressure_div As Integer      'TAR040621

    Dim l_ptarg As Single  'TAR 040715
        
    Dim flush_ptarg As Single
    Dim flush_ccs As Single
    

'   **********l
'   TAR040625 4:47PM
'   Set up a censusing array so that we can see exactly how each measurement is being taken
'   and what state / how consistent the measurements are.
'   structInitialMeasurements.Pressure = P
'   structInitialMeasurements.Mass = h
'   structInitialMeasurements.Time = T
'
'    Dim r_arrayMeas_Index As Long
'    Const c_ArrayMeas_Max = 16384

'    Dim structInitialMeasurements As MeasurementsRecord
'    Dim structStartMeanPressMeas As MeasurementsRecord
'    Dim arrayMeasurements(1 To c_ArrayMeas_Max) As MeasurementsRecord
'    Dim mean_diff_Measurements As MeasurementsRecord
'    Dim structFinalMeasurements As FinalMeasurements
    ' new variables 6.71.81
    Dim last_pulse_23_time As Single
    Dim ip_regulator_count_offset As Long
    Dim L As Long
    Dim local_time As Single
    Dim last_time_regulator_incremented As Single
    Dim findRegValue As Boolean
    Dim targCounts As Integer
    findRegValue = Not UseRegCalForLP
    
    Move_Valve 22, "C" 'AJB 11-04-09
    ReadXReturnX4 4
    Dim initialPen As Double
    initialPen = x5
    Move_Valve 16, "C"
    regnum = 0
    If (air_inlets = 2) Then
        Move_Valve 15, "C"
        current_air_inlet = 1
    End If
    
'    r_arrayMeas_Index = 1

'   TAR040625
'   **********
'

    If g_bBalanceNotPenet = True Then
        r_mean_pressure = 0                     'TAR040621
        r_mean_pressure_div = 1                 'TAR040621
        ReadXReturnX4 4                                      'TAR040620
        s_local_BalanceNotPenet_gm_cm = ts$(484)
        s_local_BalanceNotPenet_Height_Mass = ts$(486)
    Else
        s_local_BalanceNotPenet_gm_cm = ts$(485)
        s_local_BalanceNotPenet_Height_Mass = ts$(243)
    End If
'
' End code inserted by Tim Richards 6/14/04
' **********

    PS_pointsDone = 0
    last2730readstatus = False ' read 27 next
    last2730readtime = Timer ' last time we read either of them
    last_pulse_23_time = Timer
    single_pressure_sum_pressure = 0
    single_pressure_sum_flow = 0
    single_pressure_sum_n = 0
    
    lastpinctime = Timer            ' Take reading of current time

    ' increase compression pressure if necessary before we increase pressure quickly
    If autocompress And compression_pressure <> 0 And Compression_Increase_Factor > 0 Then
        move_compression_regulator_to_pressure (compression_pressure + ptarg * Compression_Increase_Factor)
    End If

    ' convert ptarg and MaxP from differential to absolute
    ptarg = ptarg + real_atm
    MaxP = MaxP + real_atm
    ' where step pressure is 0, we want a fake very high MaxP to avoid triggering the
    ' end of the test due to pressure fluctuations
    If DELTAP = 0 Then MaxP = MaxP + 1000
    Dim tempSwitchLPGauge As Boolean
    
    If switchLPGauge Then
        tempSwitchLPGauge = switchLPGauge
        switchLPGauge = False
    End If
    
    If LP_FlushBeforeTest Then
        progress.Line25.Caption = "Performing Flush Procedure"
        progress.Line25.Refresh
        
        If Drain12 Then
            If g_bBalanceNotPenet Then
                r_mean_pressure = 0         'TAR040621
                r_mean_pressure_div = 1     'TAR040621
                Move_Valve 11, "C"  'TAR note 040617 'BD 4/4
            Else
                Move_Valve 11, "O"  'TAR note 040617 'not changed '1293 5/7
                If Not topDownLp Then
                    Move_Valve 22, "C"
                End If
            End If
        ElseIf liqpermonly = False Then
            Move_Valve 2, "O"
        Else
        
        End If
        Move_Valve 8, "C"
        move_motorized_regulator_to_pressure LP_FlushPressure
        ReadXReturnX4 4
        h = x5
        Move_Valve 8, "O"
        
        Do
            ReadXReturnX4 4
            h2 = Abs(x5 - h)
            DoEvents
            If (h2 < LP_CCsToFlush) Then Exit Do
        Loop
        Move_Valve 8, "C"
        Zero_Reg
        
        progress.Line25.Caption = "Refilling Penetrometer"
        progress.Line25.Refresh
        
        Refill_Penetro
        If recirculation Then Move_Valve 20, "O" ' also re-open valve 21 if we just refilled
        If Drain12 Then
            If g_bBalanceNotPenet = True Then
                r_mean_pressure = 0         'TAR040621
                r_mean_pressure_div = 1     'TAR040621
                Move_Valve 11, "C"  'TAR note 040617 'BD 4/4
            Else
                Move_Valve 11, "O"  'TAR note 040617 'not changed '1293 5/7
                If Not topDownLp Then
                    Move_Valve 22, "C"
                End If
            End If
        ElseIf liqpermonly = False Then
            Move_Valve 2, "O"
        End If
    
        If penet_refill_delay > 0 Then waitseconds (penet_refill_delay)
    End If
    
    ' Get a value from the regulator calibration if we can
    If UseRegCalForLP Then
    
        If ptarg - real_atm < 0.5 Then
            ' No extrapolation allowed at low pressures: too inaccurate
            targCounts = GetRegulatorCalValue(ptarg - real_atm, False)
        Else
            ' Allow extrapolation for high pressures
            targCounts = GetRegulatorCalValue(ptarg - real_atm, True)
        End If
    
        If targCounts < 0 Then
            ' An error value means we have to find the pressure the old fashioned way
            findRegValue = True
        Else
            ' No need to search for pressure
            findRegValue = False
            Set_Regulator 1, targCounts
        End If
    End If
    
    ' 6.71.81 preset regulator to as close to first target pressure as we can
    ' note that valve 9 should be closed at this point, so the sample won't actually
    ' be pressurized.  This only works for new machines
    ip_regulator_count_offset = 0 ' default value
    If ip_reg_enable And DELTAP > 0 And findRegValue Then
'    If ip_reg_enable And DELTAP > 0 And PA <> 1 Then
        l_ptarg = ptarg
        'If l_ptarg < 0.5 + real_atm Then l_ptarg = 0.5 + real_atm
        If l_ptarg < lperm_initializeRegulatorPressure + real_atm Then l_ptarg = lperm_initializeRegulatorPressure + real_atm
        move_motorized_regulator_to_pressure l_ptarg - real_atm
        ip_regulator_count_offset = REGPOS ' initial regpos from table
        last_time_regulator_incremented = Timer
        ' step 1, wait for pressure to rise above what we want,
        ' incrementing every 5 seconds if necessary
        ' - we should already be close because of the previous move
        Do
            ReadXReturnX4 2
            
            progress.Line26.Caption = "1:P=" + Xformat$((x5 - real_atm) * PCNV, "###0.000  ") + PU$ + "  R=" + Format$(REGPOS)
            progress.Line26.Refresh
            If x5 >= l_ptarg Then Exit Do
            local_time = Timer
            If local_time + 1 < last_time_regulator_incremented Then
                last_time_regulator_incremented = last_time_regulator_incremented - 86400
            End If
            If local_time - last_time_regulator_incremented > 2 Then
                If REGPOS = 4000 Then Exit Do
                inc_reg lperm_regulatorIncrementSteps
                last_time_regulator_incremented = local_time
            End If
        Loop
        ' step 2, decrement the regulator by 1 until the pressure drops below
        ' what we want
        Do
            ReadXReturnX4 2
            progress.Line26.Caption = "2:P=" + Xformat$((x5 - real_atm) * PCNV, "###0.000  ") + PU$ + "  R=" + Format$(REGPOS)
            progress.Line26.Refresh
            If x5 < l_ptarg Then Exit Do
            local_time = Timer
            If local_time + 1 < last_time_regulator_incremented Then
                last_time_regulator_incremented = last_time_regulator_incremented - 86400
            End If
            If local_time - last_time_regulator_incremented > 1 Then
                If REGPOS = 0 Then Exit Do
                lower_reg lperm_regulatorIncrementSteps
                last_time_regulator_incremented = local_time
            End If
        Loop
        ' step 3, wait for pressure to rise above what we want,
        ' incrementing every 5 seconds if necessary
        ' minimum wait 20 seconds
        Do
            ReadXReturnX4 2
            progress.Line26.Caption = "3:P=" + Xformat$((x5 - real_atm) * PCNV, "###0.000  ") + PU$ + "  R=" + Format$(REGPOS)
            progress.Line26.Refresh
            local_time = Timer
            If local_time + 1 < last_time_regulator_incremented Then
                last_time_regulator_incremented = last_time_regulator_incremented - 86400
            End If
            If x5 >= l_ptarg And (local_time - last_time_regulator_incremented) > 20 Then Exit Do
            If x5 < l_ptarg And (local_time - last_time_regulator_incremented) > lperm_init_wait Then
                If REGPOS = 4000 Then Exit Do
                inc_reg lperm_regulatorIncrementSteps
                last_time_regulator_incremented = local_time
            End If
        Loop
        progress.Line26.Caption = ""
        progress.Line26.Refresh
        ip_regulator_count_offset = REGPOS - ip_regulator_count_offset
        ' if necessary, lower the regulator to match the actual ptarg
        If ptarg < l_ptarg Then
            L = regpos_from_p(ptarg - real_atm) ' + ip_regulator_count_offset
            If L < REGPOS Then
                Zero_Reg
                ' drain off some excess pressure, if possible
                Dry_Chamber_Control "O"
                Move_Valve 2, "O"
                waitseconds 2
                Dry_Chamber_Control "C"
                Move_Valve 2, "C"
                waitseconds 2
                inc_reg L
            End If
        End If
    End If

    If tempSwitchLPGauge Then
        switchLPGauge = True
        tempSwitchLPGauge = False
    End If
    
    nowString$ = Format(str$(now), "mmddyy_hhmm")
    If recirculation Then
        fn2 = FreeFile
        Open EXE_Path$ + "lqpermtempdata.txt" For Output As #fn2
        Print #fn2, "height"; vbTab; "pressure"; vbTab; "flow"; vbTab; "time"; vbTab; "temp at sample"; vbTab; "fluid temp"
    End If
    ' make "Turn" and "Record" visible on progress screen
    progress.mainmenu(1).Visible = True
    progress.mainmenu(4).Visible = True
    HKey$ = ""
    HKey2$ = ""
    
    'AJB 11-20-09
    testing = True
    
    ' Start the debugging log if appropriate
    If debugH20Perm Then
        fn = FreeFile
        Open "liqpermdebug_" + nowString$ + ".txt" For Append As #fn
        If penetrometer_select = 1 Then
            Print #fn, "PSIPERCM"; vbTab; PSIPERCM
        Else
            Print #fn, "PSIPERCM"; vbTab; P2PSIPERCM
        End If
        Print #fn, "sample_zero_point"; vbTab; sample_zero_point
        Print #fn, "liquid_lohm"; vbTab; liquid_lohm(penetrometer_select)
        If penetrometer_select = 1 Then
            Print #fn, "CSECAREA"; vbTab; CSECAREA
        Else
            Print #fn, "CSECAREA"; vbTab; P2CSECAREA
        End If
        Print #fn, "real_atm"; vbTab; real_atm
        ' old header when we only stored one line per data point
        'Print #fn, "P"; vbTab; "P2"; vbTab; "H"; vbTab; "H2"; vbTab; "T"; vbTab; "T2"
        ' we now store multiple lines per data point
        Print #fn, "i"; vbTab; "P(psi)"; vbTab; "H(cm)"; vbTab; "T(sec)"
        ' leave the file open
        'Close #fn
    End If
    
3860   ' Return point after each penetrometer refill cycle during the test
    'AJB 11-20-09
    Debug.Print "Run_Elev_LqPerm: 3860"
    
    If recirculation Then Move_Valve 20, "O" ' also re-open valve 21 if we just refilled

    ' open the drain valve to allow flow out of system
    If Drain12 Then

        If g_bBalanceNotPenet = True Then
' **********
' Begin Balance Not Penet code by search for Tim Richards on Thursday 6/17/04
' make sure the iso valve is closed when using a Mettler balance
'
            r_mean_pressure = 0         'TAR040621
            r_mean_pressure_div = 1     'TAR040621

' Tim Richards, 1PM Thursday 6/17/04 AutoTest
' This is after you've filled the penetrometer on the 1293. The current test status screen is now up.
' At this point the program has accepted the prefill value for the Mettler and there was no penetrometer.
            Move_Valve 11, "C"  'TAR note 040617 'BD 4/4
        Else
            Move_Valve 11, "O"  'TAR note 040617 'not changed '1293 5/7
            If Not topDownLp Then
                Move_Valve 22, "C"
            End If
        End If
'
' End code entered by Tim Richards 6/17/04
' **********

    ElseIf liqpermonly = False Then
        Move_Valve 2, "O"
    End If
    
    ' 9-15-06 6.71.97 new optional time delay to let everything settle
    If penet_refill_delay > 0 Then waitseconds (penet_refill_delay)
    
    
    ' 9-15-06 6.71.97 moved opening of valve 9 until after the optional time delay
    ' if it is there, open valve 9 to allow pressure to get to the penetrometer
    ' note that valve 9 will have been closed (to vent the penetrometer to atmospheric pressure)
    '  during any refill cycle and is opened here
    Move_Valve 8, "O"

'//loop return here for next data point, should increment regulator but isn;t
3870
    'AJB 11-20-09
    Debug.Print "Run_Elev_LqPerm: 3870"
    DoEvents
    If autocompress And compression_pressure <> 0 And Compression_Increase_Factor > 0 Then
        test_compression_pressure ptarg - real_atm
    End If

    ' Raise pressure to initial value.
    ' first, read current height so we know how much to correct our pressure target
    using_overshoot_from_last_time = False
    ReadXReturnX4 4

    If ip_reg_enable Then
        ' 6.71.20

        If DELTAP = 0 And (Abs(ptarg - lperm_last_target_pressure) <= 0.01) And ptarg >= 25 Then
            ' use overshoot from last time
            using_overshoot_from_last_time = True
            move_motorized_regulator_to_pressure ptarg - lperm_last_pressure_overshoot - real_atm - (x5 - sample_zero_point) * PSIPERCM
        Else
            'move_motorized_regulator_to_pressure ptarg - real_atm - (x5 - sample_zero_point) * PSIPERCM
            L = regpos_from_p(ptarg - real_atm - (x5 - sample_zero_point) * PSIPERCM) ' + ip_regulator_count_offset
            If L > REGPOS Then
                inc_reg L - REGPOS
            End If
        End If
    Else
        ' during refill, if there is no valve 9 (old machine) the regulator would have been
        '  zeroed with initp set to the current position, so the following will also reset the
        '  regulator after refill on older machines.
        ' On newer machines, the regulator would not have been zeroed, so the following will do nothing
        '  after refill.
        If REGPOS < initp * 0.9 And (Not Aborted) Then
            inc_reg 10
            lastpinctime = Timer
            GoTo 3870
        Else
            ReadXReturnX4 2
            While x5 < ptarg And REGPOS < 4000
                If lperm_v6_reginccount > 0 And lperm_v6_reginccount < 4000 Then
                    inc_reg lperm_v6_reginccount
                Else
                    inc_reg 1
                End If
                Waitms lperm_v6_regincwait, False
                ReadXReturnX4 2
            Wend
        End If
    End If

    ' This is the starting point of the test after each refill. We take "starttime" as the next baseline
    ' point for time measurements
    QueryPerformanceCounter startTime

3871    ' Read pressure, height, time
    'AJB 11-20-09
    Debug.Print "Run_Elev_LqPerm: 3871"
'   **********
'   Begin special balance code for testing inserted by search for Tim Richards Thursday 6/17/04 5:56 PM
'
        ' CLOSE VALVE 12
    If g_bBalanceNotPenet = True Then
        Move_Valve 11, "C"
    End If
'
'   End special balance code by Tim Richards 6/17/04
'   **********

' **********
' Begin Balance Not Penetrometer code entered by search for Tim Richards on Monday 6/22/04 9:06AM
' increase the pressure rapidly
'
    If g_bBalanceNotPenet = True Then
        ' 6.71.54 next line was outside if block, but is only used by new balance code
        ReadXReturnX4 4
        reg_to_target_press ptarg, x5
    End If

    l_ptarg = ptarg 'TAR 040715 save ptarg because pentro code can push it up
'
' End code entered by Tim Richards 6/22/04
' **********

' **********
' Begin balance not penetrometer code entered by Tim Richards on Wednesday 8/4/04 1:02 PM
' wait the allotted time to allow settling
'
    If g_bBalanceNotPenet = True Then
        Elev_LqPerm_Settle g_iBalanceNotPenet_SettlingTime, g_bBalanceNotPenet
    End If
'
' End code entered by Tim Richards 8/4/04
' **********

    ReadXReturnX4 2
    P = x5
    If autocompress And compression_pressure <> 0 And Compression_Increase_Factor > 0 Then
        test_compression_pressure P - real_atm
    End If
    ReadXReturnX4 4
    h = x5
    lastx4 = x4

    QueryPerformanceCounter timestamp1
    T = Timer
    
    debug_i = 0

    ' Quit the test the moment the penetrometer has been emptied - Mix
    If h <= minimum_liquid_test_stop_point Then
        MsgBox "Penetrometer Emptied"
        Move_Valve 11, "C"
        GoTo sub_done
    End If
' **********
' Begin Balance Not Penetrometer code entered by search for Tim Richards on Friday 6/25/04 4:10PM
'
'    structInitialMeasurements.Pressure = P
'    structInitialMeasurements.mass = h
'    structInitialMeasurements.time = T
'
' End code entered by Tim Richards 6/25/04
' **********

    ' Update display

' **********
' Begin Balance not Penetrometer code entered by search for Tim Richards on Sunday June 20, 2004 1:34PM
' modify the progress line to read a 'tare' balance using coopted sample_zero_point
'
    If g_bBalanceNotPenet = True Then
        'Debug.Print "g_bBalanceNotPenet = true"
        Progress_Output (P - real_atm) * PCNV, h, (ptarg - real_atm) * PCNV
    Else
        Progress_Output (P - real_atm) * PCNV, h, (ptarg - (h - sample_zero_point) * PSIPERCM - real_atm) * PCNV
    End If
'
' End Balance not Penetrometer code by Tim Richards 6/20/04
' **********

    progress.Line25.Refresh

    If recirculation Then

        backup_x4 = x4
        ' for recirculation system, read the two temperatures as well
        ' but only one at a time, and only once per 1/2 second
        If last2730readtime > Timer + 0.1 Then last2730readtime = last2730readtime - 86400
        If (Timer - last2730readtime) >= 0.5 Then
            last2730readtime = Timer
            If last2730readstatus Then
                'ReadXReturnX4 27
                x5 = readNewTemperature(wetChamberTemperature)
                a$ = ts$(452) + ": " + Xformat$(x5, "#####.0") + " " + tsunit$          ' "Fluid at Sample"
                last2730readstatus = False
            Else
                'ReadXReturnX4 30
                x5 = readNewTemperature(reservoirTemperature)
                progress.Line26.Caption = ts$(453) + ": " + Xformat$(x5, "#####.0") + " " + tsunit$ + "     " + a$      ' "Recirculating Fluid"
                last2730readstatus = True
            End If
        End If
        ' also check the door switch for old ballard that returns >40 if switch hit and
        ' <40 if door open but will never return <2
        ' If return value is <2, this is not a ballard version, so we should let it pass
        x4 = RSEcho("R@", ver1or2)
        If x4 <= 40 And x4 > 1 Then
            Aborted = True
        End If
        x4 = backup_x4
    End If
'    ' Write to the debugging log if appropriate
'    If debugH20Perm Then
'        fn = FreeFile
'        Open "liqpermdebug_" + nowString$ + ".txt" For Append As #fn
'        Print #fn, (P - real_atm); ","; h; ","; time_difference(starttime, timestamp1)
'        Close #fn
'    End If

    'AJB11-20-09
    'Debug.Print "Lastx4: " + Str$(lastx4)
    
    If lastx4 > 1 Then inrange = True
    DoEvents

' **********
' Begin Balance Not Penet code by search for Tim Richards on Thursday 6/17/04 3:59PM
' Don't use penetrometer code.
'
    If g_bBalanceNotPenet = False Then
'
' End code entered by Tim Richards 6/17/04
' **********

        ' See if we've reached the bottom of the penetrometer. If we have, do a refill and loop back.
        If lastx4 > pen_max_counts Then
            ' we don't refill when deltap=0, as well as other reasons
            If FillDone Or norefill Or DELTAP = 0 Then
                GoTo sub_done
            Else
                Refill_Penetro
                GoTo 3860
            End If
        End If

' **********
' Begin Balance Not Penet code by search for Tim Richards on Thursday 6/17/04 3:59PM
' Don't use penetrometer code.
'
    End If
'
' End code entered by Tim Richards 6/17/04
' **********
 
    ' If we're below target pressure, increment the regulator and then loop back to 3871.
    
' **********
' Begin Balance Not Penet code by search for Tim Richards on Thursday 6/17/04 2:35PM
' change     If P + (h - sample_zero_point) * PSIPERCM < ptarg And P <= MaxP And (Not Aborted) And ptarg > real_atm + 0.01 Then
'
    Dim b_local_BalanceNotPenet_increment_regulator As Boolean
    Dim b_local_BalanceNotPenet_decrement_regulator As Boolean

    If g_bBalanceNotPenet = True Then
        b_local_BalanceNotPenet_increment_regulator = P < ptarg
    Else
        'b_local_BalanceNotPenet_increment_regulator = P + (h - sample_zero_point) * PSIPERCM < ptarg
    End If

    If b_local_BalanceNotPenet_increment_regulator Then
        If P <= MaxP And (Not Aborted) And ptarg > real_atm + 0.01 Then
            ' don't increment the regulator more than once every second
            t2 = Timer
            If lastpinctime > t2 + 0.1 Then lastpinctime = lastpinctime - 86400     ' midnight crossover check
            ' if this is the first or second data point, don't increment more than once every
            ' 1 seconds (allow the faster increment if we are using deltap=0)
            If (t2 - lastpinctime) < 1 And points < 3 And DELTAP > 0 Then GoTo 3871
            ' otherwise, don't increment more than once per 0.5 seconds
            If (t2 - lastpinctime) < 0.5 And DELTAP > 0 Then GoTo 3871
            ' 6.71.54 fix for Tim's change to make regulator test work again
            '  he went from a single if block to a double nested if block
            '  and the following code was moved to outside the middle if block
            '  This moves it back inside again
            If g_bBalanceNotPenet = True Then
                inc_reg 1
            Else
                ' he also lost this increment regulator for non-balance machines
                ' which messed up elevated pressure testing
                'inc_reg 2 ' 6.71.81 was 10
                inc_reg lperm_regulatorIncrementSteps * 2
                ip_regulator_count_offset = ip_regulator_count_offset + (lperm_regulatorIncrementSteps * 2)
            End If
'
' End code entered by Tim Richards 6/17/04
' **********

            lastpinctime = Timer
            ' if deltap=0 then we are wanting to hold the same pressure and take multiple readings
            ' so we don't loop back as this would take too long and we only have one penetrometer pass
            ' to work with.
        
' **********
' Begin Balance Not Penet code by search for Tim Richards on Thursday 6/17/04 4:06PM
' change If DELTAP > 0 Then GoTo 3871
'
            If g_bBalanceNotPenet = False And DELTAP > 0 Then GoTo 3871
            If g_bBalanceNotPenet = True And inrange = False And DELTAP > 0 Then GoTo 3871
'
' End code entered by Tim Richards 6/17/04
' **********

        End If
        ' 6.71.54 end
    End If

    ' If we're above target pressure, and deltap=0, decrement the regulator

' **********
' Begin Balance Not Penet code by search for Tim Richards on Thursday 6/17/04 2:46PM
' change     If P + (h - sample_zero_point) * PSIPERCM > ptarg And P <= MaxP And (Not Aborted) And DELTAP = 0 Then
' change lower_reg 10
'
    If g_bBalanceNotPenet = True Then
        b_local_BalanceNotPenet_decrement_regulator = P > ptarg
    Else
        b_local_BalanceNotPenet_decrement_regulator = P + (h - sample_zero_point) * PSIPERCM > ptarg And DELTAP = 0
    End If

    If b_local_BalanceNotPenet_decrement_regulator Then
        If g_bBalanceNotPenet = True Then
            GoTo 3885
        Else
            lower_reg 10    ' no change TAR 040617
        End If
    End If
'
' End code entered by Tim Richards 6/17/04
' **********

    If Aborted Or P > MaxP Then GoTo sub_done
    
    If dualregulator Then
        If regnum = 0 And P - real_atm > reg1pmax Then
            lower_reg 4000 - second_regulator_starting_point
            waitseconds 3
            Move_Valve 16, "O"
            regnum = 1
            If (air_inlets = 2) Then
                Move_Valve 15, "O"
                current_air_inlet = 2
            End If
        End If
    End If
    
    If Not inrange Then GoTo 3870
    If h > penetrometer_start_test_point Then
        ' if we aren't getting anywhere and the starting pressure is 0, we need to increase
        ' the regulator a little bit
        ' if we have valve 23, we don't need to do this, we can pulse valve 23 instead
        If ptarg - real_atm < 0.001 And valve_23_exists = False Then
            ' we need to increase the regulator a little bit to start pushing the penetrometer
            pushing_penetrometer = True
            ' only increase up to 2 psi above the zero point (which is the pressure target)
            If P < ptarg + 2 Then
                inc_reg 1
            End If
        End If
        If valve_23_exists Then
            If last_pulse_23_time > Timer + 0.1 Then last_pulse_23_time = last_pulse_23_time - 86400
            If (Timer - last_pulse_23_time) >= 1 Then
                last_pulse_23_time = Timer
                Move_Valve 22, "O"
                Move_Valve 22, "C"
            End If
        End If
        GoTo 3871
    End If

    If pushing_penetrometer Then
        ' we need to stop pushing
        Zero_Reg
        Move_Valve 8, "C"
        Move_Valve 8, "O"
        Move_Valve 8, "C"
        Move_Valve 8, "O"
        Move_Valve 8, "C"
        Move_Valve 8, "O"
        pushing_penetrometer = False
        GoTo 3871 ' loop back for another reading to get everything settled
    End If

    t2 = Timer
    If lastpinctime > t2 + 0.1 Then lastpinctime = lastpinctime - 86400     ' midnight crossover check
    If (t2 - lastpinctime) < PulseDelay Then GoTo 3871      ' See version notes on 6.54.29
    If points = 1 And P + (h - sample_zero_point) * PSIPERCM > ptarg Then
        ptarg = P + (h - sample_zero_point) * PSIPERCM
    End If

3885 'setup for second section which loops on the time interval for flow measurement---TAR040621
    ' this is only used for balance, not penetrometer
    r_mean_pressure = P             'TAR040621
    r_mean_pressure_div = 1         'TAR040621
    
    'AJB 11-20-09
    Debug.Print "Run_Elev_LqPerm: 3885"
    
'    structStartMeanPressMeas.Pressure = P
'    structStartMeanPressMeas.time = Timer
'    structStartMeanPressMeas.mass = h
    ' clear out any previous "record" press
    HKey$ = ""
    
    If debugH20Perm Then
        debug_i = debug_i + 1
        Print #fn, debug_i; vbTab; P; vbTab; h; vbTab; "0"
    End If
    
' --------- second section -----------
3890
    'AJB 11-20-09
    Debug.Print "Run_Elev_LqPerm: 3890"
    
    ' Read pressure, height, time again
    DoEvents
    
    If cartridge_tester And cartridge_tester_side = 1 Then
        switchLPGauge = True
    End If
    
    ReadXReturnX4 2
    
    If cartridge_tester And cartridge_tester_side = 1 Then
        switchLPGauge = False
    End If
    
    p2 = x5
    If autocompress And compression_pressure <> 0 And Compression_Increase_Factor > 0 Then
        test_compression_pressure p2 - real_atm
    End If

    ReadXReturnX4 4
    h2 = x5
    t2 = Timer
    QueryPerformanceCounter timestamp2
    difftime = time_difference(timestamp1, timestamp2)

    If debugH20Perm Then
        debug_i = debug_i + 1
        Print #fn, debug_i; vbTab; p2; vbTab; h2; vbTab; t2 - T
    End If

' **********
' Begin Balance Not Penetrometer code entered by search for Tim Richards on Sunday 6/20/04 7:06PM
'
'   **********
'   TAR040625
'    If (r_arrayMeas_Index <= c_ArrayMeas_Max) Then
        ' Disabled these assignments 11/15/04 - were causing overflow errors. MJLC
'        arrayMeasurements(r_arrayMeas_Index).Pressure = P2
'        arrayMeasurements(r_arrayMeas_Index).mass = H2
'        arrayMeasurements(r_arrayMeas_Index).time = t2
'        arrayMeasurements(r_arrayMeas_Index).diffT2time = t2 - T - difftime
'        r_arrayMeas_Index = r_arrayMeas_Index + 1
'    End If
'   TAR040625
'   **********
    
    r_mean_pressure = r_mean_pressure + p2            'TAR040621
    r_mean_pressure_div = r_mean_pressure_div + 1     'TAR040621
'
' End Balance Not Penetrometer code by Tim Richards 6/20/04
' **********


' **********
' Begin special balance code for testing inserted by search for Tim Richards Thursday 6/17/04 5:56 PM
' make sure valve 12 remains open during the test.
'
    ' OPEN VALVE 12
    If g_bBalanceNotPenet = True Then
        Move_Valve 11, "O"
        If Not topDownLp Then
            Move_Valve 22, "C"
        End If
    End If
'
' End special balance code by Tim Richards 6/17/04
' **********


' **********
' Begin Balance not Penetrometer code entered by search for Tim Richards on Sunday June 20, 2004 1:34PM
' modify the progress line to read a 'tare' balance using coopted sample_zero_point
'
    Progress_Output_Time (p2 - real_atm) * PCNV, h2, t2 - T
'
' End Balance not Penetrometer code by Tim Richards 6/20/04
' **********

    progress.Line25.Refresh

    If recirculation Then

        backup_x4 = x4
        ' for recirculation system, read the two temperatures as well
        ' but only one at a time, and only once per 1/2 second
        If last2730readtime > Timer + 0.1 Then last2730readtime = last2730readtime - 86400
        If (Timer - last2730readtime) >= 0.5 Then
            last2730readtime = Timer
            If last2730readstatus Then
                'ReadXReturnX4 27
                x5 = readNewTemperature(wetChamberTemperature)
                a$ = ts$(452) + ": " + Xformat$(x5, "#####.0") + " " + tsunit$      ' "Fluid at Sample"
                last2730readstatus = False
            Else
                'ReadXReturnX4 30
                x5 = readNewTemperature(reservoirTemperature)
                progress.Line26.Caption = ts$(453) + ": " + Xformat$(x5, "#####.0") + " " + tsunit$ + "     " + a$      ' "Recirculating Fluid"
                last2730readstatus = True
            End If
        End If
        ' also check the door switch
        x4 = RSEcho("R@", ver1or2)
        If x4 <= 40 And x4 > 1 Then
            Aborted = True
        End If
        x4 = backup_x4
    End If
    
    ' 2 counts is 2.49% of span below zero
    ' 20000 counts is 97.5% of span above zero
    If x4 < DAC_zero - DAC_span * 0.0249 Or x4 > pen_max_counts Then
        If FillDone Or norefill Or DELTAP = 0 Then
            GoTo sub_done
        Else
            Refill_Penetro
            GoTo 3860
        End If
    End If

    While t2 + 0.1 < T: T = T - 86400!: DoEvents: Wend
    test_record
    If (t2 - T >= maxWait Or HKey$ = "R" Or Aborted) And difftime > 0 Then
        HKey$ = " "
        GoTo 3915
    End If
    ' 1000 counts differential is 1/20 of span
    If x4 - lastx4 < DAC_span * 0.025 Or (t2 - T < LP_mintime) Then GoTo 3890

' **********
' Begin code change for Balance not Penetrometer by Tim Richards on Sunday 6/20/04 12:32PM
' change 3915 If h <= H2 Then GoTo 3930
3915:
    'AJB 11-20-09
    Debug.Print "Run_Elev_LqPerm: 3915"
    
' 6.71.81 allow zero flow readings to be stored
'If h <= H2 Then     ' no change TAR040620
'    If g_bBalanceNotPenet = True Then
'        ' h is the initial, H2 is the final. We want final - initial. -TAR040620
'        ' This is because there is no height on the balance. We are dealing with an open
'        ' environment prone to errors as big as the differences in mass between readings. -TAR040620
'    Else
'        GoTo 3930   ' no change TAR040620
'    End If
'End If
'
' End code change by Tim Richards 6/20/04
' **********

' **********
' Begin balance not penetrometer code inserted by search for Tim Richards on Thursday 6/17/04 6:47PM
' elseif inserted after this code
'
    If g_bBalanceNotPenet = True Then
        VOL = (h2 - h) / g_iMettler_fluid_density

        If h2 / g_iMettler_fluid_density > g_iMettler_MaxFlowSetPoint Then
            MsgBox ts$(492), , ts$(493)   '"Reached maximum flow set point. Stopping Test.", , "Liquid Permeametry"
            Aborted = True
        End If
'
' End code inserted by Tim Richards 6/17/04
' **********

    ElseIf Second_Penetrometer And penetrometer_select = 2 Then
        VOL = P2CSECAREA * (h - h2)
    Else
        VOL = CSECAREA * (h - h2)
    End If
    If VOL < 0 Then VOL = 0 ' don't allow negative flow rates
    If difftime = 0 Then
        f = 0 ' just in case
    Else
        f = VOL / difftime * 60
    End If

    ' Write to the debugging log if appropriate
'    If debugH20Perm Then
'        fn = FreeFile
'        Open "liqpermdebug_" + nowString$ + ".txt" For Append As #fn
'        Print #fn, P; vbTab; P2; vbTab; h; vbTab; H2; vbTab; time_difference(starttime, timestamp1); vbTab; time_difference(starttime, timestamp2)
'        Close #fn
'    End If

' **********
' Begin balance not penetrometer code inserted by search for Tim Richards on Thursday 6/17/04 6:47PM
' elseif inserted after this code
'
    r_mean_pressure = r_mean_pressure / r_mean_pressure_div     'TAR040621

    If g_bBalanceNotPenet = True Then
        P = r_mean_pressure

'   **********
'   TAR040625
'
'    structFinalMeasurements.Volume = VOL
'    structFinalMeasurements.Flow = f
'    structFinalMeasurements.difftime = difftime
'    structFinalMeasurements.MeanPressure = P
'    structFinalMeasurements.MeanPoints = r_mean_pressure_div
'    structFinalMeasurements.MeasurementPoints = r_arrayMeas_Index - 1
'
'   TAR040625
'   **********

' 040714 Weds 8:15AM TAR

'    Dim structInitialMeasurements As MeasurementsRecord
'    Dim structStartMeanPressMeas As MeasurementsRecord
'    Dim arrayMeasurements(1 To c_ArrayMeas_Max) As MeasurementsRecord
'    Dim mean_diff_Measurements As MeasurementsRecord
'    Dim structFinalMeasurements As FinalMeasurements

'Type MeasurementsRecord
'    Pressure As Single
'    mass As Single
'    time As Single
'    diffT2time As Single
'End Type

'Type FinalMeasurements
'    Volume As Single
'    Flow As Single
'    difftime As Single
'    MeanPressure As Single
'    MeanPoints As Integer
'    MeasurementPoints As Integer
'End Type

 '   Dim i As Integer
 '   Dim l_fn As Integer
 '   Dim l_debugfilename As String

 '   l_fn = FreeFile
 '   On Error Resume Next
 '   l_debugfilename = Left$(OutFilename$(current_unit%), Len(OutFilename$(current_unit%)) - 4) + "_debug.csv"
 '   Open l_debugfilename For Output As #l_fn

'    Print #l_fn, "Initial Measurements"
'    Print #l_fn, "Pressure,Mass,Time,diffT2time"
'    With structInitialMeasurements
'        Print #l_fn, .Pressure; ","; .mass; ","; .time; ","; .diffT2time
'    End With
'    Print #l_fn, vbCrLf

'    Print #l_fn, "Measurements During Test"
'    Print #l_fn, "Index,Pressure,Mass,Time,diffT2time"
 '   For i = 1 To structFinalMeasurements.MeasurementPoints
   '     With arrayMeasurements(i)
  '          Print #l_fn, i, ","; .Pressure; ","; .mass; ","; .time; ","; .diffT2time
   '     End With
  '  Next i
'    Print #l_fn, vbCrLf

'    Print #l_fn, "Final Measurements"
'    Print #l_fn, "Volume,Flow,Time Diff,Mean Pressure,Mean Points,Measurement Points"
'    With structFinalMeasurements
'        Print #l_fn, .Volume; ","; .Flow; ","; .difftime; ","; .MeanPressure; ","; .MeanPoints; ","; .MeasurementPoints
'    End With
'    Print #l_fn, vbCrLf
'
'    Close #l_fn
'
' End code inserted by Tim Richards 6/17/04
' **********

    ElseIf Second_Penetrometer And penetrometer_select = 2 Then
        P = (h2 + h) / 2 * P2PSIPERCM + (P + p2) / 2
    Else
        P = (((h2 + h) / 2) - sample_zero_point) * PSIPERCM + (P + p2) / 2

    End If
    
    'AJB 11-20-09
    Debug.Print "Collecting Data"
    
    ' 6.71.81 correct for lohm value
    'P = P - (liquid_lohm(penetrometer_select) * f / 75700) ^ 2
    Debug.Print "LiquidLohm: " + str$(liquid_lohm(penetrometer_select))
    'ANDY DO STUFF HERE
    If h - initialPen < 10 Then
        points = points + 1
        dat_size_check x_array, points
    
        x_array.a(points).fl = f
        If f > 0.75 * MaxLQFlow(penetrometer_select) Then FlowFlag = True
        x_array.a(points).pr = P
        x_array.a(points).eqd = 0
        x_array.a(points).time = time_difference(startTime, timestamp2)
        
        'AJB 10-20-09 6.71.130
        If dryChamberTemperature <> 0 Then
            x_array.a(points).temp1 = readNewTemperature(dryChamberTemperature)
        End If
            
        If airTemperature <> 0 Then
            x_array.a(points).temp2 = readNewTemperature(airTemperature)
        End If
        'AJB 10-20-09 6.71.130
        
        'TJM 3-23-2010 start
        If recordHumidityForAutoTests Then x_array.a(points).humidity = readHumiditySensor()
        'TJM 3-23-2010 end
        
        If use_temperature Or recirculation Then read_temperature points, True
        took_point_time = Timer
    End If
    If h <= minimum_liquid_test_stop_point Then GoTo sub_done
    If recirculation Then
        progress.List1.AddItem Xformat$(h - sample_zero_point, "     ##0.000") + Xformat$((P - real_atm) * PCNV, "         ##0.000") + Xformat$(f, "               ###0.0000") + Xformat$((t2 - T) / 60, "           ###0.0000") + Xformat$(temperature1(points), "   ##0.0") + Xformat$(temperature2(points), "   ##0.0")

' **********
' Begin Balance not Penetrometer code entered by search for Tim Richards on Sunday 6/20/04 2:03 PM
' change the listed item
'
    ElseIf g_bBalanceNotPenet = True Then
        progress.List1.AddItem Xformat$((P - real_atm) * PCNV, "         ##0.000") + Xformat$(h2, "     ##0.0000") + Xformat$((t2 - T) / 60, "           ###0.0000") + Xformat$(f, "               ###0.0000")
'
' End Balance not Penetrometer code by Tim Richards 6/20/04
' **********

    Else
        progress.List1.AddItem Xformat$(h - sample_zero_point, "     ##0.000") + Xformat$((P - real_atm) * PCNV, "         ##0.000") + Xformat$(f, "               ###0.0000") + Xformat$((t2 - T) / 60, "           ###0.0000")
    End If
    single_pressure_sum_pressure = single_pressure_sum_pressure + P - real_atm
    single_pressure_sum_flow = single_pressure_sum_flow + f
    single_pressure_sum_n = single_pressure_sum_n + 1
    progress.List1.ListIndex = progress.List1.ListCount - 1
    progress.List1.ListIndex = -1
    If points > maxPoints Then GoTo sub_done
    
    If recirculation Then
        Print #fn2, str$(h - sample_zero_point); vbTab; str$(P - real_atm); vbTab; str$(f); vbTab; str$(Timer); vbTab; str$(temperature1(points)); vbTab; str$(temperature2(points))
    End If
    pass = 1

3930 DoEvents
    FillDone = False
    'AJB 11-20-09
    Debug.Print "Run_Elev_LqPerm: 3930"
' **********
' Begin Balance Not Penetrometer code entered by search for Tim Richards at 5:45 PM 040715
' The penetrometer code can chang p_targ depending on the pressure necessary to push the fluid.
' (search for "if points = 1". This line changes ptarg, and balance code don't do that)
'
    If l_ptarg <> ptarg And g_bBalanceNotPenet = True Then
        ptarg = l_ptarg
    End If
'
' End code by Tim Richards 040715
' **********

    ' If we're doing a normal test, increment by deltaP and loop back; if we're using a pressure step list,
    ' then go to the next point.
    If HKey2$ = "T" Then
        HKey2$ = ""
        GoTo sub_done
    End If
    If Not PS_usingList Then
        ptarg = ptarg + DELTAP
        If ptarg <= MaxP And (Not Aborted) Then GoTo 3870
    ElseIf Not Aborted Then
        PS_pointsDone = PS_pointsDone + 1       ' increment the count
        If PS_pointsDone < pressure_steps.count Then        ' Still have more points to do
            ptarg = pressure_steps.values(PS_pointsDone + 1) + real_atm
            GoTo 3870
        Else
            GoTo sub_done
        End If
    End If
        
    
sub_done:
    ' Stop the pneumatic motor if we have one - Mix
    If PneumaticMotor Then Move_Valve pnumValve%, "C"

    'AJB 11-20-09
    Debug.Print "Run_Elev_LqPerm: sub_done"
    If recirculation Then
        Close #fn2
    End If
    If debugH20Perm Then
        Close #fn
    End If
    
    If DELTAP = 0 And single_pressure_sum_n > 0 Then
        progress.List1.AddItem "  " + ts$(454) + ": " + Format$(single_pressure_sum_flow / single_pressure_sum_n, "###0.0000")      ' "Average Flow Rate"
        progress.List1.AddItem ts$(449)     ' "Venting system, please wait"
        ' now check the pressure overshoot based on the average pressure of all the readings
        If using_overshoot_from_last_time = True Then
            lperm_last_pressure_overshoot = lperm_last_pressure_overshoot + (single_pressure_sum_pressure / single_pressure_sum_n) - ptarg
        Else
            lperm_last_pressure_overshoot = (single_pressure_sum_pressure / single_pressure_sum_n) - ptarg
        End If
        lperm_last_target_pressure = ptarg
        WPPS Curr_U$, "lperm_last_target_pressure", str$(lperm_last_target_pressure), IFile$
        WPPS Curr_U$, "lperm_last_pressure_overshoot", str$(lperm_last_pressure_overshoot), IFile$
    End If
    

'   **********
'   Begin special balance code for testing inserted by search for Tim Richards Friday 6/18/04 10:29 AM
'   there is no penetrometer so we don't have to wait for it to empty.
'
    If g_bBalanceNotPenet = True Then
        Exit Sub
    End If
'
'   End special balance code by Tim Richards 6/17/04
'   **********
    If cartridge_tester And cartridge_tester_side = 1 Then
        switchLPGauge = True
    End If
    
    
    If LP_DrainAfterTest Then
        progress.Line25.Caption = "Performing Drain Procedure"
        progress.Line25.Refresh
        
        Zero_Reg
        
        If AirTop Then
            Move_Valve 19, "O"
        ElseIf liqpermonly Or PEN20500 < 0 Or Drain12 Then
            Move_Valve 11, "O"
        Else
            Move_Valve 2, "O"
        End If
        
        waitseconds LP_DrainTime
        
        If AirTop Then
            Move_Valve 19, "C"
        ElseIf liqpermonly Or PEN20500 < 0 Or Drain12 Then
            Move_Valve 11, "C"
        Else
            Move_Valve 2, "C"
        End If
    End If
    
    
    ' check to make sure we are at the minimum penetrometer value allowed for ending the test
    ' Also check if the pressure is too high - Mix
    
   ' kj
   'Dim move%
  ' move% = 0
    While h > minimum_liquid_test_stop_point And Not Aborted And (P - real_atm) * PCNV < lperm_maxp
    'move% = move% + 1
'    If move% = 5 Then
'        move% = 0
'        inc_reg 1
'    End If
    If valve_23_exists And Vpos(23) = 0 Then
            Move_Valve 8, "C" ' vent penetrometer so liquid doesn't shoot out too fast
            'Move_Valve 22, "O" AJB 11-04-09
    End If
    ' let the system sit under pressure, updating h, until we are low enough for ending the test
    
    ReadXReturnX4 2
        
    P = x5
    ReadXReturnX4 4
    h = x5
    ' Update display
        
' **********
' Begin Balance not Penetrometer code entered by search for Tim Richards on Monday June 21, 2004 9:29PM
' use the output subroutine
'
        Progress_Output (P - real_atm) * PCNV, h, _
                        (ptarg - real_atm) * PCNV
'
' End Balance not Penetrometer code by Tim Richards 6/20/04
' **********
    Wend
    
    ' Close valve 12 for an empty penetrometer - Mix
    If h <= minimum_liquid_test_stop_point Then Move_Valve 11, "C"
    
    If cartridge_tester And cartridge_tester_side = 1 Then
        switchLPGauge = False
    End If
    If valve_23_exists And Vpos(23) = 1 Then
        Move_Valve 22, "C"
    End If
    'AJB 11-20-09
    testing = False
End Sub

Function read_gauge(g As Integer) As Single
' read gauge for liquid vapor system
' takes in g as 0 through 3
' 0 is the ground ref. - channel 15
' 1 is the +2 volt reg. - channel 14
' 2 is aux pressure gauge 1 - channel 27
' 3 is aux pressure gauge 2 - channel 30

Select Case g
    Case 0:
        x4 = raw_reading(15) ' the global X4 is also set with the count value
        read_gauge = (x4 - DAC_zero) * 2# / DAC_span
    Case 1:
        x4 = raw_reading(14)
        read_gauge = (x4 - DAC_zero) * 2# / DAC_span
    Case 2:
        x4 = raw_reading(27)
        read_gauge = (x4 - DAC_zero) * aux_p1_span / DAC_span
    Case 3:
        x4 = raw_reading(30)
        read_gauge = (x4 - DAC_zero) * aux_p2_span / DAC_span
End Select

End Function

Sub run_lv_man_ctrl()

Dim read_index%, guse%, vuse%, a$ ', b$, vuse%, i%
Dim last_data_read As Single
Dim lt As Single, T As Single
Dim timeint As Single
Dim fn As Integer

read_index% = 0
lv_man_ctrl.Show 0
last_data_read = Timer
While lv_man_ctrl.Quit.Enabled Or Len(pending$) > 0
  MsgBox "F1"
  DoEvents
  GoSub autoread
  If Len(pending$) > 0 Then
    vuse% = Asc(Left$(pending$, 1))
    MsgBox str(vuse%)
    If Len(pending$) = 1 Then
      pending$ = ""
    Else
      pending$ = Right$(pending$, Len(pending$) - 1)
    End If
    If vuse% >= 0 And vuse% <= 8 Then
      Rem valve command vuse 0-8 corresponds to valves -1,-2,-3,-4,-5,-6,-7,-8,-9
      Rem and vpos values are 0,-1,-2,-3,-4,-5,-6,-7,-8
      If Vpos(-vuse%) = 0 Then
          Rem open valve
          MsgBox "Move_Valve -1 - " + str(vuse%) + ", " + "O"
          Move_Valve -1 - vuse%, "O"
          lv_man_ctrl.ValveFill(vuse%).FillColor = vbGreen
      Else
          Rem close valve
          Move_Valve -1 - vuse%, "C"
          lv_man_ctrl.ValveFill(vuse%).FillColor = vbRed
      End If
      lv_man_ctrl.ValveClick(vuse%).Enabled = True
    ElseIf vuse% >= 20 And vuse% <= 27 Then
        ' commands with 20 added are valve pulsing
        ' we do valve pulsing for the time period specified in the global lv_valve_pulse_timing
        lv_valve_pulse vuse% - 20
    ElseIf vuse% = 40 Or vuse% = 41 Then
        lv_valve_pair_pulse vuse% - 40
    ElseIf vuse% = 60 Then
        ' pressure goto function
        With lv_man_ctrl
            .Check1(2).value = 1
            abort_lv_goto = False
            .Command2.Enabled = True
            lv_goto myVal(.Text1.Text), myVal(.Text2.Text), 0, .Label2(2)
            ' when goto returns, reset enables on stuff
            .Command1.Enabled = True
            .Command2.Enabled = False
            .Command3.Enabled = True
            .Text1.Enabled = True
            .Text2.Enabled = True
        End With
    ElseIf vuse% = 61 Then
        ' auto test function
        With lv_man_ctrl
            .Check1(2).value = 1
            .Check1(3).value = 1
            abort_lv_goto = False
            .Command2.Enabled = True
            timeint = myVal(.timeinc.Text)
            If .Option5(1).value Then
                timeint = timeint * 60
            ElseIf .Option5(0).value Then
                timeint = timeint * 60 * 60
            End If
            lv_run_auto myVal(.Text4.Text), timeint, myVal(.Text2.Text), myVal(.Text1.Text), myVal(.Text3.Text), myVal(.Text5.Text), myVal(.Text6.Text), .Label2(2), .Label2(3), .Label15, lv_man_ctrl.ofilename
            If status_lights_enable Then setStatusLights 1
            .Text1.Enabled = True
            .Text2.Enabled = True
            .Text3.Enabled = True
            .Text4.Enabled = True
            .Text5.Enabled = True
            .Text6.Enabled = True
            .Command1.Enabled = True
            .Command2.Enabled = False
            .Command3.Enabled = True
        End With
    End If
  End If
  If manual_data_logging Then
    timeint = myVal(lv_man_ctrl.timeinc.Text)
    If lv_man_ctrl.Option5(1).value Then
        timeint = timeint * 60
    ElseIf lv_man_ctrl.Option5(0).value Then
        timeint = timeint * 60 * 60
    End If
    lt = Timer
    If lt + 0.1 < last_data_read Then
        last_data_read = last_data_read - 86400
    End If
    If (lt - last_data_read) >= timeint Then
        last_data_read = lt
        fn = FreeFile
        On Error Resume Next
        Open lv_man_ctrl.ofilename For Append As #fn
        If Err.Number = 0 Then
            ' read first gauge
            x5! = read_gauge(2)
            ' store the time and the first gauge reading
            a$ = date$ + " " + time$ + " " + str$(x5!) + " "
            ' read the second gauge
            x5! = read_gauge(3)
            a$ = a$ + str$(x5!)
            Print #fn, a$
        End If
        Close #fn
        On Error GoTo 0
    End If
  End If
Wend
Unload lv_man_ctrl
Exit Sub
autoread:
  If lv_man_ctrl.Check1(read_index%).value = 1 Then
    ' read value for check box of read_index%
    guse% = read_index%
    x5! = read_gauge(guse%)
    a$ = Format$(x5!, "#####0.#####") + " "
    If read_index% < 2 Then
      a$ = a$ + "v"
    Else
      a$ = a$ + "torr"
    End If
    ' retest the check box just in case they turned it off
    ' between the time we started reading and now
    DoEvents
    If lv_man_ctrl.Check1(read_index%).value Then
      lv_man_ctrl.Label2(read_index%).Caption = a$ + " (" + str$(x4) + " " + ts$(231) + ")" ' "counts"
    End If
  End If
  read_index% = read_index% + 1
  If read_index% > 3 Then read_index% = 0
  Return
  
End Sub

Sub lv_run_auto(delta_p As Single, delta_t As Single, max_p As Single, min_p As Single, p_mult As Single, min_deltap As Single, start_p As Single, P1Label As Object, P2Label As Object, StatLabel As Object, ofile As String)

Dim fn As Integer, plast As Single, p1last As Single, p2last As Single, T As Single, lt As Single
Dim p1zero As Single, p2zero As Single
Dim i As Integer

StatLabel.Caption = ts$(286)            ' "Initializing Auto Test"

If delta_p <= 0 Then
    StatLabel.Caption = ts$(287)        ' "Auto Test Failed - delta_p must be > 0"
    Exit Sub
End If
If max_p <= 0 Then
    StatLabel.Caption = ts$(288)        ' "Auto Test Failed - max_p must be > 0"
    Exit Sub
End If
If min_p <= 0 Then
    StatLabel.Caption = ts$(289)        ' "Auto Test Failed - min_p must be > 0"
    Exit Sub
End If
If delta_t <= 0 Then
    StatLabel.Caption = ts$(290)        ' "Auto Test Failed - delta_t must be > 0"
    Exit Sub
End If
If p_mult < 1 Then
    StatLabel.Caption = ts$(291)        ' "Auto Test Failed - p_mult must be >= 1"
    Exit Sub
End If
If min_deltap <= 0 Then
    StatLabel.Caption = ts$(292)        ' "Auto Test Failed - min_deltap must be > 0"
    Exit Sub
End If
If start_p < 0 Then
    StatLabel.Caption = ts$(293)        ' "Auto Test Failed - start_p must be >= 0"
    Exit Sub
End If
fn = FreeFile
On Error Resume Next
Open ofile For Output As #fn
If Err.Number <> 0 Then
    StatLabel.Caption = ts$(294)        ' "Auto Test Failed - output file can not be opened"
    Close #fn
    Exit Sub
End If
On Error GoTo 0
If status_lights_enable Then setStatusLights 2
StatLabel.Caption = ts$(295)            ' "Initializing Valves"
lv_valve_close 0 ' close A
lv_valve_close 1 ' close B
lv_valve_close 2 ' close C
lv_valve_close 3 ' close D
lv_valve_close 4 ' close E
lv_valve_close 5 ' close F
lv_valve_close 6 ' close G
lv_valve_close 7 ' close H
lv_valve_open 8 ' open I
StatLabel.Caption = ts$(226)            ' "Evacuating"
lv_valve_open 0 ' open A
lv_valve_open 1 ' open B
lv_valve_open 3 ' open D
lv_valve_open 6 ' open G
lv_valve_open 7 ' open H
p1last = read_gauge(2)
P1Label.Caption = Format$(p1last, "#####0.#####") + " torr"
p2last = read_gauge(3)
P2Label.Caption = Format$(p2last, "#####0.#####") + " torr"
T = Timer
Do
    DoEvents
    lt = Timer
    If lt + 0.1 < T Then T = T - 86400
    x5! = read_gauge(2)
    P1Label.Caption = Format$(x5!, "#####0.#####") + " torr"
    If x5! < p1last Then
        p1last = x5!
        T = lt
    End If
    x5! = read_gauge(3)
    P2Label.Caption = Format$(x5!, "#####0.#####") + " torr"
    If x5! < p2last Then
        p2last = x5!
        T = lt
    End If
    StatLabel.Caption = ts$(296) + "= " + str$(30 - (lt - T))       ' "Evacuating - time left"
Loop Until (lt - T) >= 30 Or abort_lv_goto
StatLabel.Caption = ts$(297)                ' "Evacuation Finished"
lv_valve_close 0 ' close A
lv_valve_close 1 ' close B
lv_valve_close 3 ' close D
lv_valve_close 6 ' close G
lv_valve_close 7 ' close H
lv_valve_delay
plast = 0
If abort_lv_goto Then
    Close #fn
    StatLabel.Caption = ts$(283)        ' "Test Aborted"
    Exit Sub
End If
Print #fn, str$(p1last); ","; str$(p2last)
p1zero = p1last
p2zero = p2last
If start_p > 0 Then
    StatLabel.Caption = ts$(298)            ' "Reaching starting pressure"
    lv_valve_open 0 ' open A
    lv_valve_open 1 ' open B
    lv_valve_delay
    lv_goto start_p, start_p + min_p, p1zero, P1Label
    lv_valve_close 0 ' close A
    lv_valve_close 1 ' close B
    lv_valve_delay
    plast = read_gauge(2)
    P1Label.Caption = Format$(plast, "#####0.#####") + " torr"
End If
Do While plast + delta_p + min_p <= max_p
    StatLabel.Caption = ts$(299)            ' "Reaching next pressure"
    Do
        ' reach pressure slightly above plast+delta_p - minimum is plast+delta_p, maximum is plast+delta_p+min_p
        lv_goto (plast + delta_p) * p_mult, (plast + delta_p + min_p) * p_mult, p1zero, P1Label
        If abort_lv_goto Then
            Close #fn
            StatLabel.Caption = ts$(283)        ' "Test Aborted"
            Exit Sub
        End If
        StatLabel.Caption = ts$(300)            ' "Waiting for pressure to stabilize"
        T = Timer
        Do
            DoEvents
            p1last = read_gauge(2)
            P1Label.Caption = Format$(p1last - p1zero, "#####0.#####") + " torr"
            If p1last - p1zero < (plast + delta_p) * p_mult Then
                lt = -1 ' signify problem
                Exit Do
            End If
            If p1last - p1zero > (plast + delta_p + min_p) * p_mult Then
                lt = -1
                Exit Do
            End If
            lt = Timer
            If lt + 0.1 < T Then T = T - 86400
        Loop Until (lt - T) > 5
        If abort_lv_goto Then
            Close #fn
            StatLabel.Caption = ts$(283)        ' "Test Aborted"
            Exit Sub
        End If
        If lt < 0 Then
            StatLabel.Caption = ts$(301)        ' "Retrying to reach next pressure"
        End If
    Loop Until lt >= 0
    StatLabel.Caption = ts$(302)                ' "Pressure Reached - allowing gas to flow through sample"
    lv_valve_delay ' just in case
    lv_valve_open 0 ' open valve A
    i = 0 ' no readings so far
    T = Timer ' start new timer zero point
    lt = T
    Do
        ' record p1,p2,t every delta_t seconds
        p1last = read_gauge(2)
        P1Label.Caption = Format$(p1last - p1zero, "#####0.#####") + " torr"
        p2last = read_gauge(3)
        P2Label.Caption = Format$(p2last - p2zero, "#####0.#####") + " torr"
        Print #fn, str$(p1last); ","; str$(p2last); ","; str$(lt - T)
        i = i + 1
        ' wait delta_t seconds
        'Do
        '    DoEvents
        lt = Timer
        If lt + 0.1 < T Then T = T - 86400
        'Loop Until (lt - T) >= (delta_t * i) Or abort_lv_goto
        ' wait number of seconds needed until (lt-t)>=(delta_t*i)
        waitseconds (delta_t * i) - (lt - T)
    Loop Until (i > 2 And ((p1last - p1zero) - (p2last - p2zero)) < min_deltap) Or abort_lv_goto
    Print #fn, "-1,-1,-1" ' signify end of this section of data
    If abort_lv_goto Then
        Close #fn
        StatLabel.Caption = ts$(283)        ' "Test Aborted"
        Exit Sub
    End If
    StatLabel.Caption = ts$(303)            ' "Flow Recorded - equalizing pressure"
    lv_valve_open 1 ' open B
    ' wait 5 seconds
    T = Timer
    Do
        p1last = read_gauge(2)
        P1Label.Caption = Format$(p1last - p1zero, "#####0.#####") + " torr"
        p2last = read_gauge(3)
        P2Label.Caption = Format$(p2last - p2zero, "#####0.#####") + " torr"
        DoEvents
        lt = Timer
        If lt + 0.1 < T Then T = T - 86400
    Loop Until (lt - T) >= 5 Or abort_lv_goto
    If abort_lv_goto Then
        Close #fn
        StatLabel.Caption = ts$(283)        ' "Test Aborted"
        Exit Sub
    End If
    lv_valve_close 1 ' close B
    lv_valve_close 0 ' close A
    plast = read_gauge(2) - p1zero
    P1Label.Caption = Format$(plast, "#####0.#####") + " torr"
Loop
Print #fn, "-1,-1,-1" ' signify end of data
Close #fn
StatLabel.Caption = ts$(304)                ' "Auto Test Completed Normally"
End Sub

Sub run_manual_control()
    'Dim testInt As Integer
    Dim firstTime As Integer
    firstTime = 1
    testInt = 0
    Dim hhp As String  ' hi range hi pressure gauge.
    Dim hlp As String  ' hi range lo pressure gauge.
    Dim hhpVal As Single
    Dim hlpVal As Single
    hhpVal = 1 'just to give them different values to start with.
    hlpVal = 0
    Dim i As Boolean
    Dim Ret As String
    
    Dim valvePosLabel As String
    'Dim door_status As Integer
    Dim cmd%, temp_pres%, temp_l_value%, testtemp%
    Dim valve_moving_direction%, T As Single
    Dim temp_x4 As Long, Temp_X5 As Single
    
    'Lift chamber up for diagnostics
    If gpps2("Capstuff", "sequential_testing_enabled", CSFile$, "N") = "Y" Then
    '    Move_Valve SecondPiston, "C"
    End If
    Rem readings_counter only gets incremented when a reading shows up on the display
    Rem internal readings for fail-safe routines don't count.
    readings_counter = 0
    If newreg Then
        Rem this doesn't mean that the regulator is really running - it is just set to true
        Rem to force the reading of the regulator position at least once.
        Rem Whenever the regulator position is updated, it may turn off the
        Rem regulator_running flag if the regulator motor has actually stopped.
        regulator_running = True
    End If
    If autocompress Then
        compression_regulator_running = True
        Rem see above - same reasons
    End If
    manrunning = True
    Rem index into what we should read next.  If negative, we should read the
    Rem motorized valve position next and then make it positive
    auto_index% = 1
    Rem mode for auto scanning.  If 1, commands are disabled since the motor is running
    auto_mode% = 0
    While Not want_to_quit_manual_control
        Rem first check the low pressure gauge just in case
        Rem only do this if there is no 3-way valve
        Rem Systems with 3-way valves will have internal fail-safe procedures
        Rem and we can check the low pressure gauge less often
        Rem also, if we are about to read the low pressure
        Rem gauge anyway, don't bother with doing it here.
        'Debug.Print "At top of manual control"
        If ExtraPG And (Not way3) And (auto_index% <> 3) Then
            x4 = raw_reading(13)
            'Debug.Print "Goto fail_safe_test from ExtraPG And (Not way3) And (auto_index% <> 3)"
            GoSub fail_safe_test_with_x4_already_read
        End If
        Rem check the differential pressure gauge just in case
        Rem only do this if valve 14 is closed
        Rem and if we are about to read the gauge
        Rem anyway, don't bother with doing it here.
        Rem also, for hardware version 7 we don't need to do this since it
        Rem updates the readings fast enough for this extra reading to not be necessary
        If Vpos(14) = 0 And DiffPG And (auto_index% <> 5) And version < 7 Then
            x4 = raw_reading(13 + dpgplus%)
            If x4 >= DAC_over Then
                Move_Valve 13, "O"
                If hasMultipleMVs Then
                    'Valve 14 doesn't exist yet on this form
                    'ManualControl1.show_valve_open 14
                Else
                    ManualControl.show_valve_open 14
                End If
            End If
        End If
        'case for Tom's simple temp probes.
        If tempProbe Then
        Dim raw&, cValue&
            raw& = RSEcho("R" + Chr$(65 + tempProbeChannel), ver2or3)
            'cValue& = (raw& - tempProbeMinC) * tempProbeMaxV / tempProbeMaxC
            cValue& = tempProbeMinV + (((tempProbeMaxV - tempProbeMinV) / tempProbeMaxC) * (raw& - tempProbeMinC))
            
            ManualControl.templabel.Caption = "Cts: " + str$(raw&) + " Temp: " + str$(cValue&) + tempProbeLabel
        End If
        
        ' Read the Athenas
        If UseAthena1 Then
            ManualControl.athena_1_read.Caption = CStr(Read_Athena(Athena1Channel)) + " " + Athena1Units
        End If
        If UseAthena2 Then
            ManualControl.athena_2_read.Caption = CStr(Read_Athena(Athena2Channel)) + " " + Athena2Units
        End If
        
        Rem check the high pressure gauge just in case
        Rem only do this if valve 9 is open
        Rem and if we are about to read the high range of the high pressure
        Rem gauge anyway, don't bother with doing it here.
        Rem also, for hardware version 7 we don't need to do this since it
        Rem updates the readings fast enough for this extra reading to not be necessary
        If H2OPERM And (auto_index% <> 3) And Vpos(9) = 1 And version < 7 Then
            Rem make sure we are reading the highest range
            Rem remember the current range
            temp_pres% = Pres%
            Pres% = 0
            ReadXReturnX4 2
            Pres% = temp_pres%
            If x5 > 214 Then
                Move_Valve 8, "C"
                If hasMultipleMVs Then
                    ManualControl1.show_valve_closed 9
                Else
                    ManualControl.show_valve_closed 9
                End If
                DoEvents
            End If
        End If
        Rem scan next value
        
        If auto_index% < 0 Then
            If useBubblerMV Then
                ReadXReturnX4 32 'read close limit
                bubblerMV_CLIMIT = x4
                ReadXReturnX4 33 'read open limit
                bubblerMV_OLIMIT = x4
                ReadXReturnX4 31 'read position
                
                If bubblerMV_CLIMIT = bubblerMV_OLIMIT Then
                    x5 = 0.5
                Else
                    x5 = (x4 - bubblerMV_CLIMIT) / (bubblerMV_OLIMIT - bubblerMV_CLIMIT)
                End If
                            
                If x5 >= 1 Then
                    x5 = 1
                    If valve_moving_direction% = 0 Then
                        command_issued%(41) = 1
                    End If
                ElseIf x5 <= 0 Then
                    x5 = 0
                    If valve_moving_direction% = 1 Then
                        command_issued%(41) = 1
                    End If
                End If
                    
                If hasMultipleMVs Then
                    'ManualControl1.updateBubblerMVPicture
                    'ManualControl1.lblBubblerMVPosition.Caption = Xformat$(x4, "####0") + " " + ts$(231) + "   " + Format$(x5, "##0.00%") + " " + ts$(232)
                Else
                    ManualControl.updateBubblerMVPicture
                    ManualControl.lblBubblerMVPosition.Caption = Xformat$(x4, "####0") + " " + ts$(231) + "   " + Format$(x5, "##0.00%") + " " + ts$(232)
                End If
                readings_counter = readings_counter + 1
                auto_index% = -auto_index%
            Else
                If hasMultipleMVs Then
                    If motorValveIndex = 0 Then
                        Rem read valve position value since valve is running
                        ReadXReturnX4 3
                        If oLimit = cLimit Then
                            x5 = 0.5
                        Else
                            x5 = (x4 - cLimit) / (oLimit - cLimit)
                        End If
                        If x5 >= 1 Then
                            x5 = 1
                            If valve_moving_direction% = 0 Then
                                command_issued%(41) = 1
                            End If
                        ElseIf x5 <= 0 Then
                            x5 = 0
                            If valve_moving_direction% = 1 Then
                                command_issued%(41) = 1
                            End If
                        End If
                        valvePosLabel = ts$(520)
                    ElseIf motorValveIndex = 1 Then
                        Rem read valve position value since valve is running
                        ReadXReturnX4 3
                        If olimit2 = CLIMIT2 Then
                            x5 = 0.5
                        Else
                            x5 = (x4 - CLIMIT2) / (olimit2 - CLIMIT2)
                        End If
                        If x5 >= 1 Then
                            x5 = 1
                            If valve_moving_direction% = 0 Then
                                command_issued%(41) = 1
                            End If
                        ElseIf x5 <= 0 Then
                            x5 = 0
                            If valve_moving_direction% = 1 Then
                                command_issued%(41) = 1
                            End If
                        End If
                        valvePosLabel = ts$(521)
                    ElseIf motorValveIndex = 2 Then
                        ReadXReturnX4 3
                        If olimit3 = CLIMIT3 Then
                            x5 = 0.5
                        Else
                            x5 = (x4 - CLIMIT3) / (olimit3 - CLIMIT3)
                        End If
                        If x5 >= 1 Then
                            x5 = 1
                            If valve_moving_direction% = 0 Then
                                command_issued%(41) = 1
                            End If
                        ElseIf x5 <= 0 Then
                            x5 = 0
                            If valve_moving_direction% = 1 Then
                                command_issued%(41) = 1
                            End If
                        End If
                        valvePosLabel = ts$(522)
                    End If
                Else
                    Rem read valve position value since valve is running
                    ReadXReturnX4 3
                    If oLimit = cLimit Then
                        x5 = 0.5
                    Else
                        x5 = (x4 - cLimit) / (oLimit - cLimit)
                    End If
                    If x5 >= 1 Then
                        x5 = 1
                        If valve_moving_direction% = 0 Then
                            command_issued%(41) = 1
                        End If
                    ElseIf x5 <= 0 Then
                        x5 = 0
                        If valve_moving_direction% = 1 Then
                            command_issued%(41) = 1
                        End If
                    End If
                End If
                GoSub update_v2_picture
                If hasMultipleMVs Then
                    ManualControl1.Valve_Pos(2).Caption = valvePosLabel + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Format$(x5, "##0.00%") + " " + ts$(232) ' "Valve 2"/"Counts"/"Open"
                Else
                    ManualControl.Valve_Pos(2).Caption = ts$(230) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Format$(x5, "##0.00%") + " " + ts$(232) ' "Valve 2"/"Counts"/"Open"
                End If
                readings_counter = readings_counter + 1
                v2 = x4
                auto_index% = -auto_index%
            End If
        Else
            Select Case auto_index%
              Case 1:
                ' read low flow meter
                ReadXReturnX4 0
                readings_counter = readings_counter + 1
                If lflow% = 0 Then
                    If hasMultipleMVs Then
                        'ManualControl1.lowflow.Caption = ts$(307) + " " + ts$(305) + "    (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "#####0.000 \c\c") ' "Low Flow Rate (High)"/"Counts"/"\c\c"
                    Else
                        ManualControl.lowflow.Caption = ts$(307) + " " + ts$(305) + "    (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "#####0.000 \c\c") ' "Low Flow Rate (High)"/"Counts"/"\c\c"
                    End If
                Else
                    If integrity Then
                        If hasMultipleMVs Then
                            'ManualControl1.lowflow.Caption = ts$(306) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "######.000 \c\c")   ' "Integrity Flow Rate"/"Counts"/"\c\c"
                        Else
                            ManualControl.lowflow.Caption = ts$(306) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "######.000 \c\c")   ' "Integrity Flow Rate"/"Counts"/"\c\c"
                        End If
                    Else
                        If hasMultipleMVs Then
                            'ManualControl1.lowflow.Caption = ts$(307) + " " + ts$(305) + "    (" + ts$(307) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "######.000 \c\c") ' "Low Flow Rate (Low )"/"Counts"/"\c\c"
                        Else
                            ManualControl.lowflow.Caption = ts$(307) + " " + ts$(305) + "    (" + ts$(307) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "######.000 \c\c") ' "Low Flow Rate (Low )"/"Counts"/"\c\c"
                        End If
                    End If
                End If
              Case 2:
                ' read high flow meter
                ReadXReturnX4 1
                readings_counter = readings_counter + 1
                If Not xhflow Then
                    If HFLOW% = 0 Then
                        If hasMultipleMVs Then
                            'ManualControl1.highflow.Caption = ts$(308) + " " + ts$(305) + "    (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "######.000 \c\c")   ' "High Flow Rate (High): "/"Counts"/"\c\c"
                        Else
                            ManualControl.highflow.Caption = ts$(308) + " " + ts$(305) + "    (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "######.000 \c\c")   ' "High Flow Rate (High): "/"Counts"/"\c\c"
                        End If
                    Else
                        If hasMultipleMVs Then
                            'ManualControl1.highflow.Caption = ts$(308) + " " + ts$(305) + "    (" + ts$(307) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "######.000 \c\c")   ' "High Flow Rate (Low ):/"Counts"/"\c\c"
                        Else
                            ManualControl.highflow.Caption = ts$(308) + " " + ts$(305) + "    (" + ts$(307) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "######.000 \c\c")   ' "High Flow Rate (Low ):/"Counts"/"\c\c"
                        End If
                    End If
                Else
                    If xhflow_meters = 1 Then
                        If HFLOW% = 0 Then
                            ManualControl.highflow.Caption = ts$(308) + " " + ts$(305) + " (" + ts$(308) + "-1): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + FormatNumber(x5, 3, , , vbTrue) + " CCM"    ' "High Flow Rate (Hi-1):/"Counts"/"\c\c"
                        ElseIf HFLOW% = 1 Then
                            ManualControl.highflow.Caption = ts$(308) + " " + ts$(305) + " (" + ts$(307) + "-1): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + FormatNumber(x5, 3, , , vbTrue) + " CCM"   ' "High Flow Rate (Lo-1): "/"Counts"/"\c\c"
                        ElseIf HFLOW% = 2 Then
                            ManualControl.highflow.Caption = ts$(308) + " " + ts$(305) + " (" + ts$(308) + "-2): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + FormatNumber(x5, 3, , , vbTrue) + " CCM"   ' "High Flow Rate (Hi-2): "/"Counts"/"\c\c"
                        Else
                            ManualControl.highflow.Caption = ts$(308) + " " + ts$(305) + " (" + ts$(307) + "-2): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + FormatNumber(x5, 3, , , vbTrue) + " CCM"    ' "High Flow Rate (Lo-2): "/"Counts"/"\c\c"
                        End If
                    ElseIf xhflow_meters = 2 Then
                        If HFLOW% = 0 Then
                            ManualControl.highflow.Caption = ts$(308) + " " + ts$(305) + " (" + ts$(308) + "-1): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + FormatNumber(x5, 3, , , vbTrue) + " CCM"    ' "High Flow Rate (Hi-1):/"Counts"/"\c\c"
                        ElseIf HFLOW% = 1 Then
                            ManualControl.highflow.Caption = ts$(308) + " " + ts$(305) + " (" + ts$(307) + "-1): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + FormatNumber(x5, 3, , , vbTrue) + " CCM"   ' "High Flow Rate (Lo-1): "/"Counts"/"\c\c"
                        ElseIf HFLOW% = 2 Then
                            ManualControl.highflow.Caption = ts$(308) + " " + ts$(305) + " (" + ts$(308) + "-2): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + FormatNumber(x5, 3, , , vbTrue) + " CCM"   ' "High Flow Rate (Hi-2): "/"Counts"/"\c\c"
                        ElseIf HFLOW% = 3 Then
                            ManualControl.highflow.Caption = ts$(308) + " " + ts$(305) + " (" + ts$(307) + "-2): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + FormatNumber(x5, 3, , , vbTrue) + " CCM"    ' "High Flow Rate (Lo-2): "/"Counts"/"\c\c"
                        ElseIf HFLOW% = 4 Then
                            ManualControl.highflow.Caption = ts$(308) + " " + ts$(305) + " (" + ts$(308) + "-3): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + FormatNumber(x5, 3, , , vbTrue) + " CCM"    ' "High Flow Rate (Hi-3):/"Counts"/"\c\c"
                        ElseIf HFLOW% = 5 Then
                            ManualControl.highflow.Caption = ts$(308) + " " + ts$(305) + " (" + ts$(307) + "-3): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + FormatNumber(x5, 3, , , vbTrue) + " CCM"   ' "High Flow Rate (Lo-3): "/"Counts"/"\c\c"
                        Else
                            ManualControl.highflow.Caption = ts$(308) + " " + ts$(305) + " (ERROR): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + FormatNumber(x5, 3, , , vbTrue) + " CCM"   ' ERROR
                        End If
                    End If
                End If
              Case 3:
                'added 02/09/16:--------------------------------------------------------------
'                If firstTime = 1 Then
'                    tempPres% = Pres%
'                    do_command 16 'open valve to low pressure gaue
'                    Dialog.Show
'                    Sleep 1000 ' to sleep for 1 second for valve to low pressure gauge to open
'                    'Dialog.Hide
'
'                    testInt = testInt + 1
'
'                    WPPS "TEST", "MYVALUES-PY1(2)" + str$(testInt), str$(PY1(2)), CSFile$
'                    WPPS "TEST", "MYVALUES-PY2(2)" + str$(testInt), str$(PY2(2)), CSFile$
'                    WPPS "TEST", "MYVALUES-PY1(3)" + str$(testInt), str$(PY1(3)), CSFile$
'                    WPPS "TEST", "MYVALUES-PY2(3)" + str$(testInt), str$(PY2(3)), CSFile$
'
'                    Pres% = 0 ' hi range hi pressure gauge.
'                    ReadXReturnX4 2
'                    hhp = Xformat$(x5 * PCNV, "#####.000")
'                    WPPS "TEST", "MYVALUES-hhp" + str$(testInt) + "-------", hhp, CSFile$
'                    hhpVal = val(hhp)
'
'                    Pres% = 2 ' hi range low pressure gauge.
'                    ReadXReturnX4 2
'                    hlp = Xformat$(x5 * PCNV, "#####.000")
'                    WPPS "TEST", "MYVALUES-hlp" + str$(testInt) + "-------", hlp, CSFile$
'                    hlpVal = val(hlp)
'
'
'
'                    While (hhpVal < (hlpVal - 0.001)) Or (hhpVal > (hlpVal + 0.001))
'                        Dialog.Show
'                        'MsgBox "hhpVal " + str$(hhpVal) + " hlpVal " + str$(hlpVal)
'
'                        testInt = testInt + 1
'
'                        WPPS "TEST", "MYVALUES-PY1(2)" + str$(testInt), str$(PY1(2)), CSFile$
'                        WPPS "TEST", "MYVALUES-PY2(2)" + str$(testInt), str$(PY2(2)), CSFile$
'                        WPPS "TEST", "MYVALUES-PY1(3)" + str$(testInt), str$(PY1(3)), CSFile$
'                        WPPS "TEST", "MYVALUES-PY2(3)" + str$(testInt), str$(PY2(3)), CSFile$
'
'                        Pres% = 0 ' hi range hi pressure gauge.
'                        ReadXReturnX4 2
'                        hhp = Xformat$(x5 * PCNV, "#####.000")
'                        WPPS "TEST", "MYVALUES-hhp" + str$(testInt) + "-------", hhp, CSFile$
'                        hhpVal = val(hhp)
'
'                        Pres% = 2 ' hi range low pressure gauge.
'                        ReadXReturnX4 2
'                        hlp = Xformat$(x5 * PCNV, "#####.000")
'                        WPPS "TEST", "MYVALUES-hlp" + str$(testInt) + "-------", hlp, CSFile$
'                        hlpVal = val(hlp)
'
'
'                         If hhpVal > hlpVal Then
'                         'MsgBox "hhpVal " + str$(hhpVal) + " is bigger than hlpVal " + str$(hlpVal) + ", so increase low pressure values by .001"
'                         PY1(2) = PY1(2) + 0.001
'                         PY2(2) = PY2(2) + 0.001
'                         PY1(3) = PY1(3) + 0.001
'                         PY2(3) = PY2(3) + 0.001
'
'                         Else
'                         'MsgBox "hhpVal " + str$(hhpVal) + " is lower than hlpVal " + str$(hlpVal) + ", so decrease low pressure values by .001"
'                         PY1(2) = PY1(2) - 0.001
'                         PY2(2) = PY2(2) - 0.001
'                         PY1(3) = PY1(3) - 0.001
'                         PY2(3) = PY2(3) - 0.001
'                        End If
'
'                        'Ret = gpps2("Capstuff", "JulianTEST", CSFile$, "0")
'                        WPPS "Capstuff", "PY1_2", PY1(2), CSFile$
'                        WPPS "Capstuff", "PY2_2", PY2(2), CSFile$
'                        WPPS "Capstuff", "PY1_3", PY1(3), CSFile$
'                        WPPS "Capstuff", "PY2_3", PY2(3), CSFile$
'
'
'
'                    Wend
'                    do_command 15 'close valve to low pressure gaue
'                    Dialog.Hide
'                    firstTime = 0
'                    Pres% = tempPres%
'                End If
                
                
                '--------------------------------------------------------------
                
                
                
                ' read pressure gauge
                ReadXReturnX4 2
                             
                
                
                readings_counter = readings_counter + 1
                If H2OPERM And Vpos(9) = 1 Then
                    ' remember the original x5 and x4 values in case we re-read them here
                    temp_x4 = x4
                    Temp_X5 = x5
                    Rem if we are off scale, we need to read the higher range
                    If x4 >= DAC_over And Pres% <> 0 Then
                        temp_pres% = Pres%
                        Pres% = 0
                        ReadXReturnX4 2
                    End If
                    If x5 > 214 Then
                        Move_Valve 8, "C"
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_closed 9
                        Else
                            ManualControl.show_valve_closed 9
                        End If
                        DoEvents
                    End If
                    x4 = temp_x4
                    x5 = Temp_X5
                End If
                Rem now for a possible fail-safe test for the low pressure gauge
                ' only need this if there is a low pressure gauge, and there
                ' isn't a 3-way valve or the valve is open
                ' we also don't need this if it is turned off
                If ExtraPG And ((Not way3) Or Vpos(11) = 1) And Not NoFailSafe Then
                    ' if we are in the low range and still in range, then we don't
                    ' need this test since we can't possibly be over
                    'Debug.Print "Into ExtraPG And ((Not way3) Or Vpos(11) = 1) And Not NoFailSafe"
                    If Pres% <> 3 Or x4 >= DAC_over Then
                        temp_x4 = x4
                        If Pres% <> 2 Then
                            ' we only need to read the counts if we didn't just do so
                            x4 = raw_reading(13)
                        End If
                        GoSub fail_safe_test_with_x4_already_read
                        x4 = temp_x4
                    End If
                End If
                
                
                
                
                
                
                ''WPPS "TEST", "MYVALUES" + str$(testInt), ts$(308) + " " + ts$(229) + " (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$, CSFile$
                
                ''ManualControl.Press_Read.Caption = ts$(308) + " " + ts$(229) + " (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "High Pressure (High): "/"counts"
                ''ManualControl.Press_Read.Caption = ts$(307) + " " + ts$(229) + " (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "Low Pressure (High): "/"counts"
                If Not ExtraPG Then
                   
                    If Pres% = 0 Then
                        If hasMultipleMVs Then
                            ManualControl1.Press_Read.Caption = ts$(229) + " (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "Pressure (High): "/"counts"
                        Else
                            ManualControl.Press_Read.Caption = ts$(229) + " (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "Pressure (High): "/"counts"
                    End If
                    Else
                        If hasMultipleMVs Then
                            ManualControl1.Press_Read.Caption = ts$(229) + " (" + ts$(307) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "Pressure (Low ): "/"counts"
                        Else
                            ManualControl.Press_Read.Caption = ts$(229) + " (" + ts$(307) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "Pressure (Low ): "/"counts"
                        End If
                        
                    End If
                Else
                    If Pres% = 0 Then
                        If hasMultipleMVs Then
                            ManualControl1.Press_Read.Caption = ts$(308) + " " + ts$(229) + " (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "High Pressure (High): "/"counts"
                        Else
                            ManualControl.Press_Read.Caption = ts$(308) + " " + ts$(229) + " (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "High Pressure (High): "/"counts"
                            'added code -------------------------------------:
                            'WPPS "TEST", "MYVALUES-High" + str$(testInt), Xformat$(x5 * PCNV, "#####.000"), CSFile$
                        End If
                    ElseIf Pres% = 1 Then
                        If hasMultipleMVs Then
                            ManualControl1.Press_Read.Caption = ts$(308) + " " + ts$(229) + " (" + ts$(307) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "High Pressure (Low): "/"counts"
                        Else
                            ManualControl.Press_Read.Caption = ts$(308) + " " + ts$(229) + " (" + ts$(307) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "High Pressure (Low): "/"counts"
                        End If
                    ElseIf Pres% = 2 Then
                        If hasMultipleMVs Then
                            ManualControl1.Press_Read.Caption = ts$(307) + " " + ts$(229) + " (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "Low Pressure (High): "/"counts"
                        Else
                            ManualControl.Press_Read.Caption = ts$(307) + " " + ts$(229) + " (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "Low Pressure (High): "/"counts"
                            'added code -------------------------------------:
                            'WPPS "TEST", "MYVALUES-Low" + str$(testInt), Xformat$(x5 * PCNV, "#####.000"), CSFile$
                        End If
                    Else
                        If hasMultipleMVs Then
                            ManualControl1.Press_Read.Caption = ts$(307) + " " + ts$(229) + " (" + ts$(307) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "Low Pressure (Low): "/"counts"
                        Else
                            ManualControl.Press_Read.Caption = ts$(307) + " " + ts$(229) + " (" + ts$(307) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "Low Pressure (Low): "/"counts"
                        End If
                    End If
                End If
                
                If hasMultipleMVs Then
                    If x4 < val(ManualControl1.pdebug(0).Caption) Or Len(ManualControl1.pdebug(0).Caption) = 0 Then
                        ManualControl1.pdebug(0).Caption = str$(x4)
                    End If
                    If x4 > val(ManualControl1.pdebug(1).Caption) Or Len(ManualControl1.pdebug(1).Caption) = 0 Then
                        ManualControl1.pdebug(1).Caption = str$(x4)
                    End If
                Else
                    If x4 < val(ManualControl.pdebug(0).Caption) Or Len(ManualControl.pdebug(0).Caption) = 0 Then
                        ManualControl.pdebug(0).Caption = str$(x4)
                    End If
                    If x4 > val(ManualControl.pdebug(1).Caption) Or Len(ManualControl.pdebug(1).Caption) = 0 Then
                        ManualControl.pdebug(1).Caption = str$(x4)
                    End If
                End If
                ' check the min and max for the pdebug label
                Rem also read the readat thing if enabled.
                Rem we do this here since you will always be reading the pressure
                Rem gauge, and it is possible that other stuff may be skipped on
                Rem other machines.  (There are no machines that don't have a
                Rem pressure gague!)
                
                If hasMultipleMVs Then
                    'If ManualControl1.readatcheck.value = 1 Then
                    '    ManualControl1.readatlabel.Caption = Hex$(RSEcho("R@", ver1or2))
                    'End If
                Else
                    If ManualControl.readatcheck.value = 1 Then
                        ManualControl.readatlabel.Caption = Hex$(RSEcho("R@", ver1or2))
                    End If
                End If
              Case 4:
                ' read valve 2 position
                If hasHumidityControls And useBubblerMV Then
                    ReadXReturnX4 32 'read close limit
                    readings_counter = readings_counter + 1
                    bubblerMV_CLIMIT = x4
                    ReadXReturnX4 33 'read open limit
                    readings_counter = readings_counter + 1
                    bubblerMV_OLIMIT = x4
                    ReadXReturnX4 31 'read position
                    readings_counter = readings_counter + 1
                    
                    If bubblerMV_CLIMIT = bubblerMV_OLIMIT Then
                        x5 = 0.5
                    Else
                        x5 = (x4 - bubblerMV_CLIMIT) / (bubblerMV_OLIMIT - bubblerMV_CLIMIT)
                    End If
                                        
                    If x5 > 1 Then x5 = 1
                    If x5 < 0 Then x5 = 0
                                    
                    If hasMultipleMVs Then
                        'ManualControl1.lblBubblerMVPosition.Caption = Xformat$(x4, "####0") + " " + ts$(231) + "   " + Format$(x5, "##0.00%") + " " + ts$(232)
                        'ManualControl1.updateBubblerMVPicture
                    Else
                        ManualControl.lblBubblerMVPosition.Caption = Xformat$(x4, "####0") + " " + ts$(231) + "   " + Format$(x5, "##0.00%") + " " + ts$(232)
                        ManualControl.updateBubblerMVPicture
                    End If
                ElseIf Not hasMultipleMVs Then
                    ReadXReturnX4 3
                    readings_counter = readings_counter + 1
                    If oLimit = cLimit Then
                        x5 = 0.5
                    Else
                        x5 = (x4 - cLimit) / (oLimit - cLimit)
                    End If
                    If x5 > 1 Then x5 = 1
                    If x5 < 0 Then x5 = 0
                    ManualControl.Valve_Pos(2).Caption = ts$(230) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Format$(x5, "##0.00%") + " " + ts$(232) ' "Valve 2"/"Counts"/"Open"
                    v2 = x4
                    GoSub update_v2_picture
                ElseIf hasMultipleMVs Then
                    If motorValveIndex = 0 Then
                        ReadXReturnX4 3
                        'Debug.Print " update mv1 pos"
                        readings_counter = readings_counter + 1
                        If oLimit = cLimit Then
                            x5 = 0.5
                        Else
                            x5 = (x4 - cLimit) / (oLimit - cLimit)
                        End If
                        If x5 > 1 Then x5 = 1
                        If x5 < 0 Then x5 = 0
                        ManualControl1.Valve_Pos(2).Caption = ts$(520) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Format$(x5, "##0.00%") + " " + ts$(232) ' "Valve 2"/"Counts"/"Open"
                        v2 = x4
                        GoSub update_v2_picture
                    ElseIf motorValveIndex = 1 Then
                        'Debug.Print " update mv2 pos"
                        ReadXReturnX4 3
                        readings_counter = readings_counter + 1
                        If olimit2 = CLIMIT2 Then
                            x5 = 0.5
                        Else
                            x5 = (x4 - CLIMIT2) / (olimit2 - CLIMIT2)
                        End If
                        ManualControl1.Valve_Pos(2).Caption = ts$(521) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Format$(x5, "##0.00%") + " " + ts$(232) ' "Valve 2"/"Counts"/"Open"
                        v2 = x4
                        GoSub update_v2_picture
                    ElseIf motorValveIndex = 2 Then
                        ReadXReturnX4 3
                        readings_counter = readings_counter + 1
                        If olimit3 = CLIMIT3 Then
                            x5 = 0.5
                        Else
                            x5 = (x4 - CLIMIT3) / (olimit3 - CLIMIT3)
                        End If
                        ManualControl1.Valve_Pos(2).Caption = ts$(522) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Format$(x5, "##0.00%") + " " + ts$(232)
                        v2 = x4
                        GoSub update_v2_picture
                    End If
                End If
              Case 5:
                If H2OPERM Or hydrohead Then
                    ReadXReturnX4 4
                    readings_counter = readings_counter + 1
                    
    '                last_penetrometer_reading = x5 directly follows inserted code
    ' **********
    ' BEGIN ReadBalanceNotPenet code inserted by search for Tim Richards on Thursday 6/3/04
    ' change ManualControl.Penetro.Caption = ts$(309) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "####.000") + " " + ts$(310)  ' "Penetrometer"/"Counts"/"cm of H2O"
    ' 040715 Thurs 11AM TAR ---added .0000 (one more precision) to the balance readout
    '
                    If g_bBalanceNotPenet = True Then
                        If hasMultipleMVs Then
                            ManualControl1.Penetro.Caption = ts$(481) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "####.0000") + " " + ts$(480)  ' "Mettler Balance"/"Counts"/"gm of H2O"
                        Else
                            ManualControl.Penetro.Caption = ts$(481) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "####.0000") + " " + ts$(480)  ' "Mettler Balance"/"Counts"/"gm of H2O"
                        End If
                    Else
                        If hasMultipleMVs Then
                            ManualControl1.Penetro.Caption = ts$(309) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "####.000") + " " + ts$(310)  ' "Penetrometer"/"Counts"/"cm of H2O"
                        Else
                            ManualControl.Penetro.Caption = ts$(309) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "####.000") + " " + ts$(310)  ' "Penetrometer"/"Counts"/"cm of H2O"
                        End If
                    End If
    '
    ' END inserted code by Tim Richards 6/3/04
    ' **********
    
                    last_penetrometer_reading = x5
                End If
                If DiffPG Then
                    readings_counter = readings_counter + 1
                    If DPress% = 0 Then
                        ReadXReturnX4 13 + dpgplus%
                        If x4 >= DAC_over And Vpos(14) = 0 Then
                            Move_Valve 13, "O"
                            If hasMultipleMVs Then
                                'Valve 14 doesn't exist yet
                                'ManualControl1.show_valve_open 14
                            Else
                                ManualControl.show_valve_open 14
                            End If
                        End If
                        If H2OPERM Or hydrohead Then
                            If dryChamberTemperature <> 0 Or wetChamberTemperature <> 0 Or reservoirTemperature <> 0 Then
                                ManualControl.piston_position_transducer.Caption = ts$(311) + " (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$   ' "Diff. Press. (High): "/"counts"
                            Else
                                If manual_aux_click = 0 Then manual_aux_click = 2 ' if undefined, claim it for microflow
                                If manual_aux_click = 2 Then ' allow microflow readings
                                    If hasMultipleMVs Then
                                        ManualControl1.Auxreading.Caption = ts$(311) + " (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$   ' "Diff. Press. (High): "/"counts"
                                    Else
                                        ManualControl.Auxreading.Caption = ts$(311) + " (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$   ' "Diff. Press. (High): "/"counts"
                                    End If
                                End If
                            End If
                        Else
                            If hasMultipleMVs Then
                                ManualControl1.Penetro.Caption = ts$(311) + " (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$                 ' "Diff. Press. (High): "/"counts"
                            Else
                                ManualControl.Penetro.Caption = ts$(311) + " (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$                 ' "Diff. Press. (High): "/"counts"
                            End If
                        End If
                    Else
                        ReadXReturnX4 12 + dpgplus%
                        If x4 >= DAC_over And Vpos(14) = 0 Then
                            ' low range is over - read high range just to be safe
                            temp_x4 = x4
                            x4 = raw_reading(13 + dpgplus%)
                            If x4 >= DAC_over Then
                                Move_Valve 13, "O"
                                If hasMultipleMVs Then
                                    'Valve 14 Doesn't exist yet
                                    'ManualControl1.show_valve_open 14
                                Else
                                    ManualControl.show_valve_open 14
                                End If
                            End If
                        End If
                        If H2OPERM Or hydrohead Then
                            If manual_aux_click = 0 Then manual_aux_click = 2 ' if undefined, claim it for microflow
                            If manual_aux_click = 2 Then ' allow microflow readings
                                If hasMultipleMVs Then
                                    ManualControl1.Auxreading.Caption = ts$(311) + " (" + ts$(307) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$  ' "Diff. Press. (Low ): "/"counts"
                                Else
                                    ManualControl.Auxreading.Caption = ts$(311) + " (" + ts$(307) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$  ' "Diff. Press. (Low ): "/"counts"
                                End If
                          End If
                        Else
                            If hasMultipleMVs Then
                                ManualControl1.Penetro.Caption = ts$(311) + " (" + ts$(307) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$     ' "Diff. Press. (Low ): "/"counts"
                            Else
                                ManualControl.Penetro.Caption = ts$(311) + " (" + ts$(307) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$     ' "Diff. Press. (Low ): "/"counts"
                            End If
                        End If
                    End If
                End If
              Case 6: ' only for version 6 and if regulator_running = true
                update_regulator_display
                readings_counter = readings_counter + 1
              Case 7: ' only for auxin (or temperature probes)
                If fluidsensor Then
                  ReadXReturnX4 27
                  If hasMultipleMVs Then
                      ManualControl1.Auxreading.Caption = ts$(312) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + Xformat$(x5, "#####.000") + " " + fsunit$  ' "Fluid Sensor"/"counts"
                  Else
                      ManualControl.Auxreading.Caption = ts$(312) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + Xformat$(x5, "#####.000") + " " + fsunit$  ' "Fluid Sensor"/"counts"
                  End If
                  readings_counter = readings_counter + 1
                ElseIf dryChamberTemperature <> 0 Or wetChamberTemperature <> 0 Or reservoirTemperature <> 0 Then
                  If manual_aux_click = 0 Then manual_aux_click = 1 ' if undefined, claim it for temperature
                  If manual_aux_click = 1 Then ' allow temperature readings
                    x4 = 0 ' set default in case of non-count value temperature input
                    If hasMultipleMVs Then
                        'If ManualControl1.Combo1.Tag = "D" Then
                        '    x5 = readNewTemperature(dryChamberTemperature, False)
                        'ElseIf ManualControl1.Combo1.Tag = "W" Then
                        '    x5 = readNewTemperature(wetChamberTemperature, False)
                        'ElseIf ManualControl1.Combo1.Tag = "A" Then
                        '    x5 = readNewTemperature(airTemperature, False)
                        'ElseIf ManualControl1.Combo1.Tag = "B" Then
                        '    x5 = readNewTemperature(bubblerTemperature, False)
                        'ElseIf ManualControl1.Combo1.Tag = "C" Then
                        '    x5 = readNewTemperature(cabinetTemperature, False)
                        'Else ' defaults to reservoir
                        '    x5 = readNewTemperature(reservoirTemperature, False)
                        'End If
                        'ManualControl1.Auxreading.Caption = ts$(313) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + Xformat$(x5, "#####.000") + " " + tsunit$ ' + " " + Str$(door_status)       ' "Temperature"/"counts"
                    Else
                        If ManualControl.Combo1.Tag = "D" Then
                            x5 = readNewTemperature(dryChamberTemperature, False)
                        ElseIf ManualControl.Combo1.Tag = "W" Then
                            x5 = readNewTemperature(wetChamberTemperature, False)
                        ElseIf ManualControl.Combo1.Tag = "A" Then
                            x5 = readNewTemperature(airTemperature, False)
                        ElseIf ManualControl.Combo1.Tag = "B" Then
                            x5 = readNewTemperature(bubblerTemperature, False)
                        ElseIf ManualControl.Combo1.Tag = "C" Then
                            x5 = readNewTemperature(cabinetTemperature, False)
                        ElseIf ManualControl.Combo1.Tag = "H" Then
                            x5 = readNewTemperature(hydroHeadTemperature, False)
                        ElseIf ManualControl.Combo1.Tag = "M" Then
                            x5 = readNewTemperature(mullenTemperature, False)
                        Else ' defaults to reservoir
                            x5 = readNewTemperature(reservoirTemperature, False)
                        End If
                        ManualControl.Auxreading.Caption = ts$(313) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + Xformat$(x5, "#####.000") + " " + tsunit$ ' + " " + Str$(door_status)       ' "Temperature"/"counts"
                    End If
                    readings_counter = readings_counter + 1
                  End If
                ElseIf Not Second_Penetrometer Then
                  If hasMultipleMVs Then
                      ManualControl1.Auxreading.Caption = ts$(314) + ": " + Xformat$(raw_reading(27), "####0") + " " + ts$(231)    ' "Auxillary Input"/"Counts"
                  Else
                      ManualControl.Auxreading.Caption = ts$(314) + ": " + Xformat$(raw_reading(27), "####0") + " " + ts$(231)    ' "Auxillary Input"/"Counts"
                  End If
                  readings_counter = readings_counter + 1
                End If
              Case 8: ' only for autocompress and if compression regulator is running
                update_compression_regulator_display
                readings_counter = readings_counter + 1
              Case 9: ' only for autocompress
                If manual_aux_click = 0 Then manual_aux_click = 3 ' if undefined, claim it for compression readings
                If manual_aux_click = 3 Then ' allow compression pressure readings
                  If CPress% = 0 Then
                    ReadXReturnX4 35
                    If hasMultipleMVs Then
                        ManualControl1.Auxreading.Caption = ts$(131) + " (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "Comp. Press. (High): "/"counts"
                    Else
                        ManualControl.Auxreading.Caption = ts$(131) + " (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "Comp. Press. (High): "/"counts"
                    End If
                    readings_counter = readings_counter + 1
                  Else
                    ReadXReturnX4 34
                    If hasMultipleMVs Then
                        ManualControl1.Auxreading.Caption = ts$(131) + " (" + ts$(307) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "Comp. Press. (low): "/"counts"
                    Else
                        ManualControl.Auxreading.Caption = ts$(131) + " (" + ts$(307) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "Comp. Press. (low): "/"counts"
                    End If
                    readings_counter = readings_counter + 1
                  End If
                End If
              Case 10: ' only for bubbler level sensor or reservoir tank level sensor (or possibly both!)
                ' this has to be a really raw reading with no interpretation because it can be any channel
                ' that we are not currently using, and this could remap to a flow meter of pressure gauge channel
                If BubblerLevelChannel > 0 Then
                    x4 = RSEcho("R" + Chr$(Asc("A") + BubblerLevelChannel), ver2or3)
                    x5 = (x4 - BubblerLevelZero) * 100# / (bubblerLevelSpan - BubblerLevelZero)
                    If hasMultipleMVs Then
                        'ManualControl1.BubblerLabel.Caption = Format$(x5, "###0.0")
                    Else
                        ManualControl.BubblerLabel.Caption = Format$(x5, "###0.0")
                    End If
                End If
                
                If (ReserveTankLevelChannel >= 0) Or (ChamberLiquidLevelChannel(1) >= 0) Or (ChamberLiquidLevelChannel(2) >= 0) Then
                    If hasMultipleMVs Then
                        x5 = readReserveTankLevel
                        ManualControl1.lblReserveTankLevelValue.Caption = Format$(x5, "###0.0") & " %"
                    Else
                        If ManualControl.ReserveLevelCombo.Tag = "R" Then
                            x5 = readReserveTankLevel
                        ElseIf ManualControl.ReserveLevelCombo.Tag = "1" Then
                            x5 = readChamberLiquidLevel(1)
                        ElseIf ManualControl.ReserveLevelCombo.Tag = "2" Then
                            x5 = readChamberLiquidLevel(2)
                        End If
                        ManualControl.lblReserveTankLevelValue.Caption = Format$(x5, "###0.0") & " %"
                    End If
                End If
              Case 11: 'only for piston position transducer   '6.71.123.05
                    ReadXReturnX4 37
                    If hasMultipleMVs Then
                        ManualControl1.piston_position_transducer.Caption = ts$(498) + " (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 / thick_unit_conversion#, "#####.000") + " " + thick_unit_name$
                    Else
                        ManualControl.piston_position_transducer.Caption = ts$(498) + " (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 / thick_unit_conversion#, "#####.000") + " " + thick_unit_name$
                    End If
                    readings_counter = readings_counter + 1
              Case 12: 'only for slurry tube level   '6.71.123.05
                    ReadXReturnX4 39
                    If hasMultipleMVs Then
                        'ManualControl1.slurry_tube_level.Caption = ts$(501) + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5, "#####.000") + " " + ts$(310)
                    Else
                        ManualControl.slurry_tube_level.Caption = ts$(501) + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5, "#####.000") + " " + ts$(310)
                    End If
                    readings_counter = readings_counter + 1
              Case 13: 'only for slurry tube pressure   '6.71.123.05
                    ReadXReturnX4 41
                    If hasMultipleMVs Then
                        'ManualControl1.slurry_tube_pressure.Caption = ts$(502) + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$  ' "Slurry Tube Pressure (P6):"
                    Else
                        ManualControl.slurry_tube_pressure.Caption = ts$(502) + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$  ' "Slurry Tube Pressure (P6):"
                    End If
                    readings_counter = readings_counter + 1
              Case 14: 'only for slurry wash pump flow   '6.71.123.10
                    update_slurry_wash_pump_flow_display
                    readings_counter = readings_counter + 1
              Case 15:
                    ReadXReturnX4 29
                    If hasMultipleMVs Then
                        'ManualControl1.SamplePG1Label.Caption = "Sample Pressure #1: " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$
                    Else
                        ManualControl.SamplePG1Label.Caption = "Sample Pressure #1: " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$
                    End If
              Case 16:
                    ReadXReturnX4 35
                    If hasMultipleMVs Then
                        'ManualControl1.SamplePG2Label.Caption = "Sample Pressure #2: " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$
                    Else
                        ManualControl.SamplePG2Label.Caption = "Sample Pressure #2: " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$
                    End If
              Case 17:
                    ReadXReturnX4 tank_level_location
                    If hasMultipleMVs Then
                        'ManualControl1.tankLevelLabel.Caption = str$(CInt(x5)) + " %"
                    Else
                        ManualControl.tankLevelLabel.Caption = Format$(x5, "###0.0") & " %"
                    End If
                    Debug.Print "Level:" + str$((x5))
              Case 18:
                    readAllFlows = True
                    ReadXReturnX4 101
                    readAllFlows = False
              Case 19:
                    readAllFlows = True
                    ReadXReturnX4 102
                    readAllFlows = False
              Case 20:
                    readAllFlows = True
                    ReadXReturnX4 103
                    readAllFlows = False
              Case 21:
                    readAllFlows = True
                    ReadXReturnX4 104
                    readAllFlows = False
              Case 22:
                    readAllFlows = True
                    ReadXReturnX4 105
                    readAllFlows = False
              Case 23:
                    readAllFlows = True
                    ReadXReturnX4 106
                    readAllFlows = False
              Case 24:
                    readAllFlows = True
                    ReadXReturnX4 107
                    readAllFlows = False
              Case 25:
                    readAllFlows = True
                    ReadXReturnX4 108
                    readAllFlows = False
              Case 26:
                    'readHumiditySensor
                    'ReadXReturnX4 humidityGaugeNumber
                    If hasMultipleMVs Then
                        'ManualControl1.lblPercentHumidity.Caption = str$(readHumiditySensor) + " %"
                    Else
                        ManualControl.lblPercentHumidity.Caption = str$(readHumiditySensor) + " %"
                    End If
              Case 27:
                    
                    If EPress% = 0 Then
                        ReadXReturnX4 37
                        ManualControl.ejectPLabel.Caption = ts$(525) + " (" + ts$(308) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "Comp. Press. (High): "/"counts"
                        readings_counter = readings_counter + 1
                    Else
                        ReadXReturnX4 36
                        ManualControl.ejectPLabel.Caption = ts$(525) + " (" + ts$(307) + "): " + Xformat$(x4, "####0") + " " + ts$(231) + " " + Xformat$(x5 * PCNV, "#####.000") + " " + PU$ ' "Comp. Press. (low): "/"counts"
                        readings_counter = readings_counter + 1
                    End If
            End Select
            
            auto_index% = auto_index% + 1
            If auto_index% = 2 And (itester Or BPTester) Then
                auto_index% = 3
            End If
            If (auto_mode% = 1 Or nov2) And auto_index% = 4 Then
                auto_index% = 5
            End If
            If auto_index% = 5 And (Not H2OPERM) And Not DiffPG Then
                auto_index% = 6
            End If
            If auto_index% = 6 And Not regulator_running Then
                auto_index% = 7
            End If
            If auto_index% = 7 And ((Not auxin) Or Second_Penetrometer) And dryChamberTemperature = 0 And wetChamberTemperature = 0 And reservoirTemperature = 0 Then
                auto_index% = 8
            End If
            If auto_index% = 8 And Not compression_regulator_running Then
                auto_index% = 9
            End If
            If auto_index% = 9 And Not autocompress Then
                auto_index% = 10
            End If
            If auto_index% = 10 And BubblerLevelChannel < 0 And ReserveTankLevelChannel < 0 Then
                auto_index% = 11
            End If
            If auto_index% = 11 And Not piston_position_transducer_exists Then '6.71.123.05
                auto_index% = 12
            End If
            If auto_index% = 12 And Not slurry_tube_exists Then '6.71.123.05
                auto_index% = 13
            End If
            If auto_index% = 13 And Not slurry_tube_exists Then '6.71.123.05
                auto_index% = 14
            End If
            If auto_index% = 14 And Not slurry_tube_exists Then '6.71.123.05
                auto_index% = 15
            End If
            If auto_index% = 15 And Not num_sample_pressure_gauges > 0 Then
                auto_index% = 16
            End If
            If auto_index% = 16 And Not num_sample_pressure_gauges > 1 Then
                auto_index% = 17
            End If
            If auto_index% = 17 And Not tank_level_exists Then
                auto_index% = 18
            End If
            If auto_index% = 18 And Not hasMultipleMVs Then
                auto_index% = 26
            End If
            If auto_index% = 26 And Not hasHumidityControls Then
                auto_index% = 27
            End If
            If auto_index% = 27 And Not hasSampleEject Then
                auto_index% = 28
            End If
            '6.71.123.05 If auto_index% >= 11 Then
            If auto_index% >= 28 Then  '6.71.123.05
                If GasPerm Then
                    auto_index% = 2
                Else
                    auto_index% = 1
                End If
            End If
            If auto_mode% > 0 Then auto_index% = -auto_index%
        End If
        DoEvents
        ' don't let readings_counter get too large (though it shouldn't be able to)
        If readings_counter > 10000 Then readings_counter = 10000
        
        If auto_mode% = 1 And command_issued%(41) = 1 And useBubblerMV Then
            command_issued%(41) = 0
            Send_RS232 ("SS")
            auto_mode% = 0
        ElseIf auto_mode% = 1 And command_issued%(41) = 1 And Not hasMultipleMVs Then
            command_issued%(41) = 0
            Rem stop valve
            Send_RS232 ("S" + mv1_index_char)
            Debug.Print "Stop MV1"
            auto_mode% = 0
        'AJB 12-13-09
        ElseIf hasMultipleMVs And auto_mode% = 1 And command_issued%(41) = 1 Then
            command_issued%(41) = 0
            If motorValveIndex = 0 Then
                Rem stop valve
                Send_RS232 ("S" + mv1_index_char)
                Debug.Print "Stop MV1"
            ElseIf motorValveIndex = 1 Then
                Rem stop valve
                Send_RS232 ("S" + mv2_index_char)
                Debug.Print "Stop MV2"
            ElseIf motorValveIndex = 2 Then
                Send_RS232 ("S" + mv3_index_char)
                Debug.Print ("Stop MV3")
            End If
            auto_mode% = 0
        End If
        DoEvents
        ' process future variables
        If future_pres% <> -1 Then Pres% = future_pres%
        If future_lflow% <> -1 Then lflow% = future_lflow%
        If future_hflow% <> -1 Then HFLOW% = future_hflow%
        If future_DPress% <> -1 Then DPress% = future_DPress%
        If future_CPress% <> -1 Then CPress% = future_CPress%
        If future_EPress% <> -1 Then EPress% = future_EPress%
    
        While Len(pending$) > 0 And auto_mode% = 0
            cmd% = Asc(Left$(pending$, 1))
            pending$ = Mid$(pending$, 2)
            Select Case cmd%
            Case 0:
                Rem toggle bottom autofill valve (hardware valve 13, picture valve 0)
                If Vpos(13) = 0 Then
                    Move_Valve 12, "O"
                    If hasMultipleMVs Then
                        'Valve 0 doesn't exist yet
                        'ManualControl1.show_valve_open 0
                    Else
                        ManualControl.show_valve_open 0
                    End If
                Else
                    Move_Valve 12, "C"
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_closed 0
                    Else
                        ManualControl.show_valve_closed 0
                    End If
                End If
            Case 1:
                Rem toggle valve 1
                If dualregulator And Vpos(17) = 1 Then
                    If Vpos(18) = 0 Then
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_open 1
                        Else
                            ManualControl.show_valve_open 1
                        End If
                        Move_Valve 0, "O"
                        DoEvents
                    Else
                        Move_Valve 0, "C"
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_closed 1
                        Else
                            ManualControl.show_valve_closed 1
                        End If
                        DoEvents
                    End If
                Else
                    If Vpos(1) = 0 Then
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_open 1
                        Else
                            ManualControl.show_valve_open 1
                        End If
                        Move_Valve 0, "O"
                        DoEvents
                    Else
                        Move_Valve 0, "C"
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_closed 1
                        Else
                            ManualControl.show_valve_closed 1
                        End If
                        DoEvents
                    End If
                End If
            Case 2:
                Rem toggle drain for airtop (hardware 3)
                Rem or integ flow bottom chamber valve (hardware 20)
                Rem or penetrometer isolation (hardware 12) for bottom penetrometers
                Rem - all picture valve 2
                If AirTop Then
                    ' must be valve 20
                    If Vpos(20) = 0 Then
                        If hasMultipleMVs Then
                            'Valve 2 doesn't exist yet
                            'ManualControl1.show_valve_open 2
                        Else
                            ManualControl.show_valve_open 2
                        End If
                        Move_Valve 19, "O"
                    Else
                        Move_Valve 19, "C"
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_closed 2
                        Else
                            ManualControl.show_valve_closed 2
                        End If
                    End If
                ElseIf liqpermonly Or PEN20500 < 0 Then
                    ' must be valve 12
                    If Vpos(12) = 0 Then
                        If hasMultipleMVs Then
                            'Valve 2 doesn't exist yet
                            'ManualControl1.show_valve_open 2
                        Else
                            ManualControl.show_valve_open 2
                        End If
                        Move_Valve 11, "O"
                    Else
                        Move_Valve 11, "C"
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_closed 2
                        Else
                            ManualControl.show_valve_closed 2
                        End If
                    End If
                Else
                    ' must be valve 3
                    If Vpos(3) = 0 Then
                        If hasMultipleMVs Then
                            'Valve 2 doesn't exist yet
                            'ManualControl1.show_valve_open 2
                        Else
                            ManualControl.show_valve_open 2
                        End If
                        Move_Valve 2, "O"
                    Else
                        Move_Valve 2, "C"
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_closed 2
                        Else
                            ManualControl.show_valve_closed 2
                        End If
                    End If
                End If
            Case 3, 9, 12, 13
                Rem toggle airtop venting valve (3),
                Rem or penetrometer vent (9),
                Rem or airtop drain for liquid (12),
                Rem or filltop (13),
                If Vpos(cmd%) = 0 Then
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_open cmd%
                    Else
                        ManualControl.show_valve_open cmd%
                    End If
                    Move_Valve cmd% - 1, "O"
                    DoEvents
                Else
                    Move_Valve cmd% - 1, "C"
                    
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_closed cmd%
                    Else
                        ManualControl.show_valve_closed cmd%
                    End If
                    DoEvents
                End If
            Case 4:
                Rem airtop isolation valve (4) (which is displayed backwards)
                If Vpos(4) = 0 Then
                    If hasHumidityControls Then
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_closed 18
                        Else
                            ManualControl.show_valve_closed 18
                        End If
                    Else
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_closed 4
                        Else
                            ManualControl.show_valve_closed 4
                        End If
                    End If
                    Move_Valve 3, "O"
                    DoEvents
                Else
                    If hasHumidityControls Then
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_open 18
                        Else
                            ManualControl.show_valve_open 18
                        End If
                    Else
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_open 4
                        Else
                            ManualControl.show_valve_open 4
                        End If
                    End If
                    Move_Valve 3, "C"
                    DoEvents
                End If
            Case 5, 6, 7:
                Rem pulse 5, 6, or 7
                If num_sample_pressure_gauges > 0 Then
                    If Vpos(cmd%) = 0 Then
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_open cmd%
                        Else
                            ManualControl.show_valve_open cmd%
                        End If
                        Move_Valve cmd% - 1, "O"
                        DoEvents
                    Else
                        Move_Valve cmd% - 1, "C"
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_closed cmd%
                        Else
                            ManualControl.show_valve_closed cmd%
                        End If
                        DoEvents
                    End If
                Else
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_open cmd%
                    Else
                        ManualControl.show_valve_open cmd%
                    End If
                    DoEvents
                    VPulse cmd%
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_closed cmd%
                    Else
                        ManualControl.show_valve_closed cmd%
                    End If
                    DoEvents
                End If
            Case 8:
                Rem pulse 8
                If hasMultipleMVs Then
                    ManualControl1.show_valve_open 8
                Else
                    ManualControl.show_valve_open 8
                End If
                DoEvents
                Move_Valve 7, "O"
                Move_Valve 7, "C"
                If hasMultipleMVs Then
                    ManualControl1.show_valve_closed 8
                Else
                    ManualControl.show_valve_closed 8
                End If
                DoEvents
            Case 10:
                Rem decrement v2
                Pulse_V2 1
            Case 11:
                Rem increment v2
                Pulse_V2 0
            Case 14:
                Rem microflow vent (14) or frazier valve
                If FrazierPressureGauge Then
                    If Vpos(FrazierChamberValve) = 0 Then
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_open 14
                        Else
                            ManualControl.show_valve_open 14
                        End If
                        Move_Valve FrazierChamberValve - 1, "O"
                        DoEvents
                    Else
                        Move_Valve FrazierChamberValve - 1, "C"
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_closed 14
                        Else
                            ManualControl.show_valve_closed 14
                        End If
                        DoEvents
                    End If
                Else
                    If Vpos(14) = 0 Then
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_open 14
                        Else
                            ManualControl.show_valve_open 14
                        End If
                        Move_Valve 13, "O"
                        DoEvents
                    Else
                        Move_Valve 13, "C"
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_closed 14
                        Else
                            ManualControl.show_valve_closed 14
                        End If
                        DoEvents
                    End If
                End If
            Case 15:
                Rem v11 close
                Move_Valve 10, "C"
                If hasMultipleMVs Then
                    ManualControl1.show_valve_closed 11
                Else
                    ManualControl.show_valve_closed 11
                End If
            Case 16:
                Rem v11 open
                temp_pres% = Pres%
                Pres% = 0
                ReadXReturnX4 2
                Pres% = temp_pres%
                If x5 < PY2(2) Then
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_open 11
                    Else
                        ManualControl.show_valve_open 11
                    End If
                    Move_Valve 10, "O"
                End If
            Case 17 To 19: ' toggle valves 21 or 22 or 23 (15 or 16 or 17 on screen
                If Vpos(cmd% + 4) = 0 Then
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_open cmd% - 2
                    Else
                        ManualControl.show_valve_open cmd% - 2
                    End If
                    Move_Valve cmd% + 3, "O"
                    DoEvents
                Else
                    Move_Valve cmd% + 3, "C"
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_closed cmd% - 2
                    Else
                        ManualControl.show_valve_closed cmd% - 2
                    End If
                    DoEvents
                End If
            Case 20 To 29: ' chamber iso valve manipulated
                If hasMultipleMVs Then
                    'If ManualControl1.chamberiso(cmd% - 20).value = 1 Then
                        ' open valve: 20=-1, 21=-2, 22=-3, etc.
                    '    Move_Valve 19 - cmd%, "O"
                    'Else
                    '    Move_Valve 19 - cmd%, "C"
                    'End If
                    'ManualControl1.chamberiso(cmd% - 20).Enabled = True
                Else
                    If ManualControl.chamberiso(cmd% - 20).value = 1 Then
                        ' open valve: 20=-1, 21=-2, 22=-3, etc.
                        Move_Valve 19 - cmd%, "O"
                    Else
                        Move_Valve 19 - cmd%, "C"
                    End If
                    ManualControl.chamberiso(cmd% - 20).Enabled = True
                End If
            Case 30:
                Rem increase regulator
                If ip_reg_enable Then
                    If hasMultipleMVs Then
                        inc_reg ManualControl1.RegScroll.value
                    Else
                        inc_reg ManualControl.RegScroll.value
                    End If
                Else
                    inc_reg 1
                End If
                If Not newreg Then
                    If hasMultipleMVs Then
                        ManualControl1.Regulator.Caption = ts$(315) + " " + Xformat$(REGPOS, "####0") + " " + ts$(231)  ' "Regulator"/"counts"
                    Else
                        ManualControl.Regulator.Caption = ts$(315) + " " + Xformat$(REGPOS, "####0") + " " + ts$(231)  ' "Regulator"/"counts"
                    End If
                Else
                    regulator_running = True
                End If
            Case 31:
                Rem decrease regulator
                If ip_reg_enable Then
                    If hasMultipleMVs Then
                        lower_reg ManualControl1.RegScroll.value
                    Else
                        lower_reg ManualControl.RegScroll.value
                    End If
                Else
                    lower_reg 1
                End If
                If Not newreg Then
                    If hasMultipleMVs Then
                        ManualControl1.Regulator.Caption = ts$(315) + " " + Xformat$(REGPOS, "####0") + " " + ts$(231)   ' "Regulator"/"Counts"
                    Else
                        ManualControl.Regulator.Caption = ts$(315) + " " + Xformat$(REGPOS, "####0") + " " + ts$(231)   ' "Regulator"/"Counts"
                    End If
                Else
                    regulator_running = True
                End If
            Case 32:
                Rem regulator up by 10
                For temp_pres% = 1 To 10
                    If ip_reg_enable Then
                        If hasMultipleMVs Then
                            inc_reg ManualControl1.RegScroll.value
                        Else
                            inc_reg ManualControl.RegScroll.value
                        End If
                    Else
                        inc_reg 1
                    End If
                    DoEvents
                Next temp_pres%
                If Not newreg Then
                    If hasMultipleMVs Then
                        ManualControl1.Regulator.Caption = ts$(315) + " " + Xformat$(REGPOS, "####0") + " " + ts$(231) ' "Regulator"/" Counts"
                    Else
                        ManualControl.Regulator.Caption = ts$(315) + " " + Xformat$(REGPOS, "####0") + " " + ts$(231) ' "Regulator"/" Counts"
                    End If
                Else
                    regulator_running = True
                End If
            Case 33:
                Rem regulator down by 10
                For temp_pres% = 1 To 10
                    If ip_reg_enable Then
                        If hasMultipleMVs Then
                            lower_reg ManualControl1.RegScroll.value
                        Else
                            lower_reg ManualControl.RegScroll.value
                        End If
                    Else
                        lower_reg 1
                    End If
                    DoEvents
                Next temp_pres%
                If Not newreg Then
                    If hasMultipleMVs Then
                        ManualControl1.Regulator.Caption = ts$(315) + " " + Xformat$(REGPOS, "####0") + " " + ts$(231)       ' "Regulator"/"counts"
                    Else
                        ManualControl.Regulator.Caption = ts$(315) + " " + Xformat$(REGPOS, "####0") + " " + ts$(231)       ' "Regulator"/"counts"
                    End If
                Else
                    regulator_running = True
                End If
            Case 34:
                Rem zero regulator
                Zero_Reg
                If Not newreg Then
                    If hasMultipleMVs Then
                        ManualControl1.Regulator.Caption = ts$(315) + " " + Xformat$(REGPOS, "####0") + " " + ts$(231)       ' "Regulator"/"Counts"
                    Else
                        ManualControl.Regulator.Caption = ts$(315) + " " + Xformat$(REGPOS, "####0") + " " + ts$(231)       ' "Regulator"/"Counts"
                    End If
                Else
                    regulator_running = True
                End If
            Case 35:
                Rem calibrate
                CalibBoard.Show 1
            Case 36: ' new debugging command
                Open "c:\debug.txt" For Output As #1
                T = Timer
                While (Timer - T) < 10
                    ' read pressure gauge
                    ReadXReturnX4 2
                    Print #1, x5; ",";
                    ' read high flow meter
                    ReadXReturnX4 1
                    Print #1, x5; ","; Timer - T
                    DoEvents
                Wend
                ' increment the regulator
                inc_reg 10
                While (Timer - T) < 200
                    ' read pressure gauge
                    ReadXReturnX4 2
                    Print #1, x5; ",";
                    ' read high flow meter
                    ReadXReturnX4 1
                    Print #1, x5; ","; Timer - T
                    DoEvents
                Wend
                Close #1
            Case 37:
                Valve_Test
            Case 38:
                ReZeroAll
            Case 39:
                If hasHumidityControls And useBubblerMV Then
                    Send_RS232 ("OS")
                ElseIf hasMultipleMVs Then
                    If motorValveIndex = 0 Then
                        Send_RS232 ("O" + mv1_index_char)
                    ElseIf motorValveIndex = 1 Then
                        Send_RS232 ("O" + mv2_index_char)
                    ElseIf motorValveIndex = 2 Then
                        Send_RS232 ("O" + mv3_index_char)
                    End If
                Else
                    Rem start valve 2 opening
                    Send_RS232 ("O" + mv1_index_char)
                End If
                    
                valve_moving_direction% = 0
                auto_mode% = 1
            Case 40:
                If hasHumidityControls And useBubblerMV Then
                    Send_RS232 ("CS")
                ElseIf hasMultipleMVs Then
                    If motorValveIndex = 0 Then
                        Send_RS232 ("C" + mv1_index_char)
                    ElseIf motorValveIndex = 1 Then
                        Send_RS232 ("C" + mv2_index_char)
                    ElseIf motorValveIndex = 2 Then
                        Send_RS232 ("C" + mv3_index_char)
                    End If
                Else
                    Rem start valve 2 opening
                    Send_RS232 ("C" + mv1_index_char)
                End If
                valve_moving_direction% = 1
                auto_mode% = 1
            Case 41:
                Rem stop valve 2 is implied above
            Case 42: ' rewind regulator
                If hasMultipleMVs Then
                    'ManualControl1.regrew.value = False
                    'ManualControl1.regstop.Enabled = True
                Else
                    ManualControl.regrew.value = False
                    ManualControl.regstop.Enabled = True
                End If
                Send_RS232 ("CE")
                regulator_running = True
            Case 43: ' stop regulator
                If hasMultipleMVs Then
                    'ManualControl1.regstop.value = False
                Else
                    ManualControl.regstop.value = False
                End If
                Send_RS232 ("SE")
            Case 44: ' forward regulator
                If hasMultipleMVs Then
                    'ManualControl1.regff.value = False
                    'ManualControl1.regstop.Enabled = True
                Else
                    ManualControl.regff.value = False
                    ManualControl.regstop.Enabled = True
                End If
                Send_RS232 ("OE")
                regulator_running = True
            Case 45: ' temperature controller set
                ' target temperature is now encoded as base 128 not 256
                ' this is to avoid asian character problems.
                testtemp% = Asc(Left$(pending$, 1)) + 128 * Asc(Mid$(pending$, 2, 1))
                'Send_RS232i ";", testtemp%
                If hasMultipleMVs Then
                    'If ManualControl1.Combo1.Tag = "D" Then
                    '    setNewTemperature dryChamberTemperature, (testtemp% * 0.1)
                    'ElseIf ManualControl1.Combo1.Tag = "W" Then
                    '    setNewTemperature wetChamberTemperature, (testtemp% * 0.1)
                    'ElseIf ManualControl1.Combo1.Tag = "A" Then
                    '    setNewTemperature airTemperature, (testtemp% * 0.1)
                    'ElseIf ManualControl1.Combo1.Tag = "B" Then
                    '    setNewTemperature bubblerTemperature, (testtemp% * 0.1)
                    'ElseIf ManualControl1.Combo1.Tag = "C" Then
                    '    setNewTemperature cabinetTemperature, (testtemp% * 0.1)
                    'Else
                    '    setNewTemperature reservoirTemperature, (testtemp% * 0.1)
                    'End If
                Else
                    If ManualControl.Combo1.Tag = "D" Then
                        setNewTemperature dryChamberTemperature, (testtemp% * 0.1)
                    ElseIf ManualControl.Combo1.Tag = "W" Then
                        setNewTemperature wetChamberTemperature, (testtemp% * 0.1)
                    ElseIf ManualControl.Combo1.Tag = "A" Then
                        setNewTemperature airTemperature, (testtemp% * 0.1)
                    ElseIf ManualControl.Combo1.Tag = "B" Then
                        setNewTemperature bubblerTemperature, (testtemp% * 0.1)
                    ElseIf ManualControl.Combo1.Tag = "C" Then
                        setNewTemperature cabinetTemperature, (testtemp% * 0.1)
                    ElseIf ManualControl.Combo1.Tag = "H" Then
                        setNewTemperature hydroHeadTemperature, (testtemp% * 0.1)
                    ElseIf ManualControl.Combo1.Tag = "M" Then
                        setNewTemperature mullenTemperature, (testtemp% * 0.1)
                    Else
                        setNewTemperature reservoirTemperature, (testtemp% * 0.1)
                    End If
                End If
                pending$ = Mid$(pending$, 3)
            Case 46: ' rewind compression regulator, or clear ip regulator
                If ip_creg_enable Then
                    zero_creg
                Else
                    If hasMultipleMVs Then
                        ManualControl1.cregrew.value = False
                        ManualControl1.cregstop.Enabled = True
                    Else
                        ManualControl.cregrew.value = False
                        ManualControl.cregstop.Enabled = True
                    End If
                    Send_RS232 ("CP")
                End If
                compression_regulator_running = True ' this forces update to the display
            Case 47: ' stop compression regulator
                ' don't do anything for ip regulator
                If Not ip_creg_enable Then
                    If hasMultipleMVs Then
                        ManualControl1.cregstop.value = False
                    Else
                        ManualControl.cregstop.value = False
                    End If
                    Send_RS232 ("SP")
                End If
            Case 48: ' forward compression regulator
                If Not ip_creg_enable Then
                    If hasMultipleMVs Then
                        ManualControl1.cregff.value = False
                        ManualControl1.cregstop.Enabled = True
                    Else
                        ManualControl.cregff.value = False
                        ManualControl.cregstop.Enabled = True
                    End If
                    Send_RS232 ("OP")
                    compression_regulator_running = True
                End If
            Case 49: ' increment compression regulator
                If ip_creg_enable Then
                    If hasMultipleMVs Then
                        inc_creg ManualControl1.cregscroll.value
                    Else
                        inc_creg ManualControl.cregscroll.value
                    End If
                Else
                    inc_creg 1
                End If
                compression_regulator_running = True
            Case 50: ' decrement compression regulator
                If ip_creg_enable Then
                    If hasMultipleMVs Then
                        lower_creg ManualControl1.cregscroll.value
                    Else
                        lower_creg ManualControl.cregscroll.value
                    End If
                Else
                    lower_creg 1
                End If
                compression_regulator_running = True
            Case 51: ' increment compression regulator by 10
                For temp_pres% = 1 To 10
                    If ip_creg_enable Then
                        If hasMultipleMVs Then
                            inc_creg ManualControl1.cregscroll.value
                        Else
                            inc_creg ManualControl.cregscroll.value
                        End If
                    Else
                        inc_creg 1
                    End If
                    DoEvents
                Next temp_pres%
                compression_regulator_running = True
            Case 52: ' decrement compression regulator by 10
                For temp_pres% = 1 To 10
                    If ip_creg_enable Then
                        If hasMultipleMVs Then
                            lower_creg ManualControl1.cregscroll.value
                        Else
                            lower_creg ManualControl.cregscroll.value
                        End If
                    Else
                        lower_creg 1
                    End If
                    DoEvents
                Next temp_pres%
                compression_regulator_running = True
            Case 53: ' toggle piston valve (15)
                ' we go all the way down if we are up and only single stage
                ' or we are in the middle and dual stage
                If Vpos(15) = 0 And (dual_stage_compression = False Or Vpos(24) = 1) Then
                    ' safetydown takes priority over the autopiston door switch
                    If safetydown Then
                        If safetydowndoor Then
                            ' in manual control, we don't call check_safety_door, just do the normal test
                            If (RSEcho("R@", ver1or2) And 1) = 1 Then GoTo skip_53
                        Else
                            safetykeypress.mainlabel.Caption = ts$(206)         ' "Piston About To Lower"
                            If hasMultipleMVs Then
                                safetykeypress.Show 1, ManualControl1
                            Else
                                safetykeypress.Show 1, ManualControl
                            End If
                            If safety_canceled Then GoTo skip_53
                        End If
                    ElseIf autopiston Or FrazierPiston Then
                        If (RSEcho("R@", ver1or2) And 1) = 1 Then
                            GoTo skip_53
                        End If
                    End If
                    If hasMultipleMVs Then
                        ManualControl1.piston(1).Visible = True
                    Else
                        ManualControl.piston(1).Visible = True
                    End If
                    If pneumaticSwitchValveForPiston Then
                        Move_Valve 14, "O"
                    Else
                        Move_Valve 14, "O"
                    End If
                    If hasMultipleMVs Then
                        ManualControl1.piston(1).Height = 375
                    Else
                        ManualControl.piston(1).Height = 375
                    End If
                    DoEvents
skip_53:
                ' we go up if we are all the way down
                ElseIf dual_stage_compression = False Or (Vpos(24) = 1 And Vpos(15) = 1) Then
                    safety_canceled = False
                    If safetyup Then
                        If safetyupdoor Then
                            ' in manual control, we don't call check_safety_door, just do the normal test
                            If (RSEcho("R@", ver1or2) And 1) = 1 Then safety_canceled = True
                        Else
                            safetykeypress.mainlabel.Caption = ts$(166)         ' "Piston About To Raise"
                            If hasMultipleMVs Then
                                safetykeypress.Show 1, ManualControl1
                            Else
                                safetykeypress.Show 1, ManualControl
                            End If
                        End If
                    End If
                    If Not safety_canceled Then
                        If pneumaticSwitchValveForPiston Then
                            Move_Valve 15, "O"
                        Else
                            Move_Valve 14, "C"
                        End If
                        If hasMultipleMVs Then
                            ManualControl1.piston(1).Visible = False
                        Else
                            ManualControl.piston(1).Visible = False
                        End If
                        If dual_stage_compression Then
                            Move_Valve 23, "C"
                        End If
                    End If
                    DoEvents
                ' otherwise, we only go down to the middle
                Else
                    ' safetydown takes priority over the autopiston door switch
                    If safetydown Then
                        If safetydowndoor Then
                            ' in manual control, we don't call check_safety_door, just do the normal test
                            If (RSEcho("R@", ver1or2) And 1) = 1 Then GoTo skip_53
                        Else
                            safetykeypress.mainlabel.Caption = ts$(206)         ' "Piston About To Lower"
                            If hasMultipleMVs Then
                                safetykeypress.Show 1, ManualControl1
                            Else
                                safetykeypress.Show 1, ManualControl
                            End If
                            If safety_canceled Then GoTo skip_53a
                        End If
                    ElseIf autopiston Or FrazierPiston Then
                        If (RSEcho("R@", ver1or2) And 1) = 1 Then
                            GoTo skip_53a
                        End If
                    End If
                    If hasMultipleMVs Then
                        ManualControl1.piston(1).Height = 255
                        ManualControl1.piston(1).Visible = True
                    Else
                        ManualControl.piston(1).Height = 255
                        ManualControl.piston(1).Visible = True
                    End If
                    Move_Valve 23, "O"
                    DoEvents
skip_53a:
                End If
            Case 54: ' regulator 1 select
                Move_Valve 16, "C"
                regnum = 0
            Case 55: ' regulator 2 select
                Move_Valve 16, "O"
                regnum = 1
            Case 56, 57, 58: ' xhh valve manipulated
                If hasMultipleMVs Then
                    'If ManualControl1.xhhvalve(cmd% - 56).value = 1 Then
                        ' open valve: 56=12, 57=13, 58=14 (-1 for binary)
                    '    Move_Valve cmd% - 45, "O"
                    'Else
                    '    Move_Valve cmd% - 45, "C"
                    'End If
                    'ManualControl1.xhhvalve(cmd% - 56).Enabled = True
                Else
                    If ManualControl.xhhvalve(cmd% - 56).value = 1 Then
                        ' open valve: 56=12, 57=13, 58=14 (-1 for binary)
                        Move_Valve cmd% - 45, "O"
                    Else
                        Move_Valve cmd% - 45, "C"
                    End If
                    ManualControl.xhhvalve(cmd% - 56).Enabled = True
                End If
            Case 59: ' switch penetrometer_select value
                Rem first, close any current valves that have different valves for the second
                Rem penetrometer
                If Second_Penetrometer_V9 <> 9 Then
                    If Vpos(9) <> 0 Then
                        Move_Valve 8, "C"
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_closed 9
                        Else
                            ManualControl.show_valve_closed 9
                        End If
                        DoEvents
                    End If
                End If
                If Second_Penetrometer_V12 <> 12 Then
                    If Vpos(12) <> 0 Then
                        Move_Valve 11, "C"
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_closed 2
                        Else
                            ManualControl.show_valve_closed 2
                        End If
                        DoEvents
                    End If
                End If
                If Second_Penetrometer_V13 <> 13 Then
                    If Vpos(13) <> 0 Then
                        Move_Valve 12, "C"
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_closed 13
                        Else
                            ManualControl.show_valve_closed 13
                        End If
                        DoEvents
                    End If
                End If
                If Second_Penetrometer_V23 <> 23 Then
                    If Vpos(23) <> 0 Then
                        Move_Valve 22, "C"
                        If hasMultipleMVs Then
                            ManualControl1.show_valve_closed 23
                        Else
                            ManualControl.show_valve_closed 23
                        End If
                        DoEvents
                    End If
                End If
                
                Rem next, set penetrometer_select to current value
                penetrometer_select = 3 - penetrometer_select
                If hasMultipleMVs Then
                    'ManualControl1.penselect(penetrometer_select - 1).value = True
                Else
                    ManualControl.penselect(penetrometer_select - 1).value = True
                End If
                TitleScrn.selpen(penetrometer_select).Checked = True
                TitleScrn.selpen(3 - penetrometer_select).Checked = False
                WPPS "Capstuff", "Penetrometer_Select", str$(penetrometer_select), CSFile$
                If Second_Penetrometer And penetrometer_select = 2 Then
                    If hasMultipleMVs Then
                        ManualControl1.set_liqtubing (P2PEN20500 >= 0)
                    Else
                        ManualControl.set_liqtubing (P2PEN20500 >= 0)
                    End If
                Else
                    If hasMultipleMVs Then
                        ManualControl1.set_liqtubing (PEN20500 >= 0)
                    Else
                        ManualControl.set_liqtubing (PEN20500 >= 0)
                    End If
                End If
            Case 60: ' new lv man control run
                If hasMultipleMVs Then
                    ManualControl1.Hide
                    lv_man_ctrl.Show
                    run_lv_man_ctrl
                    ' it is already unloaded by run_lv_man_ctrl
                    'Unload lv_man_ctrl
                    ManualControl1.Show
                Else
                    ManualControl.Hide
                    lv_man_ctrl.Show
                    run_lv_man_ctrl
                    ' it is already unloaded by run_lv_man_ctrl
                    'Unload lv_man_ctrl
                    ManualControl.Show
                End If
            Case 61: ' new low flow controller up
                If hasMultipleMVs Then
                    inc_lfctrl ManualControl1.lfcscroll.value
                    ManualControl1.lfclabel(1).Caption = Format$(lfcpos)
                Else
                    inc_lfctrl ManualControl.lfcscroll.value
                    ManualControl.lfclabel(1).Caption = Format$(lfcpos)
                End If
            Case 62: ' new low flow controller down
                If hasMultipleMVs Then
                    lower_lfctrl ManualControl.lfcscroll.value
                    ManualControl.lfclabel(1).Caption = Format$(lfcpos)
                Else
                    lower_lfctrl ManualControl.lfcscroll.value
                    ManualControl.lfclabel(1).Caption = Format$(lfcpos)
                End If
            Case 63: ' new low flow controller zero
                zero_lfctrl
                If hasMultipleMVs Then
                    ManualControl1.lfclabel(1).Caption = Format$(lfcpos)
                Else
                    ManualControl.lfclabel(1).Caption = Format$(lfcpos)
                End If
            Case 64: ' new door lock
                Send_RS232 ("O@")
                MsgBox ts$(478)     ' "Open Door Now"
                Send_RS232 ("C@")
            Case 65: ' toggle valve 25 (valvefill(18)) - new bubbler valve
                If Vpos(25) = 0 Then
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_open 18
                    Else
                        ManualControl.show_valve_open 18
                    End If
                    Move_Valve 24, "O"
                    DoEvents
                Else
                    Move_Valve 24, "C"
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_closed 18
                    Else
                        ManualControl.show_valve_closed 18
                    End If
                    DoEvents
                End If
            Case 66: ' toggle new valve 5 (valvefill(19))
                If Vpos(5) = 0 Then
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_open 19
                    Else
                        ManualControl.show_valve_open 19
                    End If
                    Move_Valve 4, "O"
                    DoEvents
                Else
                    Move_Valve 4, "C"
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_closed 19
                    Else
                        ManualControl.show_valve_closed 19
                    End If
                    DoEvents
                End If
            Case 67: ' air inlet 1 selected
                Move_Valve 15, "C"
                current_air_inlet = 1
            Case 68: ' air inlet 2 selected
                Move_Valve 15, "O"
                current_air_inlet = 2
            Case 69: ' set status light
                setStatusLights status_lights_value
            'edited 12/11/07 --Denis
            Case 70: 'selected the Fill Valve
                If ManualControl.Fill.value = 0 Then
                    Move_Valve Fill_ValveA, "C"
                    DoEvents
                Else
                    Move_Valve Fill_ValveA, "O"
                    DoEvents
                End If
                ManualControl.Fill.Enabled = True
            Case 71: 'selected the Drain Valve
                If ManualControl.Drain.value = 0 Then
                    Move_Valve Drain_ValveA, "C"
                    DoEvents
                Else
                    Move_Valve Drain_ValveA, "O"
                    DoEvents
                End If
                ManualControl.Drain.Enabled = True
            Case 72:
                If ManualControl.Fill2.value = 0 Then
                    Move_Valve Fill_ValveB, "C"
                    DoEvents
                Else
                    Move_Valve Fill_ValveB, "O"
                    DoEvents
                End If
                ManualControl.Fill2.Enabled = True
            Case 73:
                If ManualControl.Drain2.value = 0 Then
                    Move_Valve Drain_ValveB, "C"
                    DoEvents
                Else
                    Move_Valve Drain_ValveB, "O"
                    DoEvents
                End If
                ManualControl.Drain2.Enabled = True
            Case 74:    'toggle 2nd piston valve (8)
                        ' we go all the way down if we are up and only single stage
                        ' or we are in the middle and dual stage
                If Vpos(val(gpps2("Capstuff", "second_piston", CSFile$, "8"))) = 0 And dual_stage_compression = False Then ' Or Vpos(24) = 1) Then
                    ' safetydown takes priority over the autopiston door switch
                    If safetydown Then
                        If safetydowndoor Then
                            ' in manual control, we don't call check_safety_door, just do the normal test
                            If (RSEcho("R@", ver1or2) And 1) = 1 Then GoTo skip_74
                        Else
                            safetykeypress.mainlabel.Caption = ts$(206)         ' "Piston About To Lower"
                            If hasMultipleMVs Then
                                safetykeypress.Show 1, ManualControl1
                            Else
                                safetykeypress.Show 1, ManualControl
                            End If
                            If safety_canceled Then GoTo skip_74
                        End If
                    ElseIf autopiston Or FrazierPiston Then
                        If (RSEcho("R@", ver1or2) And 1) = 1 Then
                            GoTo skip_74
                        End If
                    End If
                    If hasMultipleMVs Then
                        ManualControl1.piston(3).Visible = True
        '                Move_Valve SecondPiston, "O"
                        ManualControl1.piston(3).Height = 375
                    Else
                        ManualControl.piston(3).Visible = True
        '                Move_Valve SecondPiston, "O"
                        ManualControl.piston(3).Height = 375
                    End If
                    DoEvents
skip_74:
             ' we go up if we are all the way down
             ElseIf dual_stage_compression = False Or Vpos(val(gpps2("Capstuff", "second_piston", CSFile$, "8"))) = 1 Then '(Vpos(24) = 1 And Vpos(7) = 1) Then
                    safety_canceled = False
                    If safetyup Then
                        If safetyupdoor Then
                            ' in manual control, we don't call check_safety_door, just do the normal test
                            If (RSEcho("R@", ver1or2) And 1) = 1 Then safety_canceled = True
                        Else
                            safetykeypress.mainlabel.Caption = ts$(166)         ' "Piston About To Raise"
                            If hasMultipleMVs Then
                                safetykeypress.Show 1, ManualControl1
                            Else
                                safetykeypress.Show 1, ManualControl
                            End If
                        End If
                    End If
                    If Not safety_canceled Then
    '                    Move_Valve SecondPiston, "C"
                        If hasMultipleMVs Then
                            ManualControl1.piston(3).Visible = False
                        Else
                            ManualControl.piston(3).Visible = False
                        End If
    '                    If dual_stage_compression Then
    '                        Move_Valve 23, "C"
    '                    End If
                    End If
                    DoEvents
                    ' otherwise, we only go down to the middle
                Else
                    ' safetydown takes priority over the autopiston door switch
                    If safetydown Then
                        If safetydowndoor Then
                            ' in manual control, we don't call check_safety_door, just do the normal test
                            If (RSEcho("R@", ver1or2) And 1) = 1 Then GoTo skip_74
                        Else
                            safetykeypress.mainlabel.Caption = ts$(206)         ' "Piston About To Lower"
                            If hasMultipleMVs Then
                                safetykeypress.Show 1, ManualControl1
                            Else
                                safetykeypress.Show 1, ManualControl
                            End If
                            If safety_canceled Then GoTo skip_74a
                        End If
                    ElseIf autopiston Or FrazierPiston Then
                        If (RSEcho("R@", ver1or2) And 1) = 1 Then
                            GoTo skip_74a
                        End If
                    End If
                    If hasMultipleMVs Then
                        ManualControl1.piston(3).Height = 255
                        ManualControl1.piston(3).Visible = True
                    Else
                        ManualControl.piston(3).Height = 255
                        ManualControl.piston(3).Visible = True
                    End If
    '                Move_Valve SecondPiston, "O"
                    DoEvents
skip_74a:
                End If
            Case 75: ' toggle slurry/wash valve V28           '6.71.123.09
                If Vpos(Slurry_wash_valve + 1) = 0 Then
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_open 20
                    Else
                        ManualControl.show_valve_open 20
                    End If
                    Move_Valve Slurry_wash_valve, "O" 'slurry/wash valve V28 O = Wash C = Slurry
                    DoEvents
                Else
                    Move_Valve Slurry_wash_valve, "C" 'slurry/wash valve V28 O = Wash C = Slurry
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_closed 20
                    Else
                        ManualControl.show_valve_closed 20
                    End If
                    DoEvents
                End If
            Case 76: ' toggle slurry tube vent valve V29      '6.71.123.09
                If Vpos(Slurry_tube_vent_valve + 1) = 0 Then
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_open 21
                    Else
                        ManualControl.show_valve_open 21
                    End If
                    Move_Valve Slurry_tube_vent_valve, "O" 'slurry tube vent valve V29 O = Air Side C = Vent/Drain
                    DoEvents
                Else
                    Move_Valve Slurry_tube_vent_valve, "C" 'slurry tube vent valve V29 O = Air Side C = Vent/Drain
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_closed 21
                    Else
                        ManualControl.show_valve_closed 21
                    End If
                    DoEvents
                End If
            Case 77: ' toggle slurry wash pump 30               '6.71.123.09
                If Vpos(Slurry_wash_pump + 1) = 0 Then
                    Move_Valve Slurry_wash_pump, "O" 'slurry wash pump 30 O = OFF, C = ON
                    If hasMultipleMVs Then
                        'ManualControl1.show_valve_closed 22 'NOTE: ENERGIZE TO "CLOSE" THE CONTACT TO SHOW "OPEN" = "ON" FOR MOTORS
                    Else
                        ManualControl.show_valve_closed 22 'NOTE: ENERGIZE TO "CLOSE" THE CONTACT TO SHOW "OPEN" = "ON" FOR MOTORS
                        'ManualControl.show_valve_open 22
                    End If
                    DoEvents
                Else
                    Move_Valve Slurry_wash_pump, "C" 'slurry wash pump 30 O = OFF, C = ON
                    If hasMultipleMVs Then
                        'ManualControl1.show_valve_open 22
                    Else
                        ManualControl.show_valve_open 22
                        'ManualControl.show_valve_closed 22
                    End If
                    DoEvents
                End If
            Case 78: ' toggle slurry tank paddle 31              '6.71.123.09
                If Vpos(Slurry_tank_paddle + 1) = 0 Then
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_closed 23 'NOTE: ENERGIZE TO "CLOSE" THE CONTACT TO SHOW "OPEN" = "ON" FOR MOTORS
                    Else
                        ManualControl.show_valve_closed 23 'NOTE: ENERGIZE TO "CLOSE" THE CONTACT TO SHOW "OPEN" = "ON" FOR MOTORS
                    End If
                    Move_Valve Slurry_tank_paddle, "O" 'slurry tank paddle 31 O = OFF, C = ON
                    DoEvents
                Else
                    Move_Valve Slurry_tank_paddle, "C" 'slurry tank paddle 31 O = OFF, C = ON
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_open 23
                    Else
                        ManualControl.show_valve_open 23
                    End If
                    DoEvents
                End If
            Case 79: ' toggle slurry tube top shut off valve V43           '6.71.123.09
                If Vpos(Slurry_tube_top_shut_off + 1) = 0 Then
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_open 24
                    Else
                        ManualControl.show_valve_open 24
                    End If
                    Move_Valve Slurry_tube_top_shut_off, "O" 'slurry tube top shut off valve V43
                    DoEvents
                Else
                    Move_Valve Slurry_tube_top_shut_off, "C" 'slurry tube top shut off valve V43
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_closed 24
                    Else
                        ManualControl.show_valve_closed 24
                    End If
                    DoEvents
                End If
            Case 80: ' toggle slurry tube fill valve V44      '6.71.123.09
                If Vpos(Slurry_tube_fill_valve + 1) = 0 Then
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_open 25
                    Else
                        ManualControl.show_valve_open 25
                    End If
                    Move_Valve Slurry_tube_fill_valve, "O" 'slurry tube fill valve V44
                    DoEvents
                Else
                    Move_Valve Slurry_tube_fill_valve, "C" 'slurry tube fill valve V44
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_closed 25
                    Else
                        ManualControl.show_valve_closed 25
                    End If
                    DoEvents
                End If
            Case 81: ' increase
                If slurry_tube_exists Then
                    If hasMultipleMVs Then
                        'inc_SlurryPumpSpeed ManualControl1.SlurryPumpSpeedScroll.value
                    Else
                        inc_SlurryPumpSpeed ManualControl.SlurryPumpSpeedScroll.value
                    End If
                End If
            Case 82: ' lower
                If slurry_tube_exists Then
                    If hasMultipleMVs Then
                        'lower_SlurryPumpSpeed ManualControl1.SlurryPumpSpeedScroll.value
                    Else
                        lower_SlurryPumpSpeed ManualControl.SlurryPumpSpeedScroll.value
                    End If
                End If
            Case 83: 'zero
                If slurry_tube_exists Then
                    zero_SlurryPumpSpeed
                End If
            Case 84: 'piston debugging dialog
                If test_piston Then
                    piston_test_dialog.Show 1
                End If
'            Case 85:
'                If number_of_wetting_valves > 0 Then
'                    Move_Valve wetting_valve(1) - 1, "O"
'                    turn_pump_on 1
'                End If
'            Case 86:
'                If number_of_wetting_valves > 0 Then
'                    Move_Valve wetting_valve(1) - 1, "C"
'                    turn_pump_off 1
'                End If
'            Case 87:
'                If number_of_wetting_valves > 0 Then
'                    If Vpos(wetting_valve(1)) = 0 Then
'                        Move_Valve wetting_valve(1) - 1, "O"
'                        DoEvents
'                    Else
'                        Move_Valve wetting_valve(1) - 1, "C"
'                        DoEvents
'                    End If
'                End If
            Case 85:
                If number_of_wetting_valves > 0 Then
                    If Vpos(wetting_valve(1)) = 0 Then
                        Move_Valve wetting_valve(1) - 1, "O"
                        DoEvents
                        'turn_pump_on 1
                    Else
                        Move_Valve wetting_valve(1) - 1, "C"
                        'turn_pump_off 1
                        DoEvents
                    End If
                End If
            Case 88:
                V2POS = mv2_start_pos
                motorValveIndex = 1
                OpenV2Pos
            Case 89:
                If hasMultipleMVs Then
                    CalibrateFlowMeter 1, 0, 0
                    CalibrateFlowMeter 1, 1, 0
                    CalibrateFlowMeter 1, 2, 0
                    CalibrateFlowMeter 1, 3, 0
                    CalibrateFlowMeter 2, 0, 1
                    CalibrateFlowMeter 2, 1, 1
                    CalibrateFlowMeter 2, 2, 1
                    CalibrateFlowMeter 2, 3, 1
                    MsgBox "Calibration Complete!", vbInformation
                End If
            Case 90: 'Zero Humidity Valve
                ' target valve position is now encoded as base 128 not 256
                ' this is to avoid asian character problems.
                'testtemp% = Asc(Left$(pending$, 1)) + 128 * Asc(Mid$(pending$, 2, 1))
                zero_hreg
                'pending$ = Mid$(pending$, 3)
            Case 91: 'Increase Humidity Valve by 1
                 Rem increase regulator
    '            If ip_reg_enable Then
    '                inc_hreg ManualControl.hregscroll.value
    '            Else
    '                inc_hreg 1
    '            End If
    '            ManualControl.lblHREGPOS.Caption = HREGPOS
            Case 92: 'Increase/Decrease Humidity Valve by VALUE
                 Rem increase regulator
    '            If ip_reg_enable Then
    '                dec_hreg ManualControl.hregscroll.value
    '            Else
    '                dec_hreg 1
    '            End If
    '            ManualControl.lblHREGPOS.Caption = HREGPOS
            Case 93:
                Rem regulator up by 10
    '            For temp_pres% = 1 To 10
    '                If ip_reg_enable Then
    '                    inc_hreg ManualControl.hregscroll.value
    '                Else
    '                    inc_hreg 1
    '                End If
    '                DoEvents
    '            Next temp_pres%
    '            ManualControl.lblHREGPOS.Caption = HREGPOS
            Case 94:
                Rem regulator up by 10
    '            For temp_pres% = 1 To 10
    '                If ip_reg_enable Then
    '                    dec_hreg ManualControl.hregscroll.value
    '                Else
    '                    dec_hreg 1
    '                End If
    '                DoEvents
    '            Next temp_pres%
    '            ManualControl.lblHREGPOS.Caption = HREGPOS
            Case 95:
                If hasMultipleMVs Then
                    'If ManualControl1.ResinValveCheckBox.value = 1 Then
                    '    Move_Valve Resin_Diverter_Valve - 1, "O"
                    'Else
                    '    Move_Valve Resin_Diverter_Valve - 1, "C"
                    'End If
                    'ManualControl1.ResinValveCheckBox.Enabled = True
                Else
                    If ManualControl.ResinValveCheckBox.value = 1 Then
                        Move_Valve Resin_Diverter_Valve - 1, "O"
                    Else
                        Move_Valve Resin_Diverter_Valve - 1, "C"
                    End If
                    ManualControl.ResinValveCheckBox.Enabled = True
                End If
            Case 96: ' resin vacuum pump control uses door lock command
                If hasMultipleMVs Then
                    'If ManualControl1.ResinVacuumCheckBox.value = 1 Then
                    '    Send_RS232 ("O@")
                    'Else
                    '    Send_RS232 ("C@")
                    'End If
                    'ManualControl1.ResinVacuumCheckBox.Enabled = True
                Else
                    If ManualControl.ResinVacuumCheckBox.value = 1 Then
                        Send_RS232 ("O@")
                    Else
                        Send_RS232 ("C@")
                    End If
                    ManualControl.ResinVacuumCheckBox.Enabled = True
                End If
            Case 97:
                'Decrement bubbler MV
                Pulse_BubblerMV 1
            Case 98:
                'Increment bubbler MV
                Pulse_BubblerMV 0
            Case 99:
                'Set servo pulse width
                If hasMultipleMVs Then
                    'Servo_Set_Pulse_Width val(ManualControl1.Servo_Width_Text.Text)
                Else
                    Servo_Set_Pulse_Width val(ManualControl.Servo_Width_Text.Text)
                End If
            Case 100:
                'Servo Table Go
                If hasMultipleMVs Then
                    'Servo_Go val(ManualControl1.Servo_Go_Text.Text)
                Else
                    Servo_Go val(ManualControl.Servo_Go_Text.Text)
                End If
            Case 101:
                If Vpos(sampleChamberDiverterValve + 1) = 0 Then
                    Move_Valve sampleChamberDiverterValve, "O"
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_closed 27
                    Else
                        ManualControl.show_valve_closed 27
                    End If
                Else
                    Move_Valve sampleChamberDiverterValve, "C"
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_open 27
                    Else
                        ManualControl.show_valve_open 27
                    End If
                End If
            Case 102:
                If Vpos(sampleEjectValve + 1) = 0 Then
                    Move_Valve sampleEjectValve, "O"
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_open 28
                    Else
                        ManualControl.show_valve_open 28
                    End If
                Else
                    Move_Valve sampleEjectValve, "C"
                    If hasMultipleMVs Then
                        ManualControl1.show_valve_closed 28
                    Else
                        ManualControl.show_valve_closed 28
                    End If
                End If
            Case 103:
                If ManualControl.Rotate1.value = 1 Then
                    turn_pump_on 1
                Else
                    turn_pump_off 1
                End If
            Case 104:
                If ManualControl.Rotate2.value = 1 Then
                    turn_pump_on 2
                Else
                    turn_pump_off 2
                End If
            Case 105:
                If ManualControl.PumpValve.value = 1 Then
                    Move_Valve (PumpValveNumber - 1), "O"
                Else
                    Move_Valve (PumpValveNumber - 1), "C"
                End If
            End Select
            
            Rem to increase "command_issued%" array if a case has been added.
            command_issued%(cmd%) = 0
        Wend
    Wend
    If hasMultipleMVs Then
        Unload ManualControl1
    Else
        Unload ManualControl
    End If
    manrunning = False
    Exit Sub
update_v2_picture:
    temp_l_value% = v2_plunger_left% - Int(8 * x5 + 0.5) * 15
    If hasMultipleMVs Then
        'If ManualControl1.v2shape(0).Left <> temp_l_value% Then
        '    ManualControl1.v2shape(0).Left = temp_l_value%
        'End If
    Else
        If ManualControl.v2shape(0).Left <> temp_l_value% Then
            ManualControl.v2shape(0).Left = temp_l_value%
        End If
    End If
    Return
fail_safe_test:
    x4 = raw_reading(13)
fail_safe_test_with_x4_already_read:
    ' 21000 counts is 2.5% above the normal two volt range
    If Vpos(11) = 1 And x4 > DAC_two + DAC_span * 0.025 And Not NoFailSafe Then
        'Debug.Print "Close V11 : X4 ="; x4
        Move_Valve 10, "C"
        If hasMultipleMVs Then
            ManualControl1.show_valve_closed 11
        Else
            ManualControl.show_valve_closed 11
        End If
    End If
    If x4 >= DAC_over And Not NoFailSafe And Not way3 Then
        Move_Valve 11, "O"
        Move_Valve 2, "O"
        If hasMultipleMVs Then
            ManualControl1.show_valve_open 12
            If AirTop Then
                ManualControl1.show_valve_open 3
            Else
                ManualControl1.show_valve_open 2
            End If
        Else
            ManualControl.show_valve_open 12
            If AirTop Then
                ManualControl.show_valve_open 3
            Else
                ManualControl.show_valve_open 2
            End If
        End If
        Zero_Reg
        MsgBox ts$(316)     ' "Regulator zeroed due to over pressure error"
    End If
    Return

End Sub

Private Sub do_command(Index As Integer)

    Debug.Print "Do_Command: " + str(Index)
    
    If command_issued%(Index) = 0 Then
        If (Index < 30 Or Index > 33) And (Index < 49 Or Index > 51) Then
            Rem regulator increments can be backed up
            Rem all other commands can't be executed while another of the same command is pending
            command_issued%(Index) = 1
        End If
        pending$ = pending$ + Chr$(Index)
    End If

End Sub

Private Sub CalibrateFlowMeter(index1 As Integer, index2 As Integer, mvIndex As Integer)
    Dim i As Integer
    Dim sum As Long
    Dim res As Long
    Dim prevMVIndex As Integer
    Dim prevHFlow As Integer
    
    prevMVIndex = motorValveIndex
    prevHFlow = HFLOW%
    
    motorValveIndex = mvIndex
    HFLOW% = index2
    
    sum = 0
    For i = 1 To 10
        ReadXReturnX4 1
        sum = sum + x4
    Next
    
    res = sum / 10
    
    FX1(index1, index2) = res
    FX2(index1, index2) = res + DAC_span
    
    WPPS "Capstuff", "FX1_" + Trim$(str$(index1)) + Trim$(str$(index2)), Trim$(str$(FX1(index1, index2))), CSFile$
    WPPS "Capstuff", "FX2_" + Trim$(str$(index1)) + Trim$(str$(index2)), Trim$(str$(FX2(index1, index2))), CSFile$
    
    HFLOW% = prevHFlow
    motorValveIndex = prevMVIndex
   Exit Sub
    
 
End Sub
                    
                    
Sub RunMultipleTest()

Dim last_test_index%

'''If auto_wet_enable = False Then
    nowait_at_beginning = preloaded_sample Or simpleqc_enable
    ' close all chamber valves
    If RUNNING Then
        For current_unit% = 1 To chambers
            Move_Valve -current_unit%, "C"
            If selchamber(current_unit%) Then
                last_test_index% = current_unit%
            End If
        Next current_unit%
    End If
    
    For current_unit% = 1 To chambers
        If current_unit% = last_test_index% Then
            nowait_at_end = False
        Else
            nowait_at_end = True
        End If
        If selchamber(current_unit%) Then
            waitseconds 30
            If RUNNING Then Move_Valve -current_unit%, "O"
            ' these are things that are initialized in init_for_ctrl, but
            ' since init_for_ctrl is not called between runs of a multi-chamber
            ' test, they should be re-initialized now
            pass = 0: HKey$ = " ": HKey2$ = " "
            holding = False
            want_to_hold = False
            
            process_CVtable ' reload lohm table for this unit
            
            If status_lights_enable Then setStatusLights 2
                RunTest
            If status_lights_enable Then setStatusLights 1
            If nowait_at_end And RUNNING Then
                Unload progress
            End If
            If RUNNING Then Move_Valve -current_unit%, "C"
            ' after the first chamber is run, all subsequent runs are automatic
            nowait_at_beginning = True
            ' if they aborted this test, then show the beginning of the next test
            If Aborted And current_unit% <> last_test_index% Then
                If MsgBox(ts$(317), vbYesNo) = vbNo Then        ' "Current test was aborted.  Do you want to continue with the next chamber?"
                    Exit For
                End If
                nowait_at_beginning = preloaded_sample Or simpleqc_enable
            End If
        End If
    Next current_unit%
    current_unit% = 1
'''Else
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''    chamber_ready = 1
'''    Do While chamber_ready = 1 Or chamber_ready = 2
'''        current_unit% = chamber_ready
'''        chamber_ready = 0
'''        If current_unit% = last_test_index% Then
'''            nowait_at_end = False
'''        Else
'''            nowait_at_end = True
'''        End If
'''        If selchamber(current_unit%) Then
'''            If RUNNING Then Move_Valve -current_unit%, "O"
'''            ' these are things that are initialized in init_for_ctrl, but
'''            ' since init_for_ctrl is not called between runs of a multi-chamber
'''            ' test, they should be re-initialized now
'''            pass = 0: HKey$ = " ": HKey2$ = " "
'''            holding = False
'''            want_to_hold = False
'''            process_CVtable ' reload lohm table for this unit
'''            If status_lights_enable Then setStatusLights 2
'''                RunTest
'''            If status_lights_enable Then setStatusLights 1
'''            If nowait_at_end And RUNNING Then
'''                Unload progress
'''            End If
'''            If RUNNING Then Move_Valve -current_unit%, "C"
'''            ' after the first chamber is run, all subsequent runs are automatic
'''            nowait_at_beginning = True
'''            ' if they aborted this test, then show the beginning of the next test
'''            If Aborted And current_unit% <> last_test_index% Then
'''                If MsgBox(ts$(317), vbYesNo) = vbNo Then        ' "Current test was aborted.  Do you want to continue with the next chamber?"
'''                    ''Exit For
'''                    Exit Do
'''                End If
'''                nowait_at_beginning = preloaded_sample Or simpleqc_enable
'''            End If
'''        End If
'''
'''        'tests to see if there the next chamber is ready for testing
'''        If chamber_ready = 0 Then
'''            If MsgBox("Do you have the Next Chamber ready?" + vbCrLf + vbCrLf + "Press OK to start next chamber." + vbCrLf + _
'''                       "Press CANCEL to stop tests.", vbOKCancel, "Waiting for User Input") = vbOK Then
'''                'Same as 'other chamber ready' on the progress form
'''                If chamber_ready = 1 Then
'''                    chamber_ready = 2
'''                ElseIf chamber_ready = 2 Then
'''                    chamber_ready = 1
'''                End If
'''            Else
'''                'done with testing
'''                GoTo TestingDoneHandler
'''            End If
'''
'''        End If
'''
'''    Loop
'''    ''Next current_unit%
'''TestingDoneHandler:
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''End If

'If FlowFlag Then
'    MsgBox ts$(318) + vbCrLf + ts$(319), 48, ts$(320)       ' "The program has detected flows during this test that are within 75% of the machine's full flow potential."/"You may wish to lessen the sample cross section to reduce the flow and rerun."/"Flow Limit Warning"
'End If

TitleScrn.MousePointer = 0
Unload progress

End Sub
Sub RunSequentialTest()
    fileIncreaseNum = 1
    nowait_at_beginning = preloaded_sample Or simpleqc_enable
    ' close all chamber valves
    If RUNNING Then
        If sequentialTesting Then
            Move_Valve -1, "C"
            Move_Valve -2, "C"
        End If
    End If

    chamber_ready = 1
    manuallySelectedChamber = 1
    tempChamberVal = 1
    Do While chamber_ready = 1 Or chamber_ready = 2
        tempChamberVal = chamber_ready
        Do While chamber_ready <> 0
            If RUNNING Then
                Move_Valve -chamber_ready, "O"
                tempChamberValB = chamber_ready
                chamber_ready = 0
                nowait_at_end = True
                RunTest
                fileIncreaseNum = fileIncreaseNum + 1
                progress.mainmenu(8).Visible = True
                manuallySelectedChamber = chamber_ready
                tempChamberVal = chamber_ready
            End If
        Loop
        If tempChamberVal = 1 Then
            If MsgBox("Is Chamber 2 ready?" + vbCrLf + vbCrLf + "Press OK if READY." + vbCrLf + _
                   "Press CANCEL to stop and EXIT tests.", vbOKCancel, "Next Test") = 1 Then
                chamber_ready = 2
                manuallySelectedChamber = 2
            Else
                chamber_ready = 0
            End If  'end oif message box if
        ElseIf tempChamberVal = 2 Then
            If MsgBox("Is Chamber 1 ready?" + vbCrLf + vbCrLf + "Press OK if READY." + vbCrLf + _
                   "Press CANCEL to stop and EXIT tests.", vbOKCancel, "Next Test") = 1 Then
                chamber_ready = 1
                manuallySelectedChamber = 1
            Else
                chamber_ready = 0
            End If  'end of message box if
        Else
            If tempChamberValB = 1 Then
                If MsgBox("Is Chamber 2 ready?" + vbCrLf + vbCrLf + "Press OK if READY." + vbCrLf + _
                    "Press CANCEL to stop and EXIT tests.", vbOKCancel, "Next Test") = 1 Then
                     chamber_ready = 2
                     manuallySelectedChamber = 2
                Else
                    chamber_ready = 0
                End If  'end of message box if
            Else
                If MsgBox("Is Chamber 1 ready?" + vbCrLf + vbCrLf + "Press OK if READY." + vbCrLf + _
                    "Press CANCEL to stop and EXIT tests.", vbOKCancel, "Next Test") = 1 Then
                     chamber_ready = 1
                     manuallySelectedChamber = 1
                Else
                    chamber_ready = 0
                End If  'end of message box if
            End If
        End If
    Loop
    
    If FlowFlag Then
        MsgBox ts$(318) + vbCrLf + ts$(319), 48, ts$(320)    ' "The program has detected flows during this test that are within 75% of the machine's full flow potential."/"You may wish to lessen the sample cross section to reduce the flow and rerun."/"Flow Limit Warning"
    End If
    TitleScrn.MousePointer = 0
    Unload progress
End Sub

Sub run_recirculation_setup(mode As Integer)
Dim cmd%, readindex%
Dim last2730readstatus As Boolean
Dim last2730readtime As Single
Dim T As Single
Dim l_temp As Long

last2730readstatus = False ' read 27 next
last2730readtime = Timer ' last time we read either of them

recirculation_setup.Show 0
readindex% = 1
If mode = 1 Then
    ' alternative captions when run right before a test
    recirculation_setup.Command1(5).Caption = ts$(490)      ' "Start Test"
    recirculation_setup.Command1(6).Caption = ts$(491)      ' "Cancel Test"
    ' 6.71.80 can now start test in recirc1 mode as well as recirc2 mode
    'If flow_status <> 3 Then
    If flow_status < 2 Or flow_status > 3 Then
        recirculation_setup.Command1(5).Enabled = False
        ' can't start test unless in recirc2 mode (or recirc1 mode)
    End If
    recirculation_setup.Caption = recirculation_setup.Caption + " - " + sid$(current_unit%)
End If
pending$ = ""
If flow_status = 0 Then
    ' unknown flow status, start with stop flow command already pending
    pending$ = Chr$(3)
End If
Do While True
    While Len(pending$) > 0
        cmd% = Asc(Left$(pending$, 1))
        pending$ = Mid$(pending$, 2)
        Select Case cmd%
        Case 1: ' open chamber
            ' can only open the chamber if we are not in recirc2 mode
            ' and still need to follow the safety protocol
            If flow_status <> 3 Then
                safety_canceled = False
                If safetyup Then
                    If safetyupdoor Then
                        ' do auto door switch thing instead of key press thing
                        check_safety_door True
                    Else
                        safetykeypress.mainlabel.Caption = ts$(166)     ' "Piston About To Raise"
                        safetykeypress.Show 1, recirculation_setup
                    End If
                End If
                If Not safety_canceled Then
                    move_piston "C"
                    recirculation_setup.Label1.Caption = ts$(455)       ' "Chamber Status: Open"
                    recirculation_setup.Command1(4).Enabled = False ' can't go into recirc2 if chamber open
                End If
            End If
        Case 2: ' close chamber
            ' if compression_pressure=0 then we want to raise the piston as well
            ' but leave the flow status as if we have closed it
            ' This means they are using the screw-on lid
            ' can always close the chamber, but need to follow safety protocol
            safety_canceled = False
            ' safetydown will be turned off when you have the door switch
            ' but we leave this in here anyway just in case they ever go back
            If compression_pressure = 0 Then
                If safetyup Then
                    If safetyupdoor Then
                        ' do auto door switch thing instead of key press thing
                        check_safety_door True
                    Else
                        safetykeypress.mainlabel.Caption = ts$(166)     ' "Piston About To Raise"
                        safetykeypress.Show 1, recirculation_setup
                    End If
                End If
            ElseIf safetydown Then
                If safetydowndoor Then
                    ' do auto door switch thing instead of key press thing
                    check_safety_door True
                Else
                    safetykeypress.mainlabel.Caption = ts$(206)         ' "Piston About To Lower"
                    safetykeypress.Show 1, recirculation_setup
                End If
            End If
            If compression_pressure > 0 Then
                l_temp = RSEcho("R@", ver1or2)
                If l_temp < 40 And l_temp > 1 Then
                    safety_canceled = True
                    MsgBox ts$(457)         ' "Close door and try again"
                End If
            End If
            If Not safety_canceled Then
                If compression_pressure = 0 Then
                    move_piston "C"
                Else
                    move_piston "O"
                    '6.71.61 Give piston time to close
                    'T = Timer
                    'While (Timer - T <= pistonDelayTime): DoEvents: Wend
'                    waitseconds pistonDelayTime
                    '****
                End If
                recirculation_setup.Label1.Caption = ts$(456)       ' "Chamber Status: Closed"
                ' if we are already in recirc1 mode, we can now go into recirc2
                If flow_status = 2 Then
                    recirculation_setup.Command1(4).Enabled = True
                End If
            End If
        Case 3: ' stop all flow
            ' can always stop all flow
            Move_Valve 12, "C"
            Move_Valve 19, "C"
            Move_Valve 11, "C"
            Move_Valve 20, "C"
            If v22_exists Then
                Move_Valve 21, "C"
            End If
            flow_status = 1
            recirculation_setup.Label2.Caption = ts$(458)       ' "Flow Status: All Stopped"
            recirculation_setup.Command1(4).Enabled = False ' can't go directly into recirc2
            ' can open the piston if in stop mode
            recirculation_setup.Command1(0).Enabled = True
            ' can open the door if in stop mode
            recirculation_setup.Command1(7).Enabled = True
            If mode = 1 Then
                ' disable continue button since we are not in recirc2
                recirculation_setup.Command1(5).Enabled = False
            End If
        Case 4: ' recirculate 1
            ' can always go into recirc1
            Move_Valve 19, "C"
            Move_Valve 11, "C"
            Move_Valve 20, "C"
            If v22_exists Then
                Move_Valve 21, "C"
            End If
            Move_Valve 12, "O"
            flow_status = 2
            recirculation_setup.Label2.Caption = ts$(459)       ' "Flow Status: Partial Recirculation"
            'If mode = 1 Then
            '    ' disable continue button since we are not in recirc2
            '    recirculation_setup.Command1(5).Enabled = False
            'End If
            If mode = 1 Then
                ' enable continue button now that we are in recirc1
                recirculation_setup.Command1(5).Enabled = True
            End If
            ' if the piston is closed, we can now go into recirc2
            If piston_status = 2 Or compression_pressure = 0 Then
                recirculation_setup.Command1(4).Enabled = True
            End If
            ' can open the piston if in recirc1 mode
            recirculation_setup.Command1(0).Enabled = True
            ' can open the door if in recirc1 mode
            recirculation_setup.Command1(7).Enabled = True
        Case 5: ' recirculate 2
            ' double check that we are in recirc1 mode and the piston is closed
            ' and that the door is closed
            l_temp = RSEcho("R@", ver1or2)
            If flow_status = 2 And (piston_status = 2 Or compression_pressure = 0) And (l_temp > 40 Or l_temp < 2) Then
                If v22_exists Then
                    Move_Valve 21, "O"
                End If
                Move_Valve 19, "O"
                Move_Valve 11, "O"
                flow_status = 3
                ' can't open the piston if in recirc2 mode
                recirculation_setup.Command1(0).Enabled = False
                ' can't open the door if in recirc2 mode
                recirculation_setup.Command1(7).Enabled = False
                recirculation_setup.Label2.Caption = ts$(460)    '"Flow Status: Full Recirculation"
                If mode = 1 Then
                    ' enable continue button now that we are in recirc2
                    recirculation_setup.Command1(5).Enabled = True
                End If
            End If
        Case 6: ' continue
            If mode = 0 Then
                ' can always continue - leave everything alone since we will be coming
                ' back here after we setup the test
                Exit Do
            End If
            ' if this is the last call before the start of the test, we need to set the
            ' valves properly to prepare for the test
            ' We can only do this when we are already in recirc2 mode and the piston closed
            ' Also allow recirc1 mode
            If (piston_status = 2 Or compression_pressure = 0) And (flow_status = 3 Or flow_status = 2) Then
                Move_Valve 12, "C"
                If v22_exists Then
                    Move_Valve 21, "C"
                End If
                'Move_Valve 20, "O" ' this valve is opened later
                ' if we came here from recirc1, we need to open 20 and 12
                ' but first, delay while we wait for valve 13 to close
                '  all the way to avoid any burst of pressurized water
                '  from a still-slightly-open valve 13
                If flow_status = 2 Then waitseconds 4
                Move_Valve 19, "O"
                Move_Valve 11, "O"
                flow_status = 4 ' ready to run test
                Exit Do
            End If
        Case 7: ' cancel
            ' close everything off and quit - you can always do this
            Move_Valve 12, "C"
            Move_Valve 19, "C"
            Move_Valve 11, "C"
            Move_Valve 20, "C"
            If v22_exists Then
                Move_Valve 21, "C"
            End If
            flow_status = 0 ' set to uninitialized flow status to mark that we canceled
            Exit Do
        Case 8: ' open door switch
            Send_RS232 ("O@")
            MsgBox ts$(478)     ' "Open Door Now"
            Send_RS232 ("C@")
        Case 9: ' open drain
            ' for now, we are allowing the opening of the drain at all times
            ' at some point we may want to restrict this
            Move_Valve 22, "O"
            recirculation_setup.Command1(8).Enabled = False
            recirculation_setup.Command1(9).Enabled = True
        Case 10: ' close drain
            Move_Valve 22, "C"
            recirculation_setup.Command1(8).Enabled = True
            recirculation_setup.Command1(9).Enabled = False
        End Select
        DoEvents
    Wend
    Select Case readindex%
        Case 1:
            ' read penetrometer status
            ReadXReturnX4 4
            recirculation_setup.Label3.Caption = ts$(461) + ": " + Xformat$(x4, "####0") + " " + ts$(231) + "   " + Xformat$(x5, "####.000") + " cm"  ' "Penetrometer Status"/counts
        Case 2:
            ' read first temperature probe
            If last2730readtime > Timer + 0.1 Then last2730readtime = last2730readtime - 86400
            If (Timer - last2730readtime) >= 0.5 Then
                last2730readtime = Timer
                If last2730readstatus Then
                    'ReadXReturnX4 30
                    x5 = readNewTemperature(reservoirTemperature)
                    recirculation_setup.Label4.Caption = ts$(453) + ": " + Xformat$(x5, "#####.0") + " " + tsunit$      ' "Recirculating Fluid"
                    last2730readstatus = False
                Else
                    ' read second temperature probe
                    'ReadXReturnX4 27
                    x5 = readNewTemperature(wetChamberTemperature)
                    recirculation_setup.Label5.Caption = ts$(452) + ": " + Xformat$(x5, "#####.0") + " " + tsunit$      ' "Fluid at Sample"
                    last2730readstatus = True
                End If
            End If
        Case 3:
            ' read door switch
            ' only needed if we are in recirc2 mode
            If flow_status = 3 Then
                l_temp = RSEcho("R@", ver1or2)
                If l_temp <= 40 And l_temp > 1 Then
                    pending$ = Chr$(4) ' override all other pending commands and force recirc1 mode
                End If
            End If
    End Select
    readindex% = readindex% + 1
    If readindex% > 3 Then readindex% = 1
    DoEvents
Loop
Unload recirculation_setup

End Sub
Sub RunSingleTest()
        'setsToDo = GPM_numberSets       'edc 09-25=07
        'counter = 0
    nowait_at_beginning = preloaded_sample Or simpleqc_enable
    nowait_at_end = False
    If status_lights_enable Then setStatusLights 2
        'If TType(current_unit%) = 3 And GP_multisetTest Then
        '    Do While setsToDo >= 1
        '    RunTest
        '    Unload progress
        '    Loop
        'Else
        'MsgBox ("Running test")
        RunTest
        'End If
    If status_lights_enable Then setStatusLights 1
    If FlowFlag Then
        MsgBox ts$(318) + vbCrLf + ts$(319), 48, ts$(320)    ' "The program has detected flows during this test that are within 75% of the machine's full flow potential."/"You may wish to lessen the sample cross section to reduce the flow and rerun."/"Flow Limit Warning"
    End If

    TitleScrn.MousePointer = 0
    Unload progress
    
End Sub
'This function is created to allow for the control of either one or two watlows
Sub doTemperatureControl(Index As Integer)
    Dim dryTemp As Single
    Dim airTemp As Single
    Dim tempset As Boolean
    Dim airTempSet As Boolean
    Dim dryTempSet As Boolean
    
    If Index = 1 Then
       
        'load status
        Status.Label1.Caption = "Temperature Stability Routine:"
        Status.Label2.Caption = "Temperature Set Point:" + str(temperatureSetPoint) + " C"
        Status.Command1.Enabled = True
        Status.Show
        
        tempset = False
        dryTempSet = False
        
        setNewTemperature (dryChamberTemperature), temperatureSetPoint
        'wait for the temperature
        While Not tempset And Status.Command1.Enabled = True
            If Status.Command1.Enabled = False Then
                If MsgBox("User Exited Temperature Stability Routine, Continue To Test?", vbOKCancel) = vbCancel Then
                    setNewTemperature (dryChamberTemperature), 0
                    Exit Sub
                End If
            End If
            
            DoEvents
            
            dryTemp = readNewTemperature((dryChamberTemperature))
            
            Status.Label3.Caption = "Chamber Temp: " + str(dryTemp) + " C "
                        
            If dryTemp > (temperatureSetPoint - (temperatureSetPoint * 0.001)) And dryTemp < (temperatureSetPoint + (temperatureSetPoint * 0.001)) Then
                dryTempSet = True
            End If
            
            If dryTempSet Then
                tempset = True
            End If
            waitseconds 1
        Wend
        Status.Hide
    ElseIf Index = 2 Then
        
        'load status
        Status.Label1.Caption = "Temperature Stability Routine:"
        Status.Label2.Caption = "Temperature Set Point:" + str(temperatureSetPoint) + " C"
        Status.Command1.Enabled = True
        Status.Show
        'MsgBox "Set channel: " + Str$(dryChamberTemperature) + " = " + Str$(temperatureSetPoint)
        'MsgBox "Set channel: " + Str$(airTemperature) + " = " + Str$(temperatureSetPoint)
        setNewTemperature (dryChamberTemperature), temperatureSetPoint
        setNewTemperature (airTemperature), temperatureSetPoint
        'wait for the temperature
        
        While Not tempset And Status.Command1.Enabled = True
            If Status.Command1.Enabled = False Then
                If MsgBox("User Exited Temperature Stability Routine, Continue To Test?", vbOKCancel) = vbCancel Then
                    setNewTemperature (dryChamberTemperature), 0
                    setNewTemperature (airTemperature), 0
                    Exit Sub
                End If
            End If
            
            DoEvents
            
            dryTemp = readNewTemperature((dryChamberTemperature))
            
            Status.Label3.Caption = "Chamber Temp: " + str(dryTemp) + " C "
            
            If dryTemp > (temperatureSetPoint - (temperatureSetPoint * 0.001)) And dryTemp < (temperatureSetPoint + (temperatureSetPoint * 0.001)) Then
                dryTempSet = True
            End If
            
            If dryTempSet Then
                tempset = True
            End If
            waitseconds 1
        Wend
        Status.Hide
    End If
    reset_status_window
End Sub
Sub reset_status_window()
    
    Status.Label1.Caption = ""
    Status.Label2.Caption = ""
    Status.Label3.Caption = ""
    Status.Command1.Enabled = True
    
End Sub

Sub RunTest()


    Dim r As Long
    Dim T As Single, s As Single
    Dim FF As Single, i As Integer
    Dim XX As Integer
    Dim extra_type_of_gas As Boolean, extra_type_of_liquid As Boolean, temp$
    Dim TempFlow As Single
    Dim OpenTPF As Boolean
    Dim fn1 As Integer, fn2 As Integer
    Dim u$
    Dim compression_special As Boolean
    Dim original_v2incr As Single
    Dim time As Date
    Dim non_cpass_test As Boolean
    Dim retval As Double
    Dim first_loop As Boolean
    ' 6.71.64
    Dim filenameBase$
    Dim GP_darcies() As Single          ' Array to hold darcy values for a gasperm averaging test
    
    'JF added 1/21/2010 for BP Multi Tests
    Dim BPTestsRun As Integer
    ' 8/1/12 for multiple pressure hold tests
    Dim PHTestsRun As Integer
    'JF added 8-22-10 for LP Multi Tests
    Dim LPTestsRun As Integer
    
    Dim tmpLohmName As String
    Dim nReturn As Integer
    geoValveClosed = True
    
    Unload Testscrn
    first_loop = True ' this is the first loop through (for looping demo)

    Debug.Print "TType: " + str$(TType(current_unit%))
    Debug.Print "TMode: " + str$(TMode(current_unit%))
    Debug.Print "Current Unit: " + str$(current_unit%)
    
    On Error GoTo BadFileNameError
    filenameBase$ = Left$(OutFilename$(current_unit%), Len(OutFilename$(current_unit%)) - 4)
    On Error GoTo 0
    
    If TType%(current_unit%) = 3 Then ReDim GP_darcies(gP_numAvgTests)
    If Not cartridge_tester And Not multiChamberSystem Then
        current_unit% = 1
    End If
    
    ' Prepare to watch the pressure for reduction - Mix
    NeedToWatchPressForReduction = ReduceFlowAtTarget
    
    'setup valve positioning for if the system is a cartridge_tester
    If cartridge_tester Then
        If cartridge_tester_side = 0 Or (cartridge_tester_side = 1 And TType%(current_unit%) = 4) Then
            Move_Valve 5, "C"
            Move_Valve 4, "C"
            'Large flow penetrometer test
            If cartridge_tester_side = 1 And TType%(current_unit%) = 4 Then
                Move_Valve 8, "C"
                Move_Valve 4, "C"
            ElseIf cartridge_tester_side = 0 And TType%(current_unit%) = 4 Then
                Move_Valve 9, "O"
            End If
        Else
            Move_Valve 5, "O"
            Move_Valve 4, "O"
        End If
    End If
    
    If Resin_Diverter_Valve > 0 Then
        If TType%(current_unit%) = 4 Then
            Move_Valve Resin_Diverter_Valve - 1, "C"
        ElseIf TType%(current_unit%) = 7 Then
            Move_Valve Resin_Diverter_Valve - 1, "O"
        End If
    End If
    
    'Adding code to select the correct penetrometer if they are hard coded to a specific test
    If Second_Penetrometer Then ' Only applies if there is more than one penetrometer
        If TType%(current_unit%) = 4 And liqperm_penetrometer > 0 Then 'If it is an LP test and the penet is hard coded
            penetrometer_select = liqperm_penetrometer
        ElseIf TType%(current_unit%) = 2 And TMode%(current_unit%) = 3 Then 'If it is a Hydro Head test
            If hhRunAsMullen(current_unit%) And (mullen_penetrometer > 0) Then 'If it is a Mullen test
                penetrometer_select = mullen_penetrometer
            ElseIf burst_penetrometer > 0 Then  'If it is a Burst test
                penetrometer_select = burst_penetrometer
            ElseIf hydrohead_penetrometer > 0 Then  'If it is a normal Hydro Head test
                penetrometer_select = hydrohead_penetrometer
            End If
        End If
    End If

    BPTestsRun = 0
    PHTestsRun = 0
    LPTestsRun = 0
GP_multiLoop:
BP_multiLoop:
LP_multiLoop:

    If RUNNING Then pleasewait.Show 0
    
    If multiChamberSystem = False Or manualMultiChamber = True Then
        u$ = ""
    Else
        u$ = ts$(103) + str$(current_unit%)             ' "Unit"
        progress.Caption = ts$(321) + " " + u$          ' "Current Test Status"
    End If
    'using_watlow = False
    
    If RUNNING Then
        BPTLNumPoints = 0
        fn1 = FreeFile
        Open EXE_Path$ + "lastdata.cft" For Output As #fn1
        Rem new extended header
        Rem note that this is duplicated in the Pressure_Hold routine
        Rem the Pressure_Hold routine does its own file creation and doesn't
        Rem use this.
        Print #fn1, "EXTENDED"
        Rem there are 2 new values for normal tests, 5 for diff perm
        '3 for square pore
        'and one more for capflow test type
        'and one or two more for parameter file used
        If TType%(current_unit%) = 6 Then
            If lvperm_enable Then
                x4 = 4 ' liquid vapor permeability
            Else
                x4 = 5     ' diff perm test
                If MF_Settle Then x4 = 8  ' three more for settling information
            End If
        Else
            x4 = 2  ' normal
        End If
        If SquarePores Then x4 = x4 + 1 ' one more for square pores
        If (TType%(current_unit%) = 1) Or (TType%(current_unit%) = 4) Then x4 = x4 + 1 ' one more for capflow tests
        If (TType%(current_unit%) = 3) Or (TType%(current_unit%) = 2) Or (TType%(current_unit%) = 1) Then x4 = x4 + 1 ' one parameter file
        If (TType%(current_unit%) = 1) And (TMode%(current_unit%) <> 4) Then x4 = x4 + 1 ' second parameter file if not linear dry
        If (TType%(current_unit%) < 3 Or TType%(current_unit%) > 5) Then x4 = x4 + 1 ' one more for tfactor, now always printed
        x4 = x4 + 1 ' for serial number
        x4 = x4 + 1 ' for lohm table
        If autocompress And compression_pressure > 0 Then
            x4 = x4 + 1 ' one more for compression pressure
            If use_sample_compression Then x4 = x4 + 2 ' two more for sample compression values
        End If
        ' store the initial temperature reading
        If dryChamberTemperature <> 0 Then x4 = x4 + 1
        If (TType%(current_unit%) = 3) And (TMode%(current_unit%) >= 10 And TMode%(current_unit%) <= 12) Then x4 = x4 + 2
        
        'JF 2-11-10
        ' Add in the Additional Info data if it is being used and increment the EXTENDED value
        If useAdditionalInfo Then x4 = x4 + numberOfAdditionalInfoLines
        If recordHumidityForAutoTests Then x4 = x4 + 1
        
        Print #fn1, x4
        Print #fn1, "Operator="; operator$(current_unit%)
        Print #fn1, "Lot Number="; lot_number$(current_unit%)
        Print #fn1, "Hardware Serial Number="; serial_number$
        
        ' 6.71.61
        If (TType%(current_unit%) < 3 Or TType%(current_unit%) > 5) Then Print #fn1, "Tortuosity Factor="; str$(tfactor)
        
        If SquarePores Then Print #fn1, "Pore Shape=Square"
        
' **********
' REPORT-WRITING CODE ENTERED BY TIM RICHARDS 04 05 06
'
        Select Case TType(current_unit)
            Case 1
                Print #fn1, "Type of test=";
                temp$ = TestName$()
                Rem strip off the leading stuff
                Print #fn1, Mid$(temp$, Len(ts$(380)) + 3)
                Print #fn1, "Wet Parameter="; TPFWET$(current_unit%)        ' IDENTICAL LINES (let's call it "A")
                If TMode%(current_unit%) <> 4 Then Print #fn1, "Dry Parameter="; TPFDRY$(current_unit%)
                Select Case TMode(current_unit)
                    Case 1        ' wet up / dry down
                    Case 2        ' wet up / dry up
                    Case 3        ' dry up / wet up
                    Case 4        ' wet up / calculated dry
                    Case 5        ' wet up / dry down, stop at bubble point
                    Case 6        ' wet up / dry up, with fluid sensing
                    Case 7        ' dry up / wet up, with fluid sensing
                    Case 8        ' wet up / dry up, no wait at dry
                    Case 9        ' wet up / dry up, no wait at dry, fluid sensing
                    Case 10       ' wet up / calculated dry, Darcy
                    Case 11       ' wet up / calculated dry, square root
                End Select
            Case 2
                Print #fn1, "Wet Parameter="; TPFWET$(current_unit%)        ' IDENTICAL LINES (let's call it "A")
                Select Case TMode(current_unit)
                    Case 0        ' manual bubble point
                    Case 1        ' auto bubble point
                    Case 2        ' integrity test on saturated sample
                    Case 3        ' hydrohead
                End Select
            Case 3
                If TMode%(current_unit%) <> 4 Then Print #fn1, "Dry Parameter="; TPFDRY$(current_unit%)
                Select Case TMode(current_unit)
                    Case 0        ' gas perm
                    Case 1        ' ESA
                    Case 2        ' pressure drop
                    Case 10
                        Print #fn1, "Using Non Standard Orifice Size=N/A"
                        Print #fn1, "Circular Orifice Diameter=N/A"
                    Case 11
                        Print #fn1, "Using Non Standard Orifice Size=N/A"
                        Print #fn1, "Circular Orifice Diameter=N/A"
                    Case 12
                End Select
            Case 4
                Select Case TMode(current_unit)
                    Case 1        ' liquid perm - ambient
                        Print #fn1, "Type of Test=Liquid Perm - Ambient"
                    Case 2        ' liquid perm - elevated
                        Print #fn1, "Type of Test=Liquid Perm - Elevated"
                    Case 13 '6.71.123.18
                        Print #fn1, "Type of Test=Liquid Perm - Build Cake By Pressure"
                    Case 14 '6.71.123.18
                        Print #fn1, "Type of Test=Liquid Perm - Build Cake By Flow"
                    Case 15 '6.71.123.18
                        Print #fn1, "Type of Test=Liquid Perm - Slurry Tube Wash Cycle"
                    Case Else
                        '6.71.123.18 Print #fn1, "Type of Test=Liquid Perm - Elevated - tmode=" & Str(TMode(current_unit))
                        Print #fn1, "Type of Test=Liquid Perm - tmode=" & str(TMode(current_unit))
                End Select
            Case 5                ' pressure hold
            Case 6                ' LV perm
                If Not lvperm_enable Then Print #fn1, "Initial Pressure="; mf_press(current_unit%); " PSI"
                Print #fn1, "Maximum Time="; mf_time(current_unit%); " minutes"
                Print #fn1, "Step Time="; Step_Time(current_unit%); " minutes"
                If lvperm_enable = False And MF_Settle Then
                    Print #fn1, "Settle Time Setting="; MF_Settle_time; " seconds"
                    Print #fn1, "Settle Pressure Setting="; MF_Settle_pressure; " PSI"
                    ' the following needs to be filled in later
                    Print #fn1, "Total Settling Time= Undetermined"
                End If
        End Select
        
        tmpLohmName = get_filename_from_path(current_lohm_path$)
        If current_unit% > 1 Then
            tmpLohmName = Left(tmpLohmName, Len(tmpLohmName) - 4) + Trim$(str$(current_unit%)) + ".cal"
        End If
        Print #fn1, "Lohm Table="; tmpLohmName
        
        If autocompress Then
            If compression_pressure > 0 Then
                If use_sample_compression Then
                    Print #fn1, "Sample Compression Diameter ="; sample_compression_diameter
                    Print #fn1, "Sample Compression Pressure ="; sample_compression_pressure
                End If
                Print #fn1, "Piston Compression Pressure ="; compression_pressure
            End If
        End If
        ' watlow takes priority over internal temperature readings
        If dryChamberTemperature <> 0 Then Print #fn1, "Initial sample chamber temperature ="; readNewTemperature(dryChamberTemperature)
        
        'Add the actual information and headers
        If useAdditionalInfo Then
            For i = 0 To numberOfAdditionalInfoLines - 1
                Print #fn1, infoLineHeaders(i) & "=" & infoLineValues(current_unit%, i)
            Next i
        End If
        
        If enableHumidityControlForAutoTests And recordHumidityForAutoTests Then
            Print #fn1, "Target Humidity=" & str(targetHumidity)
        ElseIf recordHumidityForAutoTests Then
            Print #fn1, "Target Humidity= "
        End If
        
        OpenTPF = False
        fn2 = FreeFile
        If (TType%(current_unit%) = 1 And (TMode%(current_unit%) = 3 Or TMode%(current_unit%) = 7)) Or TType%(current_unit%) = 3 Then
            If Dir$(TPFDRY$(current_unit%)) = "" Then
                MsgBox ts$(322)     ' "Error: Can't find dry parameter file - using defaults"
            Else
                Open TPFDRY$(current_unit%) For Input As #fn2
                OpenTPF = True
            End If
        ElseIf TType%(current_unit%) = 1 Or TType%(current_unit%) = 2 Then
            If Dir$(TPFWET$(current_unit%)) = "" Then
                MsgBox ts$(323)     ' "Error: Can't find wet parameter file - using defaults"
            Else
                Open TPFWET$(current_unit%) For Input As #fn2
                OpenTPF = True
            End If
        End If

        DoEvents

        If OpenTPF Then
            Input #fn2, PULSEWIDTH: Input #fn2, V2INCR
            Input #fn2, BUBLTIME: Input #fn2, BUBLFLOW
            Input #fn2, ZEROTIME: Input #fn2, Maxpres
            Input #fn2, MAXFLOW: Input #fn2, mineqtime
            Input #fn2, PRESSLEW: Input #fn2, flowslew
            Input #fn2, EQITER: Input #fn2, AVEITER
            Input #fn2, MAXPDIF: Input #fn2, MAXFDIF
            Input #fn2, STARTP: Input #fn2, STARTF
            Input #fn2, PulseDelay: Input #fn2, preginc
            On Error Resume Next
            minbppres = 0
            Input #fn2, minbppres
            On Error Resume Next
            Input #fn2, temperatureSetPoint 'AJB 10-21-09
            Input #fn2, temperatureSetPoint 'AJB 10-21-09
            Dim tC As Single
            Input #fn2, tC
            temperatureControl = IIf(tC, 1, 0)
            Debug.Print "tempSetPoint"; temperatureSetPoint
            On Error GoTo 0
            Close #fn2
        End If
        
        'AJB 10-21-09 Temperature Set Routine
        'determine if temperature control has been enabled.
        If temperatureControl Then
            
            'Determine number of active chambers
            Dim numberOfChambers As Integer
            
            If TType%(current_unit%) = 2 And TMode%(current_unit%) = 3 Then ' hydrohead
                If hhRunAsMullen(current_unit%) Then
                    setNewTemperature mullenTemperature - 1, temperatureSetPoint
                ElseIf hhRunAsBurst(current_unit%) Then ' use hydrohead temperature
                    setNewTemperature hydroHeadTemperature - 1, temperatureSetPoint
                Else
                    setNewTemperature hydroHeadTemperature - 1, temperatureSetPoint
                End If
'                If hhRunAsMullen(current_unit%) Then
'                    setNewTemperature mullenTemperature - 1, temperatureSetPoint
'                Else
'                    setNewTemperature hydroHeadTemperature - 1, temperatureSetPoint
'                End If
            Else
                If dryChamberTemperature <> 0 And airTemperature = 0 Then
                    numberOfChambers = 1
                    setNewTemperature (dryChamberTemperature - 1), temperatureSetPoint
                ElseIf dryChamberTemperature <> 0 And airTemperature <> 0 Then
                    numberOfChambers = 2
                    setNewTemperature (dryChamberTemperature - 1), temperatureSetPoint
                    setNewTemperature (airTemperature - 1), temperatureSetPoint
                End If
                
                'Enter the proper temperature control routine
                doTemperatureControl numberOfChambers
            End If
        End If
        
        Maxpres = maxp_set(current_unit%)
        ' maxp_set is not necessarily valid for types 4, 5, or 6
        If TType%(current_unit%) = 4 Then
            ' liquid permeability
            ' for elevated, we don't know the maximum pressure yet - that is entered later
            ' for ambient, we don't need a maximum pressure
            ' so for now, set to the top of reg1 just to be safe
            Maxpres = reg1pmax - 0.001
        ElseIf TType%(current_unit%) = 5 Then
            ' pressure hold
            Maxpres = Hold_Press(current_unit%)
        ElseIf TType%(current_unit%) = 6 Then
            ' microflow
            Maxpres = mf_press(current_unit%)
            If microflowregulator Then
                ' if we have active control of the pressure, we can go as high as
                ' the hold pressure plus the maximum differential pressure on the
                ' microflow pressure gauge
                Maxpres = Maxpres + PY2(4) - PY1(4)
            End If
        End If
        ' just in case, let's change the regulator now
        ' except for ttype 4 since we don't know yet what the maximum pressure
        ' really is
        ' 6.71.20
        using_low_regulator = False
        If dualregulator And TType%(current_unit%) <> 4 Then
            If Maxpres >= reg1pmax Then
                ' 6.71.20 begin
                ' 6.71.22
                'If second_regulator_starting_point = 0 Or minp_set(current_unit%) > reg1pmax Then
                If use_second_regulator_only Or minp_set(current_unit%) > reg1pmax Then
                    Move_Valve 16, "O"
                    regnum = 1
                    If (air_inlets = 2) Then
                        Move_Valve 15, "O"
                        current_air_inlet = 2
                    End If
                        
                Else
                    using_low_regulator = True
                    Move_Valve 16, "C"
                    regnum = 0
                    If (air_inlets = 2) Then
                        Move_Valve 15, "C"
                        current_air_inlet = 1
                    End If
                    
                End If
                ' 6.71.20 end
            Else
                using_low_regulator = True
                Move_Valve 16, "C"
                regnum = 0
                If (air_inlets = 2) Then
                    Move_Valve 15, "C"
                    current_air_inlet = 1
                End If

            End If
        End If
        
        'Save first set of parameters
        DRYParams = ""
        WETParams = ""
        BPParams = ""
        If (TType%(current_unit%) = 1 And (TMode%(current_unit%) = 3 Or TMode%(current_unit%) = 7)) Or TType%(current_unit%) = 3 Then
        'dry parameters
            DRYParams = "D," + str(V2INCR) + "," + str(preginc) + "," + str(mineqtime) + "," + str(PRESSLEW) + "," + str(flowslew) + "," + str(EQITER) + "," + str(AVEITER) + "," + str(MAXPDIF) + "," + str(MAXFDIF)
        Else
        'bubble point parameters
            BPParams = "B," + str(BUBLFLOW) + "," + str(BUBLTIME) + "," + str(minbppres) + "," + str(ZEROTIME) + "," + str(PulseDelay)
        'wet parameters
            WETParams = "W," + str(V2INCR) + "," + str(preginc) + "," + str(mineqtime) + "," + str(PRESSLEW) + "," + str(flowslew) + "," + str(EQITER) + "," + str(AVEITER) + "," + str(MAXPDIF) + "," + str(MAXFDIF)
        End If

        TitleScrn.Refresh
        GMaxF = STARTF
        FlowFlag = False
        
        ' Make sure our remap switch valve is in place - Mix
        FireOnRemapValve
        
        ' Make sure our target Athena temperature has been set
        If Athena1InTest Then Set_Athena Athena1Channel, Athena1Target
        If Athena2InTest Then Set_Athena Athena2Channel, Athena2Target
        
        DoEvents
    End If
    If Not RUNNING Then Exit Sub

    If TType%(current_unit%) = 1 And TMode%(current_unit%) = 5 Then
        stop_at_bp = True
        TMode%(current_unit%) = 1
    Else
        stop_at_bp = False
    End If
    If TType%(current_unit%) = 1 And TMode%(current_unit%) = 10 Then
        linear_type% = 1
        TMode%(current_unit%) = 4
    ElseIf TType%(current_unit%) = 1 And TMode%(current_unit%) = 11 Then
        linear_type% = 2
        TMode%(current_unit%) = 4
    Else
        linear_type% = 0
    End If
    If TType%(current_unit%) = 1 And TMode%(current_unit%) = 8 Then
        TMode%(current_unit%) = 2
        nowait_for_du = True
    ElseIf TType%(current_unit%) = 1 And TMode%(current_unit%) = 9 Then
        TMode%(current_unit%) = 6
        nowait_for_du = True
    Else
        nowait_for_du = False
    End If
    
    If TType%(current_unit%) = 1 And (TMode%(current_unit%) = 6 Or TMode%(current_unit%) = 7) Then
        use_fluid_sensor = True
        TMode%(current_unit%) = TMode%(current_unit%) - 4
    Else
        use_fluid_sensor = False
    End If
    ' given bublflow, find starting REGPOS value.  Also get sv2p and SHFP
    DoEvents
    ' we have already done this in init_for_ctrl if you have a low flow meter
    ' we only need to set things if you have a dual regulator
    If low_flow_controller Then
        ' 6.71.20
        using_low_regulator = False
        If dualregulator Then
            If Maxpres >= reg1pmax Then
                ' 6.71.20 begin
                ' 6.71.22
                'If second_regulator_starting_point = 0 Or minp_set(current_unit%) > reg1pmax Then
                If use_second_regulator_only Or minp_set(current_unit%) > reg1pmax Then
                    ' use second ones
                    SBPP = SBPP2
                    SHFP = SHFP2
                    Move_Valve 16, "O"
                    regnum = 1
                    
                    ' open 500 Psi inlet
                    If (air_inlets = 2) Then
                        Move_Valve 15, "O"
                        current_air_inlet = 2
                    End If
                Else
                    using_low_regulator = True
                    SBPP = SBPP1
                    SHFP = SHFP1
                    Move_Valve 16, "C"
                    regnum = 0
                    
                    ' open 100 Psi inlet
                    If (air_inlets = 2) Then
                        Move_Valve 15, "C"
                        current_air_inlet = 1
                    End If

                End If
                ' 6.71.20 end
            Else
                ' use the first ones
                using_low_regulator = True
                SBPP = SBPP1
                SHFP = SHFP1
                Move_Valve 16, "C"
                regnum = 0
                If (air_inlets = 2) Then
                    Move_Valve 15, "C"
                    current_air_inlet = 1
                End If
                
            End If
        End If
    ElseIf Not liqpermonly Then
        fn2 = FreeFile
        Open EXE_Path$ + "capcal.d8a" For Input As #fn2           'load capcal data
            ' 6.71.22
            'If dualregulator And Maxpres > reg1pmax And (second_regulator_starting_point = 0 Or minp_set(current_unit%) > reg1pmax) Then
            If dualregulator And (Maxpres > reg1pmax And minp_set(current_unit%) > reg1pmax) Or use_second_regulator_only Then
                ' rem skip first regulator calibration information
                Do
                    Input #fn2, XX, FF
                Loop Until XX = -1 And FF = -1
                Move_Valve 16, "O"
                regnum = 1
                If (air_inlets = 2) Then
                    Move_Valve 15, "O"
                    current_air_inlet = 2
                End If
            Else
                regnum = 0
                If (air_inlets = 2) Then
                    Move_Valve 15, "C"
                    current_air_inlet = 1
                End If

            End If
            SBPP = 0: SHFP = 0
            If BUBLFLOW <= MaxLowFlow Then
                TempFlow = BUBLFLOW
            Else
                ' if you are running a high flow bubble point, you open the regulator
                ' to the point where you would get 2 cc/min out of the low flow meter
                TempFlow = 0.2 * MaxLowFlow
            End If
            Do
                Input #fn2, XX, FF
                    If XX = -1 And FF = -1 Then GoTo REGPOS1
                If FF <= TempFlow Then SBPP = XX
                If FF <= 0.2 Then SHFP = XX
            Loop
            Do
                Input #fn2, XX, FF
            Loop While XX <> -1 Or FF <> -1
REGPOS1:
            ' 6.71.22
            If dualregulator And (Maxpres <= reg1pmax Or (Not use_second_regulator_only And minp_set(current_unit%) <= reg1pmax)) Then
                Do
                    Input #fn2, XX, FF
                Loop Until XX = -1 And FF = -1
                Move_Valve 16, "C"
                regnum = 0
                If (air_inlets = 2) Then
                    Move_Valve 15, "C"
                    current_air_inlet = 1
                End If

            End If
            If SHFP < 3 Then SHFP = 3
            Input #fn2, SV2P
        Close #fn2
    End If
    ' recirculation system does not have a temperature setting method
    If wetChamberTemperature <> 0 And TType%(current_unit%) = 4 And recirculation = False Then
        TTarg = lperm_temperature
        GetValue.Label1.Caption = ts$(324) + " (" + tsunit$ + "):"      ' "Enter testing temperature"
        GetValue.Continue.default = True
        GetValue.Text1.Text = LTrim$(str$(TTarg))
        GetValue.Text1.SelStart = 0
        GetValue.Text1.SelLength = Len(GetValue.Text1.Text)
        GetValue.Show 1
        If Got_Value <> -9 Then TTarg = Got_Value
        If TTarg < 0 Then TTarg = 0
        If TTarg > 999.9 Then TTarg = 999.9
        lperm_temperature = TTarg
    Else
        TTarg = 0
    End If
    If TTarg = 0 Then
        use_temperature = False
    Else
        use_temperature = True
    End If
    If TType%(current_unit%) = 2 And TMode%(current_unit%) = 3 Then
        If hhRunAsBurst(current_unit%) Then
            Print #fn1, "BURST"
        Else
            Print #fn1, "HYDROHEAD"
        End If
        
        'for the hydrohead and burst tests refill the penetrometer
        If (hhRunAsBurst(current_unit%) And (penetrometer_select = burst_penetrometer)) Or _
           (hhRunAsHydrohead(current_unit%) And (penetrometer_select = hydrohead_penetrometer)) Then
           
            Refill_Penetro
        End If

    End If
    ' it doesn't really matter what we put for pressure hold tests because the entire file
    ' is rewritten elsewhere
    If TType%(current_unit%) = 5 Then Print #fn1, "HOLD"                 'write header for output file
    If TType%(current_unit%) = 6 Then
        If MF_recordTemperature Then
            Print #fn1, "DIFFPERM+t"
        Else
            Print #fn1, "DIFFPERM"
        End If
    End If

    ' hydrohead tests do not have temperaturesensor headers on them
    'New Hydrohead for Masdar has temperature sensors for hydrohead and mullen
    If TType%(current_unit%) <> 2 Or TMode%(current_unit%) <> 3 Then
        If use_fluid_sensor Then
            Print #fn1, "FLUIDSENSOR"
            Print #fn1, fsunit$
        ElseIf dryChamberTemperature <> 0 And airTemperature = 0 And TType%(current_unit%) <> 4 Then
            Print #fn1, "TEMPERATURESENSOR"
        ElseIf use_temperature Or (recirculation And TType%(current_unit%) = 4) Then
            If reservoirTemperature <> 0 Then
                Print #fn1, "TEMPERATURESENSOR2"
            Else
                Print #fn1, "TEMPERATURESENSOR"
            End If
        ElseIf dryChamberTemperature <> 0 And airTemperature <> 0 And TType%(current_unit%) <> 4 Then
            Print #fn1, "TEMPERATURESENSORDUAL"
        End If
    End If
    
    ' JF edit data file from here
    Print #fn1, date$
    Print #fn1, Line1$(current_unit%)
    Print #fn1, Line2$(current_unit%)
    extra_type_of_gas = False
    extra_type_of_liquid = False
    If TType%(current_unit%) < 3 Then
        Print #fn1, fluid$(current_unit%)
    ElseIf TType%(current_unit%) = 3 Or TType%(current_unit%) = 6 Then
        If TType%(current_unit%) = 6 And lvperm_enable Then
            Print #fn1, fluid$(current_unit%)
        ElseIf Len(Gas$) < 21 Then
            Print #fn1, Gas$
           'Print #fn1,
        Else
            Print #fn1, "X"
            If TType%(current_unit%) = 6 Then
                ' for microflow, we put the extra gas information out now
                Print #fn1, Mid$(Gas$, 21)
                Print #fn1, str$(val(Left$(Gas$, 20)))
            Else
                ' for permeability, we set a flag and put this information out later
                extra_type_of_gas = True
            End If
        End If
    Else
        If Len(Liquid$(current_unit%)) < 21 Then
            Print #fn1, Liquid$(current_unit%)
        Else
            Print #fn1, "X"
            extra_type_of_liquid = True
        End If
    End If
    If TType%(current_unit%) = 2 Then Print #fn1, str$(surfTen(current_unit%))
    If TType%(current_unit%) = 1 Then
        Print #fn1, str$(-surfTen(current_unit%))
        ' negate diameter if we are outputing time values
        If use_time Then
            Diam(current_unit%) = -Diam(current_unit%)
        End If
        If cyl_len(current_unit%) = 0 Then
            Print #fn1, str$(Diam(current_unit%))
        Else
            Print #fn1, 0
            Print #fn1, str$(Diam(current_unit%)); ","; str$(cyl_len(current_unit%))
        End If
        ' negate diameter again to bring it back to normal
        If use_time Then
            Diam(current_unit%) = -Diam(current_unit%)
        End If
        Print #fn1, str$(thick(current_unit%))
    End If
    ' note that we don't output the extra information for diffperm tests (6)
    ' this is because we put it out above
    If TType%(current_unit%) >= 3 And TType%(current_unit%) <> 6 Then
        Print #fn1, 0
        If extra_type_of_gas Then
            Print #fn1, Mid$(Gas$, 21)
            Print #fn1, str$(val(Left$(Gas$, 20)))
        ElseIf extra_type_of_liquid Then
            Print #fn1, Mid$(Liquid$(current_unit%), 21)
            Print #fn1, str$(val(Left$(Liquid$(current_unit%), 20)))
        End If
    End If
    Print #fn1, sid$(current_unit%)
    If TType%(current_unit%) >= 3 Then
        If TType%(current_unit%) = 4 And use_time Then
            Diam(current_unit%) = -Diam(current_unit%)
        End If
        
        If cyl_len(current_unit%) = 0 Then
            Print #fn1, str$(Diam(current_unit%))
        Else
            Print #fn1, 0
            Print #fn1, str$(Diam(current_unit%)); ","; str$(cyl_len(current_unit%))
        End If
        ' SCDiam is only valid for ESA testing
        If SCDiam > Diam(current_unit%) And TType%(current_unit%) = 3 And TMode%(current_unit%) <> 0 Then
            Print #fn1, str$(-thick(current_unit%))
            Print #fn1, str$(SCDiam)
        Else
            Print #fn1, str$(thick(current_unit%))
        End If
        
        If TType%(current_unit%) = 4 And use_time Then
            Diam(current_unit%) = -Diam(current_unit%)
        End If
    End If
    If TType%(current_unit%) = 3 And TMode%(current_unit%) = 1 Then
        Print #fn1, str$(-mass(current_unit%))
        Print #fn1, str$(-density(current_unit%))
    ElseIf TType%(current_unit%) = 3 And TMode%(current_unit%) = 2 Then
        Print #fn1, "0"
        Print #fn1, str$(MAXFLOW), str$(mass(current_unit%)), str$(density(current_unit%))
    End If
           
    On Error GoTo 0
    Aborted = False
' JF GPLoopBack Start
GPLoopBack:
    DoEvents
    Init_System
    Close #fn1
    If Aborted Then
        Unload pleasewait ' 6.71.33
        Exit Sub            'v6.52.04 JP 5/26/93
    End If

    If LoopingDemo Then
        progress.Label4.Visible = True
        progress.Label4.ForeColor = vbRed
        If TType%(current_unit%) = 1 Then
            progress.Label4.Caption = ts$(435)  ' "Looping CFP Demo"
        ElseIf TType%(current_unit%) = 2 Then
            progress.Label4.Caption = ts$(436)  ' "Looping BP Demo"
        Else
            progress.Label4.Caption = ts$(437)  ' "Looping GP Demo"
        End If
    End If
    
    If GP_multiAverageTest Then
        progress.Label4.Visible = True
        progress.Label4.ForeColor = vbRed
        progress.Label4.Caption = "GP Avg (" + Format$(GP_multiAvgCounter + 1) + " of " + Format$(gP_numAvgTests) + ")"
    End If
BPLoopBack:                                 ' Loopback point for looping demo test
    
    If LoopingDemo Then                          ' Clear the bubble point from the previous test
        progress.Line26.Caption = ""
        progress.Picture1.Cls
        progress.happyface.Visible = False
        progress.sadface.Visible = False
    End If
    
    ' initialize the first array
    ReDim first_array.a(100)
    first_array.s = 100
    First_Curve = True
    color3 = RGB(255, 165, 0)
    If TType%(current_unit%) <> 4 Then
        If TMode%(current_unit%) <> 3 Or TType%(current_unit%) = 2 Then
            progress.W_Curve.Caption = ts$(325)     ' "Wet Curve"
            color1 = RGB(0, 0, 255)
            color2 = RGB(255, 0, 0)
        Else
            progress.W_Curve.Caption = ts$(326)     ' "Dry Curve"
            color2 = RGB(0, 0, 255)
            color1 = RGB(255, 0, 0)
        End If
        progress.W_Curve.ForeColor = color1
    End If
    If TType%(current_unit%) = 3 Then
        progress.W_Curve.Caption = ts$(326)         ' "Dry Curve"
        color2 = RGB(0, 0, 255)
        color1 = RGB(255, 0, 0)
        progress.W_Curve.ForeColor = color1
    End If
    If TType%(current_unit%) = 5 Then
        progress.W_Curve.ForeColor = RGB(255, 0, 255)
        progress.W_Curve.Caption = ts$(327)          ' "Pressure Hold Test"
        progress.Label2.Caption = ts$(74) + " - " + ts$(245) ' "Time - sec."
        progress.Label1.Caption = PU$
    End If
    If TType%(current_unit%) = 6 Then
        progress.W_Curve.ForeColor = RGB(255, 0, 255)
        If lvperm_enable Then
            progress.W_Curve.Caption = ts$(328)     ' "Liq. Vapor Permeability"
            progress.Label1.Caption = "Torr"
        Else
            progress.W_Curve.Caption = ts$(329)     ' "Microflow Analysis"
            progress.Label1.Caption = PU$
        End If
        progress.Label2.Caption = ts$(74) + " - " + ts$(75) ' "Time - min."
    End If
    points = 0
    If TType%(current_unit%) = 1 And TMode%(current_unit%) = 3 Then pass = 2        ' DUWU test
    man_bp_detect = False
    If TType%(current_unit%) = 2 And TMode%(current_unit%) = 2 And integrity Then
            ITP = minp_set(current_unit%)
            If reg_table_size%(regnum) > 0 Then
                If regnum = 0 Then
                    If reg_table_pres!(reg_table_size%(0)) < ITP Then
                        MsgBox (ts$(330))           ' "Minimum Pressure greater than maximum calibrated pressure for regulator."
                        ITP = reg_table_pres!(reg_table_size%(0))
                    End If
                Else
                    If reg_table_pres2!(reg_table_size%(1)) < ITP Then
                        MsgBox (ts$(330))           ' "Minimum Pressure greater than maximum calibrated pressure for regulator."
                        ITP = reg_table_pres2!(reg_table_size%(1))
                    End If
                End If
            End If
    Else
        ITP = 0
    End If
    ' compression only works for the first unit
    If autocompress And current_unit% = 1 Then
        Got_Value = compression_pressure
        If Got_Value <> -9 Then
            compression_pressure = Got_Value
            If compression_pressure = 0 And Not allowZeroCompression Then
                compression_pressure = 20
                compression_special = True
            Else
                compression_special = False
            End If
            If creg_table_size% > 0 Then
                If creg_table_pres!(creg_table_size%) < compression_pressure Then
                    MsgBox (ts$(331))                       ' "Compression Pressure greater than maximum calibrated pressure for regulator."
                    compression_pressure = creg_table_pres!(creg_table_size%)
                End If
            End If
            move_compression_regulator_to_pressure (compression_pressure)
            If compression_special Then compression_pressure = 0
            WPPS "Capstuff", "compression_pressure", str$(compression_pressure), CSFile$
            save_user_global_stuff
        Else
            MsgBox ts$(332)         ' "The compression regulator will be left at its current position"
        End If
    End If      ' autocompression
    ' we now allow estimated bubble point for high bublflow values
    If TType%(current_unit%) < 3 And Not (TType%(current_unit%) = 2 And TMode%(current_unit%) = 2) And Not nov2 Then
        ' starting pressure now set in test setup screen
            EBPP = minp_set(current_unit%)
            If reg_table_size%(regnum) > 0 Then
                If regnum = 0 Then
                    If reg_table_pres!(reg_table_size%(0)) < EBPP Then
                        MsgBox (ts$(330))           ' "Minimum Pressure greater than maximum calibrated pressure for regulator."
                        BBPP = reg_table_pres!(reg_table_size%(0))
                    End If
                Else
                    If reg_table_pres2!(reg_table_size%(1)) < EBPP Then
                        MsgBox (ts$(330))           ' "Minimum Pressure greater than maximum calibrated pressure for regulator."
                        BBPP = reg_table_pres2!(reg_table_size%(1))
                    End If
                End If
            End If
    Else
        EBPP = 0
    End If
    If TType%(current_unit%) = 2 And TMode%(current_unit%) = 3 And PSIPERCC > 0 Then
        ' get the hydrohead rate of pressure increase
        ' only for first pass
        If Not nowait_at_beginning Then
          Do
            GetValue.Label1.Caption = ts$(333) + " - " + PU$ + "/" + ts$(75)     ' "Rate of pressure increase"/"min"
            GetValue.Label1.Tag = ""
            GetValue.Text1.Text = str$(1)
            GetValue.Text1.SelStart = 0
            GetValue.Text1.SelLength = 10
            GetValue.Continue.default = True
            GetValue.Show 1
            If Got_Value <> -9 Then
                BUBLFLOW = Got_Value / PCNV / PSIPERCC
            Else
                Unload pleasewait  ' 6.71.33
                Exit Sub
            End If
            DoEvents
          Loop While BUBLFLOW <= 0
        End If
    End If
    If Aborted Then
        Unload pleasewait ' 6.71.33
        Exit Sub
    End If
    lock_p0 = False
    
    If slurry_tube_exists Then
        'try to get pump ready to accept commands
        set_slurry_wash_pump_aout_by_flow (0)
        Move_Valve Slurry_wash_pump, "C" 'slurry wash pump 30 O = OFF, C = ON
    End If
    
    '6.71.123.20 Load_Sample first_array
    'Skip Load Sample if slurry tube exists and Type = liquid perm and Mode = Slurry Tube Wash Cycle '6.71.123.20
    If slurry_tube_exists And (TType%(current_unit%) = 4) And (TMode%(current_unit%) = 15) Then '6.71.123.20
        Slurry_Tube_Wash_Cycle_Sub
    Else
        Load_Sample first_array
    End If
    If slurry_tube_exists And (TType%(current_unit%) = 4) And (TMode%(current_unit%) = 13) Then '6.71.123.20
        Build_Cake_By_Pressure_Sub
        Exit Sub
    End If
    If slurry_tube_exists And (TType%(current_unit%) = 4) And (TMode%(current_unit%) = 14) Then '6.71.123.20
        Build_Cake_By_Flow_Sub
        Exit Sub
    End If
    just_did_vacuum_purge = False
    
    DoEvents
    If Aborted Then
        Unload pleasewait ' 6.71.33
        Exit Sub
    End If
    
    Unload pleasewait ' 6.71.33
    progress.Show 0
    progress.Refresh
    With progress
        If (TType%(current_unit%) = 4) Or (TType%(current_unit%) = 7) Then
            .Picture1.Visible = False
            .X_Zero.Visible = False
            .Y_Zero.Visible = False
            .X_Max.Visible = False
            .Y_Max.Visible = False
            .List1.Visible = True
            .W_Curve.Visible = False
            .Label1.Visible = False
            .Label2.Visible = False
        Else
            .List1.Visible = False
            .X_Zero.Visible = True
            .Y_Zero.Visible = True
            .X_Max.Visible = True
            .Y_Max.Visible = True
            If TType%(current_unit%) <> 6 Then .Label2.Caption = PU$
            .W_Curve.Visible = True
            .Label1.Visible = True
            .Label2.Visible = True
        End If
        .happyface.Visible = False
        .sadface.Visible = False
    End With
    failed = False
    NOWHERE% = 0
'////////////////////////////////////////////////////
'Edited on 12/14/2007  --Denis
'Redone on SOMEDAY -- Andy
Dim startTime&, currentTime&, fillTime%
fillTime% = val(gpps2(Curr_U$, "wet_time", IFile$, "0"))
    If auto_wet_used And cartridge_tester Then
        If manuallySelectedChamber = 1 Then
            'fill time for water to run into chamber
            Move_Valve Drain_ValveA, "C"
            If fillTime% > 0 Then
                Move_Valve Fill_ValveA, "O"
                progress.Line25.Caption = "FILLING SAMPLE CHAMBER"
                If PneumaticMotor = True Then
                    turn_pump_on pnumValve%
                End If
                'waitseconds val(gpps2(Curr_U$, "wet_time", IFile$, "0"))
                'return current time in milliseconds
                startTime = Timer
                'read level sensor so x5 has the right value
                x5 = readChamberLiquidLevel(1)
                'loop
                Do: DoEvents
                    'read level sensor for each loop
                    x5 = readChamberLiquidLevel(1)
                    'set current time in milliseconds for each loop
                    currentTime& = Timer - startTime
                    
                    'exit loop if x5 is greater than 100% or if the current time - start time is greater than
                    'the setting in the file for fill time.
                Loop Until x5 >= auto_wet_fill_height Or currentTime& >= fillTime
                If PneumaticMotor = True Then turn_pump_off pnumValve%
                Move_Valve Fill_ValveA, "C"
            End If
            If x5 > auto_wet_fill_height Then
                progress.Line25.Caption = "Chamber over filled, Adjusting...."
                Move_Valve Drain_ValveA, "O"
                Do: DoEvents
                    x5 = readChamberLiquidLevel(1)
                Loop Until x5 <= auto_wet_fill_height
                Move_Valve Drain_ValveA, "C"
            End If
            DoEvents
            'soak time for water levels to hold
            progress.Line25.Caption = "SOAKING SAMPLE FOR: " + gpps2(Curr_U$, "soak_time", IFile$, "0") + "seconds."
            waitseconds val(gpps2(Curr_U$, "soak_time", IFile$, "0"))
            DoEvents
            
        End If
        '2nd chamber fill, soak, drain times
        If manuallySelectedChamber = 2 Then
            
            'fill time for water to run into chamber
           'fill time for water to run into chamber
            Move_Valve Drain_ValveB, "C"
            If fillTime% > 0 Then
                Move_Valve Fill_ValveB, "O"
                progress.Line25.Caption = "FILLING SAMPLE CHAMBER"
                If PneumaticMotor = True Then
                    turn_pump_on pnumValve%
                End If
                'waitseconds val(gpps2(Curr_U$, "wet_time", IFile$, "0"))
                'return current time in milliseconds
                startTime = Timer
                'read level sensor so x5 has the right value
                x5 = readChamberLiquidLevel(2)
                'loop
                Do: DoEvents
                    'read level sensor for each loop
                    x5 = readChamberLiquidLevel(2)
                    'set current time in milliseconds for each loop
                    currentTime& = Timer - startTime
                    
                    'exit loop if x5 is greater than 100% or if the current time - start time is greater than
                    'the setting in the file for fill time.
                Loop Until x5 >= auto_wet_fill_height Or currentTime& >= fillTime
                If PneumaticMotor = True Then turn_pump_off pnumValve%
                Move_Valve Fill_ValveB, "C"
            End If
            If x5 > auto_wet_fill_height Then
                progress.Line25.Caption = "Chamber over filled, Adjusting...."
                Move_Valve Drain_ValveB, "O"
                Do: DoEvents
                    x5 = readChamberLiquidLevel(2)
                Loop Until x5 <= auto_wet_fill_height
                Move_Valve Drain_ValveB, "C"
            End If
            DoEvents
            'soak time for water levels to hold
            progress.Line25.Caption = "SOAKING SAMPLE FOR: " + gpps2(Curr_U$, "soak_time", IFile$, "0") + "seconds."
            waitseconds val(gpps2(Curr_U$, "soak_time", IFile$, "0"))
            DoEvents
        End If
    End If
'////////////////////////////////////////////////////
    Dim testing As Boolean
    testing = True
'    testing = False
    OutLogFileName$(current_unit%) = filenameBase$ + ".log"
 
    If PA = 0 And Not testing Then
        waitseconds 10
' JF DEMO STOP

        MsgBox ts$(164), 0, ts$(165)            ' "This is as far as you can go with the demo program"/"Auto Test Demo"
        If (autocompress Or autopiston Or (FrazierPiston And FrazierRunning)) And (recirculation = False) Then
            safety_canceled = False
            If safetyup And Vpos(15) = 1 Then
                If safetyupdoor Then
                    ' do auto door switch thing instead of key press thing
                    check_safety_door True
                Else
                    safetykeypress.mainlabel.Caption = ts$(166)     ' "Piston About To Raise"
                    safetykeypress.Show 1, progress
                End If
            End If
            If Not safety_canceled Then move_piston "C"
        End If
        Exit Sub
    End If
    non_cpass_test = True                       ' Assume that the test doesn't use run_c_pass (and thus doesn't
                                                ' call caprep at the end by default)
    If TType%(current_unit%) = 2 And TMode%(current_unit%) = 0 Then
        Manual_BP
    ElseIf TType%(current_unit%) = 5 Then
        ' experimental - use rotating chamber fill for pressure hold test as well
        If (ComLoc <> 0 And auto_soak_enable And rotating_chamber_enable And Not hasMultipleMVs) Then 'And PumpValveNumber > 0) Then
            ' if it is not demo mode, then do the following
            ' Prepare the chamber for the cartridge test:
            ' rotate and fill rotating_chamber_enable And auto_soak_enable And Not hasMultipleMVs
            If (PHTestsRun = 0) Then
                 If (readReserveTankLevel() > ReserveTankLevelMin And current_unit = 1) Then
                    rotateAndFillCartridgeTesterChamber current_unit%
                 ElseIf readReserveTankLevel() > ReserveTankLevelMin / 2 And current_unit = 2 Then
                    rotateAndFillCartridgeTesterChamber current_unit%
                 Else
                    nReturn = MsgBox("Please add the liquid to the reservoir and click OK button to continue the test.", vbOKOnly)
                    If (nReturn <> vbOK) Then
                        Return '
                    Else
                        rotateAndFillCartridgeTesterChamber current_unit%
                    End If
                End If
            End If
        End If
        Pressure_Hold
        'TODO: loop back for multiple pressure hold tests
        ' after pressure hold tests are all done, drain the system
        If (ComLoc <> 0 And rotating_chamber_enable And auto_soak_enable And Not hasMultipleMVs) Then
            stopAndDrainCartridgeTesterChamber current_unit%
        End If
    ElseIf TType%(current_unit%) = 6 Then
        If lvperm_enable Then
            lvperm_test
        Else
            Diff_Perm_Test
        End If
    ElseIf TType%(current_unit%) = 4 And (TMode%(current_unit%) = 13 Or TMode%(current_unit%) = 14) Then
        'Added by JF to do nothing else during Slurry tests
    Else
        ' Used for single point test
        PROGRAMCTRL = 0
        'The following IF block was added by JF on 1-19-10 to add the auto wetting procedure for CFP tests for Corning.
        If ((TType%(current_unit%) = 1 And (TMode%(current_unit%) = 1 Or TMode%(current_unit%) = 2 Or TMode%(current_unit%) > 3)) Or TType%(current_unit%) = 2) And _
            number_of_wetting_valves > 0 And _
            auto_wet_wet_time > 0 And _
            auto_wet_used And _
            auto_wet_enable Then
            For i = 1 To number_of_wetting_valves
                auto_wet_sample wetting_valve(i)
            Next i
        End If
         'Move_Valve 3, "C"
         
        If (ComLoc <> 0 And auto_soak_enable And rotating_chamber_enable And Not hasMultipleMVs And PumpValveNumber > 0) Then
            ' if it is not demo mode, then do the following
            ' Prepare the chamber for the cartridge test:
            ' rotate and fill rotating_chamber_enable And auto_soak_enable And Not hasMultipleMVs
            If (BPTestsRun = 0) Then
                 If (readReserveTankLevel() > ReserveTankLevelMin And current_unit = 1) Then
                    rotateAndFillCartridgeTesterChamber current_unit%
                 ElseIf readReserveTankLevel() > ReserveTankLevelMin / 2 And current_unit = 2 Then
                    rotateAndFillCartridgeTesterChamber current_unit%
                 Else
                    nReturn = MsgBox("Please add the liquid to the reservoir and click OK button to continue the test.", vbOKOnly)
                    If (nReturn <> vbOK) Then
                        Return '
                    Else
                        rotateAndFillCartridgeTesterChamber current_unit%
                    End If
                End If
            End If
        End If
        'if geopore machine, close extra ball valve.
        If geoPoreValve Then
            Move_GeoValves "C"
            geoValveClosed = True
        End If
        'openv2completely
        Run_C_Pass first_array
        Call Move_Valve(9, "C")
        
        If TType(current_unit%) = 1 And geoPoreValve And TMode(current_unit%) = 2 Then
            Move_GeoValves "C"
            geoValveClosed = True
        End If
       ' close_v2_completely
        'Call Zero_Reg
        non_cpass_test = False
    End If
    If non_cpass_test Then              ' Give user a chance to run a report
        If auto_report_type = 1 Then retval = Shell(EXE_Path$ + "Caprep.exe " + "resultcall " + OutFilename$(current_unit%), 1)
        If auto_report_type = 2 Then retval = Shell(EXE_Path$ + "Caprep.exe " + OutFilename$(current_unit%), 1)
        Exit Sub
    End If
    
    DoEvents
    
    HKey$ = " "
    HKey2$ = " "
    FPOINTS = points
    
    If LoopingDemo And TType%(current_unit%) = 2 Then GoTo BPLoopBack       ' Looping BP test
    
    If TType%(current_unit%) > 1 Or Aborted Or TMode%(current_unit%) = 4 Then
        
        ' Looping GP test?
        If LoopingDemo And TType%(current_unit%) = 3 Then
            progress.Line26.Caption = FResult$
            fn1 = FreeFile
            Open "GPDemo.txt" For Append As #fn1
            Print #fn1, FResult$ + Space$(10) + Format$(str$(now), "mm/dd/yy hh:mm")
            Close #fn1
            waitseconds 15
            GoTo GPLoopBack

        ' added 6.71.64
        ElseIf GP_multiAverageTest And TType%(current_unit%) = 3 Then
            ' This is a multiple-test GP run with averaging
            GP_multiAvgCounter = GP_multiAvgCounter + 1
            OutFilename$(current_unit%) = filenameBase$ + "_" + str$(GP_multiAvgCounter) + ".cft"
            
            If GP_multiAvgCounter < gP_numAvgTests Then
                Test_Done           ' Run the first part of test_done to do write to lastdata.cft
                do_final_copy                           ' Copy lastdata into source file
            Else
                ' This is the final run, so we can just let test_done behave normally - will
                ' call do_final_copy on its own
                ' Need to temporarily turn off the special test flag, though, so we don't
                ' exit test_done prematurely as we have been doing. (Yes, this is sloppy.)
                GP_multiAverageTest = False
                Test_Done
                GP_multiAverageTest = True
            End If
            s = CalcGP(EXE_Path$ + "lastdata.cft")      ' Get permeability
            ' Save darcy value for future reference
            If s > -999 Then GP_darcies(GP_multiAvgCounter) = s
            fn1 = FreeFile
            Open filenameBase$ + "_summary.txt" For Append As #fn1
            If GP_multiAvgCounter = 1 Then
                Print #fn1, ts$(494) + " = " + sid$(current_unit%)              ' "Permeability results for sample ID"
                Print #fn1, "--------------------"
                Print #fn1, vbNullString
            End If
            Print #fn1, ts$(495) + str$(GP_multiAvgCounter) + ":  " + FResult$      '  "Test"
            Close #fn1
            If GP_multiAvgCounter < gP_numAvgTests Then
                GoTo GP_multiLoop
            Else
                ' We've done all our tests - finish up and exit
                ' First calculate the average value in the darcy file and append it
                Dim finalResult As Single
                For i = 1 To gP_numAvgTests
                    finalResult = finalResult + GP_darcies(i)
                Next i
                finalResult = finalResult / gP_numAvgTests
                Open filenameBase$ + "_summary.txt" For Append As #fn1
                Print #fn1, "--------------------"
                Print #fn1, ts$(496) + " = " + str$(finalResult)    ' "Average"
                Close #fn1
                Exit Sub
            End If
        ElseIf TType%(current_unit%) = 2 And bpRunMultipleTests Then
            BPTestsRun = BPTestsRun + 1
            OutFilename$(current_unit%) = filenameBase$ + "_" + str$(BPTestsRun) + ".cft"
            OutLogFileName$(current_unit%) = filenameBase$ + "_" + str(BPTestsRun) + ".log"
            
            If Aborted Then
                bpRunMultipleTests = False
                Test_Done
                If (rotating_chamber_enable And auto_soak_enable And Not hasMultipleMVs) Then
                    stopAndDrainCartridgeTesterChamber current_unit%
                End If
                Exit Sub
            End If
            
            If BPTestsRun < bpTestCount Then
                Test_Done
                do_final_copy  ' Is this right?
                progress.Picture1.Cls
                progress.Picture1.Refresh
                progress.Line26.Caption = ""
                GoTo BP_multiLoop
            Else
                bpRunMultipleTests = False
                Test_Done
                'Stop rotating cartridge tester chamber after the abort.
                If (ComLoc <> 0) Then
                    If (rotating_chamber_enable And auto_soak_enable And Not hasMultipleMVs) Then
                        stopAndDrainCartridgeTesterChamber current_unit%
                    End If
                End If
                bpRunMultipleTests = True
                Exit Sub
            End If
        ElseIf TType%(current_unit%) = 4 And lpRunMultipleTests Then
            LPTestsRun = LPTestsRun + 1
            OutFilename$(current_unit%) = filenameBase$ + "_" + str$(BPTestsRun) + ".cft"
            
            If LPTestsRun < lpTestCount Then
                Test_Done
                do_final_copy
                progress.Picture1.Cls
                progress.Picture1.Refresh
                progress.Line26.Caption = ""
                GoTo LP_multiLoop
            Else
                lpRunMultipleTests = False
                Test_Done
                lpRunMultipleTests = True
            End If
        End If
        
        'Stop rotating cartridge tester chamber after the abort.
        If (ComLoc <> 0 And TType%(current_unit%) = 2 And Not bpRunMultipleTests) Then
        Dim drainTime&
        drainTime& = val(gpps2(Curr_U$, "drain_time", IFile$, "10"))
            If manuallySelectedChamber = 1 Then
                If ((rotating_chamber_enable Or cartridge_tester) And auto_soak_enable And Not hasMultipleMVs) Then
                    'stopAndDrainCartridgeTesterChamber current_unit%
                    turn_pump_off current_unit%
                    If drainTime& > 0 Then
                        If auto_wet_used And cartridge_tester Then
                            If manuallySelectedChamber = 1 Then
                                Move_Valve Drain_ValveA, "O"
                            Else
                                Move_Valve Drain_ValveB, "O"
                            End If
                        End If
                    End If
                    
                    progress.Line25.Caption = "DRAIN VALVE OPEN FOR: " + str$(drainTime&) + " seconds."
                    '///////////////////////////////////////////
                    'waitseconds drainTime&
                    Dim THIS&, that&
                    that = drainTime&
                    THIS = (that * 1000)
                    'Make the timer count down in the auto test progress screen
                    'AW 9/21/2015
                    Dim startTimep&, currentTimep&, elapsedTimep&
                    Dim bubTimep&
                    bubTimep& = that
                    startTimep& = Timer
                    Do: DoEvents
                        currentTimep& = Timer
                        elapsedTimep& = currentTimep& - startTimep&
                        progress.Line25.Caption = "DRAIN VALVE OPEN FOR: " + str$(bubTimep& - elapsedTimep) + " seconds"
                        
                    Loop Until elapsedTimep& >= that
                    '/////////////////////////////////////////
                        If auto_wet_used And cartridge_tester Then
                        If manuallySelectedChamber = 1 Then
                            Move_Valve Drain_ValveA, "C"
                        Else
                            Move_Valve Drain_ValveB, "C"
                        End If
                    End If
                    DoEvents
                End If
            End If
        End If
        Test_Done
        Exit Sub
    End If
    OpenTPF = False
    fn1 = FreeFile
    If TMode%(current_unit%) = 3 Then
        If Dir$(TPFWET$(current_unit%)) = "" Then
            MsgBox ts$(323)                 ' "Error: Can't load wet parameter file - using defaults"
        Else
            Open TPFWET$(current_unit%) For Input As #fn1
            OpenTPF = True
        End If
    Else
        If Dir$(TPFDRY$(current_unit%)) = "" Then
            MsgBox ts$(322)                 ' "Error: Can't load dry parameter file - using defaults"
        Else
            Open TPFDRY$(current_unit%) For Input As #fn1
            OpenTPF = True
        End If
    End If
    If OpenTPF Then
        Input #fn1, PULSEWIDTH: Input #fn1, V2INCR
        Input #fn1, BUBLTIME: Input #fn1, BUBLFLOW
        Input #fn1, ZEROTIME: Input #fn1, Maxpres
        Input #fn1, MAXFLOW: Input #fn1, mineqtime
        Input #fn1, PRESSLEW: Input #fn1, flowslew
        Input #fn1, EQITER: Input #fn1, AVEITER
        Input #fn1, MAXPDIF: Input #fn1, MAXFDIF
        Input #fn1, STARTP: Input #fn1, STARTF
        Input #fn1, PulseDelay: Input #fn1, preginc
        On Error Resume Next
        minbppres = 0
        Input #fn1, minbppres
        On Error Resume Next
        Input #fn1, temperatureSetPoint 'AJB 10-21-09
        Input #fn1, temperatureSetPoint 'AJB 10-21-09
        Input #fn1, tC
        temperatureControl = IIf(tC, 1, 0)
        Debug.Print "tempSetPoint"; temperatureSetPoint
        On Error GoTo 0
        Close #fn1
        Maxpres = maxp_set(current_unit%)
    End If

    'save second set of parameters
    If DRYParams = "" Then
    'dry parameters
        DRYParams = "D," + str(V2INCR) + "," + str(preginc) + "," + str(mineqtime) + "," + str(PRESSLEW) + "," + str(flowslew) + "," + str(EQITER) + "," + str(AVEITER) + "," + str(MAXPDIF) + "," + str(MAXFDIF)
    Else
    'bubble point parameters
        BPParams = "B," + str(BUBLFLOW) + "," + str(BUBLTIME) + "," + str(minbppres) + "," + str(ZEROTIME) + "," + str(PulseDelay)
    'wet parameters
        WETParams = "W," + str(V2INCR) + "," + str(preginc) + "," + str(mineqtime) + "," + str(PRESSLEW) + "," + str(flowslew) + "," + str(EQITER) + "," + str(AVEITER) + "," + str(MAXPDIF) + "," + str(MAXFDIF)
    End If

    ' initialize second array
    If first_loop Then
        ReDim second_array.a(100)
        second_array.s = 100
    End If
    First_Curve = False
    If TType%(current_unit%) = 1 And TMode%(current_unit%) = 1 Then
        progress.W_Curve.Caption = ts$(326)         ' "Dry Curve"
        progress.W_Curve.ForeColor = color2
    End If
    points = 0
    DoEvents
    ' move temperature data from temperature1 to temperature2 for safe keeping
    ' while we run the second pass of the test
    For i = 1 To temperature_array_size
        temperature2(i) = temperature1(i)
    Next i
    If TType%(current_unit%) = 1 And TMode%(current_unit%) = 3 Then
        pass = 0
        Setup_2_3 second_array, first_loop
        If LoopingDemo Then        ' CFP loop
            ' we need to put first_array back into second_array since Setup_2_3 swapped them
            ' there has to be room, since that is where it came from
            For i% = 1 To FPOINTS
                second_array.a(i%) = first_array.a(i%)
            Next i%
            SPOINTS = FPOINTS
            waitseconds 15
            nowait_at_beginning = True
            progress.Picture1.Cls
            first_loop = False
            GoTo GPLoopBack
        End If
        Exit Sub
    End If
    If TType%(current_unit%) = 1 And TMode%(current_unit%) = 2 Then
        pass = 2
        If nowait_at_beginning Then
            ' if we don't prompt, we want an extra delay in here to allow things to settle
            ' how about 10 seconds
            waitseconds 10
        End If
        Setup_2_3 second_array
        Exit Sub
    End If
    points = points + 1
    dat_size_check second_array, points
    second_array.a(points).fl = FLAST
    second_array.a(points).pr = plast
    If use_fluid_sensor Then
      ReadXReturnX4 27
      second_array.a(points).fluid = x5 - fluid_sensor_0
    End If
    second_array.a(points).eqd = 0
    second_array.a(points).time = Timer
    took_point_time = Timer
    GMaxP = plast - P0
    GMaxF = FLAST
    pass = 2
    V2FACTR = 1: PWFACTR = 1
    original_v2incr = V2INCR
    V2INCR = -V2INCR
    If V2INCR > -20 Then V2INCR = -20
    NOWHERE% = 0
    PROGRAMCTRL = 3300
    DoEvents
    '
    'Call Zero_Reg
    Run_C_Pass second_array
    close_v2_completely
    geoRegCounts = 0
    geoIncrease = 0
    If LoopingDemo And TType%(current_unit%) = 1 Then        ' CFP loop
        progress.Picture1.Cls
        waitseconds 15
        GoTo GPLoopBack
    End If
    PROGRAMCTRL = 0
    SPOINTS = points
    SquarePores = False
    
    Test_Done
    
    V2INCR = original_v2incr
    
    Unload info_form
    
BadFileNameError:

End Sub

Sub BP_Scr_Refresh(x_array As dat_array)
    Dim i%
    Dim yAxisValue As Single
    
    'Rescale Y Axis
    If BP_AutoDetectMethod = 0 Then
    
        If BP_UsePressureVsTime Then
            yAxisValue = x_array.a(BP_Points).pr - P0
        Else
            yAxisValue = x_array.a(BP_Points).fl
        End If
        
        If yAxisValue > BP_Y_Max Then
            BP_Y_Max = BP_Y_Max * 1.5
            progress.PictureBP.Scale (0, BP_Y_Max)-(BP_X_Max, 0)
            
            If BP_UsePressureVsTime Then
                progress.Y_Max.Caption = LTrim$(RTrim$(Format$(BP_Y_Max, "######0.000")))
            Else
                progress.Y_Max.Caption = LTrim$(RTrim$(Format$(BP_Y_Max, "######0")))
            End If
            
            progress.Refresh
        End If
    Else
        If x_array.a(BP_Points).fl2 > BP_Y_Max Then
            BP_Y_Max = BP_Y_Max * 1.5
            progress.PictureBP.Scale (0, BP_Y_Max)-(BP_X_Max, -BP_Y_Max)
            progress.Y_Max.Caption = LTrim$(RTrim$(Format$(BP_Y_Max, "######0")))
            progress.Y_Zero.Caption = LTrim$(RTrim$(Format$(-BP_Y_Max, "######0")))
            progress.Refresh
        End If
    End If
    
    'Rescale X Axis
    If x_array.a(BP_Points).time > BP_X_Max Then
        BP_X_Max = BP_X_Max * 1.5
        If BP_AutoDetectMethod = 0 Then
            progress.PictureBP.Scale (0, BP_Y_Max)-(BP_X_Max, 0)
        Else
            progress.PictureBP.Scale (0, BP_Y_Max)-(BP_X_Max, -BP_Y_Max)
        End If
        progress.X_Max.Caption = LTrim$(RTrim$(Format$(BP_X_Max, "######0")))
        progress.Refresh
    End If
    
    'Graph all points in the array
    On Error Resume Next
    If BP_AutoDetectMethod = 0 Then
        If BP_UsePressureVsTime Then
            progress.PictureBP.PSet (x_array.a(1).time, x_array.a(1).pr - P0), color3
        Else
            progress.PictureBP.PSet (x_array.a(1).time, x_array.a(1).fl), color3
        End If
        progress.PictureBP.Cls
        For i% = 2 To BP_Points
            If BP_UsePressureVsTime Then
                progress.PictureBP.PSet (x_array.a(i%).time, x_array.a(i%).pr - P0), color3
                progress.PictureBP.Line (x_array.a(i% - 1).time, x_array.a(i% - 1).pr - P0)-(x_array.a(i%).time, x_array.a(i%).pr - P0), color3
            Else
                progress.PictureBP.PSet (x_array.a(i%).time, x_array.a(i%).fl), color3
                progress.PictureBP.Line (x_array.a(i% - 1).time, x_array.a(i% - 1).fl)-(x_array.a(i%).time, x_array.a(i%).fl), color3
            End If
        Next i%
    Else
        progress.PictureBP.PSet (x_array.a(1).time, x_array.a(1).fl2), color3
        progress.PictureBP.Cls
        For i% = 2 To BP_Points
            progress.PictureBP.PSet (x_array.a(i%).time, x_array.a(i%).fl2), color3
            progress.PictureBP.Line (x_array.a(i% - 1).time, x_array.a(i% - 1).fl2)-(x_array.a(i%).time, x_array.a(i%).fl2), color3
        Next i%
    End If
    On Error GoTo 0
    progress.Refresh
End Sub

Sub Scr_Refresh(x_array As dat_array)
    Dim i%
'    progress.Label1.Caption = "cc/m"
'            progress.Label2.Caption = "psi"
'             progress.Y_Max.Caption = Format$(500, "######0")
'             progress.X_Max.Caption = Format$(1, "######0.00")
'             progress.Refresh
    ' we are changing this
    Const maf = 1200#  'maximum air flow on Low flow instruments used to get around warning message
    If (MaxAirFlow > maf) And (f >= 0.75 * MaxAirFlow) Then FlowFlag = True
    'Rescale Y Axis
    If f >= GMaxF And First_Curve Then
        While f > GMaxF
            GMaxF = GMaxF * 1.5
        Wend
        progress.Picture1.Scale (0, GMaxF / 1000)-(GMaxP, 0)
        progress.Y_Max.Caption = LTrim$(RTrim$(Format$(GMaxF, "######0")))
        progress.Refresh
    End If
    'Rescale X Axis
    If P - P0 >= GMaxP And First_Curve Then
        While P - P0 > GMaxP
            GMaxP = GMaxP * 1.5
        Wend
        progress.Picture1.Scale (0, GMaxF / 1000)-(GMaxP, 0)
        progress.X_Max.Caption = LTrim$(RTrim$(Format$(GMaxP * PCNV, "######0.00")))
        progress.Refresh
    End If
    
    'Graph all points in the array
    On Error Resume Next
    If First_Curve Then
        progress.Picture1.PSet (x_array.a(1).pr - P0, x_array.a(1).fl / 1000), color1
        LastPr = x_array.a(1).pr: LastFl = x_array.a(1).fl
        progress.Picture1.Cls
        For i% = 2 To points
            progress.Picture1.PSet (x_array.a(i%).pr - P0, x_array.a(i%).fl / 1000), color1
            progress.Picture1.Line (LastPr - P0, LastFl / 1000)-(x_array.a(i%).pr - P0, x_array.a(i%).fl / 1000), color1
            LastPr = x_array.a(i%).pr: LastFl = x_array.a(i%).fl
        Next i%
    Else
        progress.Picture1.PSet (x_array.a(points).pr - P0, x_array.a(points).fl / 1000), color2
        progress.Picture1.Line (LastPr - P0, LastFl / 1000)-(x_array.a(points).pr - P0, x_array.a(points).fl / 1000), color2
        LastPr = x_array.a(points).pr: LastFl = x_array.a(points).fl
    End If
    On Error GoTo 0
    progress.Refresh
End Sub
Sub Send_RS232(db$)

    Dim NUMBADCOM As Integer
    Dim RETCODE&, temp$
    
    'DoEvents
    NUMBADCOM = 0
56020:
    RETCODE& = RSEcho(db$, 0)
    If RETCODE& = 0 And NUMBADCOM = 0 Then
        db$ = ""
        Exit Sub
    End If
    If RETCODE& <> 0 Then
        temp$ = ts$(334) + " " + Format$(RETCODE&)      ' "Error in RS232 system.  Return code was"
        MsgBox temp$, 53, ts$(335)                      ' "Control RS232 System"
    End If
    NUMBADCOM = NUMBADCOM + 1
    If RETCODE& <> 0 Then GoTo 56020 Else db$ = ""
    
End Sub

Sub Send_RS232i(db$, i As Integer)

    Dim NUMBADCOM As Integer
    Dim RETCODE&, temp$
    
    'DoEvents
    NUMBADCOM = 0
56020:
    RETCODE& = RSEchoi(db$, i, 0)
    If RETCODE& = 0 And NUMBADCOM = 0 Then
        db$ = ""
        Exit Sub
    End If
    If RETCODE& <> 0 Then
        temp$ = ts$(334) + " " + Format$(RETCODE&)      ' "Error in RS232 system.  Return code was"
        MsgBox temp$, 53, ts$(335)                      ' "Control RS232 System"
    End If
    NUMBADCOM = NUMBADCOM + 1
    If RETCODE& <> 0 Then GoTo 56020 Else db$ = ""
    
End Sub

Sub Send_RS232l(db$, L As Long)

    Dim NUMBADCOM As Integer
    Dim RETCODE&, temp$
    
    'DoEvents
    NUMBADCOM = 0
56020:
    RETCODE& = RSEchol(db$, L, 0)
    If RETCODE& = 0 And NUMBADCOM = 0 Then
        db$ = ""
        Exit Sub
    End If
    If RETCODE& <> 0 Then
        temp$ = ts$(334) + " " + Format$(RETCODE&)      ' "Error in RS232 system.  Return code was"
        MsgBox temp$, 53, ts$(335)                      ' "Control RS232 System"
    End If
    NUMBADCOM = NUMBADCOM + 1
    If RETCODE& <> 0 Then GoTo 56020 Else db$ = ""
    
End Sub

Sub Send_RS232b(db$, b As Byte)

    Dim NUMBADCOM As Integer
    Dim RETCODE&, temp$
    
    'DoEvents
    NUMBADCOM = 0
56020:
    RETCODE& = RSEchob(db$, b, 0)
    If RETCODE& = 0 And NUMBADCOM = 0 Then
        db$ = ""
        Exit Sub
    End If
    If RETCODE& <> 0 Then
        temp$ = ts$(334) + " " + Format$(RETCODE&)      ' "Error in RS232 system.  Return code was"
        MsgBox temp$, 53, ts$(335)                      ' "Control RS232 System"
    End If
    NUMBADCOM = NUMBADCOM + 1
    If RETCODE& <> 0 Then GoTo 56020 Else db$ = ""
    
End Sub

Sub Set_Regulator_Speed()
Rem set the speed of the regulator based on the current position
Rem of the regulator.  At the lower limit we use a pulsewidth of
Rem 12.  At the upper limit we use 4.  We scale in between.  ]
Rem Looks like we may need to change this often !! Different regulators behave
Rem differently at higher / lower output pressures

Rem new: use reg_pulse_min and reg_pulse_max

    Dim RegSpeed%

    If Not newreg Then MsgBox ("Illegal Subroutine Call")
    REGPOS = raw_reading(18)
    If REGPOS <= reg_cl Then
        RegSpeed% = reg_pulse_min
    ElseIf REGPOS >= reg_ol Then
        RegSpeed% = reg_pulse_max
    Else
        RegSpeed% = (REGPOS - reg_cl) * CSng(reg_pulse_max - reg_pulse_min) / (reg_ol - reg_cl) + reg_pulse_min
    End If
    Send_RS232 ("J" + Chr$(RegSpeed%))

End Sub

Sub set_lfctrl(ByVal i As Integer)
' set the low flow controller to the value of i

    If i < 0 Then i = 0
    If i > 4000 Then i = 4000
    If i = 0 Then
        zero_lfctrl
        Exit Sub
    End If
    If i = lfcpos Then Exit Sub
    If i > lfcpos Then
        inc_lfctrl i - lfcpos
    Else
        lower_lfctrl lfcpos - i
    End If

End Sub
Sub set_low_flow_rate(f As Single)
' set i to count value based on flow rate
' assume 0 counts = 0 flow rate
' and 4000 counts = maximum flow rate for low flow meter

    Dim i As Integer

    i = 0
    While f > flow_cal(i) And i < 40
        i = i + 1
    Wend
    set_lfctrl i * 100
    
End Sub

Sub SetLowFlow()
' this is the low flow meter/controller calibration part of the
' Adjust Flow Parameters calibration

    Dim RestartTest2 As Single
    Dim k As Single
    Dim T As Single
    Dim filenum As Integer
    Dim best_flow#, j&, jx&, CL&
    Dim FX4 As Long
    Dim LX4 As Long
    Dim v2posx4 As Long
    Dim regusing As Integer
    Dim i As Integer
    Dim last_lfcpos As Integer
    'AJB 10-30-09
    Move_Valve 0, "O"
    
    Msgform.Label1.Caption = ts$(336)           ' "Initializing low flow calibration"
    Msgform.Label1.Visible = True
    Msgform.Refresh
    Do
        If dualregulator Then
            regusing = 1
            Move_Valve 16, "C"
            regnum = 0
            If (air_inlets = 2) Then
                Move_Valve 15, "C"
                current_air_inlet = 1
            End If

        End If
        RestartTest2 = 0
do_next_regulator:
        'k = Timer
        best_flow# = 0
        'While (Timer - k < 1) And (Timer >= k): DoEvents: Wend
        waitseconds 1
        Msgform.Label1.Caption = ts$(337)       ' "Initializing valve 2"
        Msgform.Refresh
        excercize_valve_2
        HFLOW% = 1
        ' we don't open the file if we are on the second pass
        If Not dualregulator Or regusing = 1 Then
            filenum = FreeFile
            Open EXE_Path$ + "capcal.tmp" For Output As #filenum
            ' new header for low flow controller
            If low_flow_controller Then
                Print #filenum, "-7,-7"
            End If
        End If
        If low_flow_controller Then
            If PA = 0 Then
                SHFP = 100
                SBPP = 1000
            Else
                Msgform.Label.Caption = ts$(338)        ' "Finding proper regulator setting"
                ' first, find the regulator settings
                SHFP = 0
                SBPP = 0
                Zero_Reg
                set_lfctrl 4000 ' set low flow controller to full scale
                ' flow won't go up because there is no pressure on the regulator
                Move_Valve 0, "O"
                If hasMultipleMVs Then
                    ManualControl1.show_valve_open 1
                Else
                    ManualControl.show_valve_open 1
                End If
                ' increase regulator until flow is over 10% of full scale
                k = Timer
                'AJB 10-30-09
                Move_Valve 0, "O"
                Do
                    If newreg Then
                        REGPOS = raw_reading(18) ' just in case we ever use a motorized regulator with a low flow controller
                    End If
                    ReadXReturnX4 0
                    Msgform.Label1.Caption = ts$(315) + "+ " + Format$(REGPOS) + "  " + ts$(209) + "=" + Format$(x5) + " (" + Format$(x4) + ")"       ' "Regulator"/"Low Flow"
                    Msgform.Refresh
                    ' set SHFP to regpos until flow over 10%
                    If x4 < DAC_span / 10 + DAC_zero Then SHFP = REGPOS
                    ' increment regulator every second until flow over 100%
                    If (Timer - k > 1) Or (Timer < k) Then
                        inc_reg 10
                        k = Timer
                    End If
                    DoEvents
                Loop Until x4 >= DAC_two And REGPOS < 4000
                SBPP = REGPOS
                ' leave the regulator at this position, but zero the controller
                zero_lfctrl
                
                ' wait for low flow reading to stabilize downward
                Msgform.Label.Caption = ts$(339)                            ' "Waiting for lowest flow"
                k = Timer
                LX4 = x4
                Do
                    ReadXReturnX4 0
                    Msgform.Label1.Caption = ts$(209) + "=" + Format$(x5) + " (" + Format$(x4) + ")"   ' "Low Flow"
                    Msgform.Refresh
                    If LX4 > x4 Then
                        LX4 = x4
                        k = Timer
                    End If
                Loop Until (Timer - k) > 3
                Msgform.Label.Caption = ts$(340) + "..."        ' "Calibrating Flow Meters"
            End If
            Print #filenum, str$(SHFP)
            Print #filenum, str$(SBPP)
            If dualregulator And regusing = 2 Then
                GoTo done_reg2
            End If
        End If
        If GasPerm Or PA = 0 Then
            If low_flow_controller Then
                For i = 0 To 40
                    Print #filenum, str$(i * FY2(0, 0) * gasflowconversionfactor / 40)
                Next i
            Else
                Print #filenum, "0,.05"
                Print #filenum, "1,1"
                Print #filenum, "2,2"
                Print #filenum, "3,100"
                Print #filenum, "-1,-1"
            End If
        Else
            Move_Valve 0, "O"
            If hasMultipleMVs Then
                ManualControl1.show_valve_open 1
            Else
                ManualControl.show_valve_open 1
            End If
1040        Rem first, wait 1 second minimum
            'k = Timer
            'While (Timer - k < 1) And (Timer >= k): DoEvents: Wend
            waitseconds 1
            ReadXReturnX4 0
            LX4 = x4
            k = Timer
1045        ReadXReturnX4 0
            Msgform.Label1.Caption = ts$(209) + "=" + Format$(x5) + " (" + Format$(x4) + ")"           ' "Low Flow"
            Msgform.Refresh
            DoEvents
            ' reset if flow went higher or if flow dropped by more than 2% of full scale
            ' also reset if flow is too low - 4 counts on any DAC should be ok.  This would
            ' be caused by a temporary drop in system pressure which could be caused by
            ' the I/P converter doing something strange
            If x4 < LX4 - DAC_span / 30 Or x4 > LX4 Or x4 < 4 Then
                LX4 = x4
                k = Timer
                GoTo 1045
            End If
            If (Timer + 0.1 < k) Then k = k - 86400
            If (Timer - k) < 2 Then GoTo 1045
            LX4 = x4
            If low_flow_controller Then
                ' 6.71.28 making it work better with new style flow controllers
                ' if we are above 0 counts and the reading is less than 1% of full scale
                ' we may want to raise the target until the flow responds and then lower it
                ' back down and wait for a new stable value
                If lfcpos > 0 And (x4 - DAC_zero) < (DAC_span / 100) And lfcpos < 2000 Then
                    ' kick it up to 50% of full scale until the flow reading goes
                    ' above 2%
                    last_lfcpos = lfcpos ' remember current lfcpos
                    inc_lfctrl 2000 - lfcpos
                    k = Timer
                    Do
                        ReadXReturnX4 0
                        Msgform.Label1.Caption = ts$(209) + "=" + Format$(x5) + " (" + Format$(x4) + ")"           ' "Low Flow"
                        If (x4 - DAC_zero) > (DAC_span / 50) Then Exit Do
                        If (Timer + 0.1) < k Then k = k - 86400
                    Loop Until (Timer - k) > 30 ' 30 second timeout probably won't happen
                    ' lower back down to original value
                    lower_lfctrl lfcpos - last_lfcpos
                    ' wait until flow hasn't gone lower in 5 seconds
                    ReadXReturnX4 0
                    LX4 = x4
                    k = Timer
                    Do
                        ReadXReturnX4 0
                        Msgform.Label1.Caption = ts$(209) + "=" + Format$(x5) + " (" + Format$(x4) + ")"           ' "Low Flow"
                        Msgform.Refresh
                        DoEvents
                        If x4 < LX4 Then
                            LX4 = x4
                            k = Timer
                        End If
                        If (Timer + 0.1 < k) Then k = k - 86400
                    Loop Until (Timer - k) > 5
                End If
                Msgform.Label1.Caption = ts$(341) + "=" + Format$(lfcpos) + "  " + ts$(209) + "=" + Format$(x5) + " (" + Format$(x4) + ")" ' "Controller"/"Low Flow"
                Msgform.Refresh
                Print #filenum, str$(x5)
                If lfcpos < 4000 Then
                    inc_lfctrl 100
                    GoTo 1040
                End If
                zero_lfctrl
            Else
                If newreg Then
                    REGPOS = raw_reading(18)
                End If
                If x5 > best_flow# Then
                    Msgform.Label1.Caption = ts$(315) + "=" + Format$(REGPOS) + "  " + ts$(209) + "=" + Format$(x5) + " (" + Format$(x4) + ")" ' "Regulator"/"Low FLow"
                    Msgform.Refresh
                    Print #filenum, str$(REGPOS); ","; str$(x5)
                    best_flow# = x5
                End If
                If x5 <= 0.2 Then SHFP = REGPOS
                If ip_reg_enable Then
                    inc_reg 20
                Else
                    inc_reg 1
                End If
                DoEvents
                If LX4 < DAC_over Then GoTo 1040
                If newreg Then
                    If SHFP < reg_cl Then SHFP = reg_cl
                ElseIf ip_reg_enable Then
                    If SHFP < 40 Then SHFP = 40
                Else
                    If SHFP < 3 Then SHFP = 3
                End If
                Print #filenum, "-1,-1"
            End If
            Move_Valve 0, "C"
            If hasMultipleMVs Then
                ManualControl1.show_valve_closed 1
            Else
                ManualControl.show_valve_closed 1
            End If
        End If
        If dualregulator And regusing = 1 Then
            regusing = 2
            Msgform.Label1.Caption = ts$(342)       ' "Preparing for calibration with regulator 2 - zeroing regulator 1"
            Msgform.Refresh
            Zero_Reg
            Move_Valve 16, "O"
            regnum = 1
            Move_Valve 15, "O"
            current_air_inlet = 2
            GoTo do_next_regulator
        End If
done_reg2:
        If itester Or PA = 0 Or BPTester Or v2solenoid Then
            Print #filenum, str$(SV2P)
        Else
            Msgform.lb.Visible = False
            Msgform.Label.Caption = ts$(343) + "..."    ' "Setting First Flow"
            Msgform.Refresh
            Msgform.Label1.Caption = ts$(344)           ' "Waiting for system to settle"
            Msgform.Refresh
            'T = Timer
            'While Timer - T < 10: DoEvents: Wend
            waitseconds 10
            Msgform.Label1.Caption = ts$(345)           ' "Setting regulator to high pressure"
            Msgform.Refresh
            If newreg Then
                reg_goto (reg_ol)
            Else
                If dualregulator Then
                    If ip_reg_enable Then
                        inc_reg 2000 - REGPOS
                    Else
                        While REGPOS < 50
                            inc_reg 1
                        Wend
                    End If
                ElseIf ip_reg_enable Then
                    inc_reg 4000 - REGPOS
                Else
                    While REGPOS < 300
                        inc_reg 1
                    Wend
                End If
            End If
            ReadXReturnX4 1
            FX4 = x4
            LX4 = x4
            ReadXReturnX4 3
            SV2P = x4
            
1150        Send_RS232 ("I" + mv1_index_char)
            ReadXReturnX4 3
            v2posx4 = x4
            If x4 >= oLimit - DAC_span / 200 Then
                Beep
                MsgBox ts$(346) + vbCrLf + ts$(347), 32, ts$(348)       ' "Calibration"      ' "The air compressor seems to be disconnected."/"Please connect it."/
                Close #filenum
                Zero_Reg
                RestartTest2 = 1
            Else
                ReadXReturnX4 1
                If LX4 >= x4 Then SV2P = v2posx4
                LX4 = x4
                Msgform.Label1.Caption = ts$(349) + "=" + Format$(v2posx4) + " " + ts$(30) + "=" + Format$(x5) + " (" + Format$(x4) + ")"       '  "Position"/"Flow"
                Msgform.Refresh
                If x4 <= FX4 + DAC_span / 80 Then GoTo 1150
                ReadXReturnX4 3
                Print #filenum, str$(SV2P)
                Msgform.Label1.Caption = ts$(350) + " - " + ts$(33)     ' "Finished - zeroing regulator"
                Msgform.Refresh
                Zero_Reg
            End If
        End If
    Loop While (RestartTest2 = 1)
    If dualregulator Then
        Move_Valve 16, "C"
        regnum = 0
        If (air_inlets = 2) Then
            Move_Valve 15, "C"
            current_air_inlet = 1
        End If
        
    End If
    'k = Timer
    'While (Timer - k < 1) And (Timer >= k): DoEvents: Wend
    waitseconds 1
    Msgform.Label1.Caption = ts$(11)                        ' "Closing valve 2"
    Send_RS232 ("C" + mv1_index_char)
    CL& = DAC_over
    T = Timer
1340 ReadXReturnX4 3
    DoEvents
    If x4 < CL& Then
        CL& = x4
        T = Timer
    End If
    Msgform.Label1.Caption = ts$(208) + ": f=" + Format$(x5) + " (" + Format$(x4) + ")"    '  "Waiting for stable values"
    Msgform.Refresh
    If Timer + 0.1 < T Then T = T - 86400!
    If x4 > DAC_zero + DAC_span / 200 And (Timer - T < 5) Then GoTo 1340
    Close #filenum
    On Error Resume Next
    Kill EXE_Path$ + "capcal.bak" ' ignore error
    Name EXE_Path$ + "capcal.d8a" As EXE_Path$ + "capcal.bak" ' ignore error
    Err.clear
    Name EXE_Path$ + "capcal.tmp" As EXE_Path$ + "capcal.d8a"
    If Err.Number <> 0 Then
        MsgBox ts$(351)             ' "Problem renaming calibration file - your new calibration is in the capcal.tmp file.  Rename this to capcal.d8a to set it to the active calibration."
    End If
    On Error GoTo 0
    
End Sub

Sub setNewTemperature(i As Integer, T As Single)
If i = 1 Or i = 2 Then
    Send_RS232i ";", Int(T * 10)
' i=2 does not have a defined temperature setting method
ElseIf i >= 3 And i <= 8 Then
    ' set through rabbit board
    setRabbitTemperature i - 3, T
ElseIf i < 0 Then
    ' set through aux com port (A if i=-1, -3, etc., B if i=-2, -4, etc.)
    setExternalWatlowTemperature (i And 1) + 1, T
End If
End Sub

Sub setExternalWatlowTemperature(channel As Integer, T As Single)
' channel is 1 or 2
On Error Resume Next
If TitleScrn.AuxComm.PortOpen = False Then
    TitleScrn.AuxComm.PortOpen = True
    If Err.Number <> 0 Then
        Exit Sub
    End If
End If
TitleScrn.AuxComm.Output = "= SP" + Format$(channel) + " " + Format$(T, "###0.0") + Chr$(13)
End Sub

Sub setRabbitTemperature(channel As Integer, T As Single)
    Dim getChar$, sendChar$, chanChar$, a$, i As Integer
    Dim viaModbus As Boolean
    
    ' channel is 0, 1, 2, 3, 4, or 5
    If channel < 2 Then
        sendChar$ = ">"
        getChar$ = "<"
        viaModbus = watlowViaModbus(1)
    ElseIf channel < 4 Then
        sendChar$ = "}"
        getChar$ = "{"
        viaModbus = watlowViaModbus(2)
    Else
        sendChar$ = "]"
        getChar$ = "["
        viaModbus = watlowViaModbus(3)
    End If
    
    If viaModbus Then
        setWatlowViaModbus channel, T, getChar$, sendChar$
    Else
        If (channel And 1) = 0 Then
            chanChar$ = "1"
        Else
            chanChar$ = "2"
        End If
        
        a$ = "= SP" + chanChar$ + " " + Format$(T, "###0.0") + Chr$(13)
        For i = 1 To Len(a$)
            Send_RS232 sendChar$ + Mid$(a$, i, 1)
        Next i
    End If
End Sub

Sub setStatusLights(value As Integer)
' 0 is off, 1 if red, 2 is yellow
' first, make sure that speed is set to full so we get the brightest light
Send_RS232b "sA", 255
If value = 1 Then
    Send_RS232 "MAF"
ElseIf value = 2 Then
    Send_RS232 "MAR"
Else
    Send_RS232 "MAS"
End If
End Sub

Sub Setup_2_3(x_array As dat_array, Optional first_loop As Boolean = True)
' if first_loop is false, we don't actually run the second pass, since x_array already
' contains all the data from the previous loop

    Dim T As Single
    Dim tempfl As Single
    Dim i%, j%, TE%, tt, hh As Single
    Dim P0First As Single
    Dim fn1 As Integer
    Dim TDAT As pfdata2
    Dim original_nowait_at_beginning As Boolean
    Dim Index As Integer
    
    ' special case of wet up sample requiring some but not all load prompts
    ' remember the original so we can set it back after they saturate
    original_nowait_at_beginning = nowait_at_beginning
    If TType%(current_unit%) = 1 And TMode%(current_unit%) = 3 And first_loop Then
        nowait_at_beginning = False ' must prompt for loading saturated sample
    End If
    
    If first_loop Then
        Init_System
        P0First = P0         '  Keep track of p0 value for first run
        lock_p0 = False
        If status_lights_enable Then setStatusLights 1
        
        If (TType%(current_unit%) = 1) And (TMode%(current_unit%) = 3) And auto_wet_enable And auto_wet_used And (number_of_wetting_valves > 0) And (auto_wet_wet_time > 0) Then
            For Index = 1 To number_of_wetting_valves
                auto_wet_sample wetting_valve(Index)
                nowait_at_beginning = True
            Next Index
        End If
        
        If nowait_at_beginning = False Then
            ' if compression, must raise the piston here so they can wet the sample
            If (autocompress Or autopiston Or (FrazierPiston And FrazierRunning)) And recirculation Then
                safety_canceled = False
                If safetyup And Vpos(15) = 1 Then
                    If safetyupdoor Then
                        ' do auto door switch thing instead of key press thing
                        check_safety_door True ' we can cancel this
                    Else
                        safetykeypress.mainlabel.Caption = ts$(166)     ' "Piston About To Raise"
                        safetykeypress.Show 1
                    End If
                End If
                If Not safety_canceled Then
                    move_piston "C"
                End If
            End If
            If doorlock Then
                If temperatureControl Then
                    Dim temp As Single
                    'read watlow
                    temp = readNewTemperature((dryChamberTemperature), False)
                    If temp > safe_temperature Then
                        
                        MsgBox "Temperature is greater than safe temperature. Press Ok to start flowing gas to bring temperature down."
                        
                        'open v2
                        openv2completely
                        
                        'zero regulator
                        Zero_Reg
                        
                        'set regulator to 10% to cool the chamber
                        inc_reg 400
                        'MsgBox "Set Temperature to zero"
                        setNewTemperature (dryChamberTemperature), 0
                        setNewTemperature (airTemperature), 0
                        
                        Status.Label1.Caption = "Lowering chamber temperature to: " + str$(safe_temperature)
                        Status.Label2.Caption = ""
                        Status.Label1.Visible = True
                        Status.Label2.Visible = True
                        Status.Label3.Caption = ""
                        Status.Command1.Enabled = True
                        Status.Command1.Visible = False
                        
                        Status.Show
                        
                        While temp > safe_temperature
                            temp = readNewTemperature((dryChamberTemperature), False)
                            Status.Label2.Caption = "Current Chamber Temp: " + str$(temp) + " C"
                            waitseconds 1
                            DoEvents
                        Wend
                        
                        Status.Command1.Visible = True
                        
                        Status.Hide
                        
                        'zero regulator
                        Zero_Reg
                        
                        Move_Valve 2, "O"
                        
                        waitseconds 5
                        
                        Move_Valve 2, "C"
                        
                        close_v2_completely
                        
                        ' must allow them to open the door now
                        If MsgBox(ts$(463), vbYesNo) = vbYes Then       ' "Do you want to open the door now?"
                            Send_RS232 ("O@")
                            Move_Valve 2, "O"
                            MsgBox ts$(478)     ' "Open Door Now"
                            Load_Sample x_array
                            Move_Valve 2, "C"
                            Send_RS232 ("C@")
                        End If
                                    
                        If MsgBox("Set Watlow back to temperature set point?", vbYesNo) = vbYes Then
                            'Determine number of active chambers
                            Dim numberOfChambers As Integer
                            MsgBox "reset temp to: " + str$(temperatureSetPoint)
                            If dryChamberTemperature <> 0 And airTemperature = 0 Then
                                numberOfChambers = 1
                                setNewTemperature (dryChamberTemperature), temperatureSetPoint
                            ElseIf dryChamberTemperature <> 0 And airTemperature <> 0 Then
                                numberOfChambers = 2
                                setNewTemperature (dryChamberTemperature), temperatureSetPoint
                                setNewTemperature (airTemperature), temperatureSetPoint
                            End If
                
                            'Enter the proper temperature control routine
                            doTemperatureControl numberOfChambers
                        End If
                    End If
                    
                Else
                    ' must allow them to open the door now
                    If MsgBox(ts$(463), vbYesNo) = vbYes Then       ' "Do you want to open the door now?"
                        Send_RS232 ("O@")
                        Move_Valve 2, "O"
                        MsgBox ts$(478)     ' "Open Door Now"
                        Load_Sample x_array
                        Move_Valve 2, "C"
                        Send_RS232 ("C@")
                    End If
                
                End If
                
                
            End If
        End If
        
        Move_Valve 2, "O"
        Load_Sample x_array
        Move_Valve 2, "C"
        
        
        Rem P0 now equals the P0 for the second part of the test
        Rem this is the P0 for the dry test unless TMode%=3, in which case
        Rem it is the P0 for the wet test
        If TMode%(current_unit%) = 2 Then progress.W_Curve.Caption = ts$(326)   ' "Dry Curve"
        If TMode%(current_unit%) = 3 Then progress.W_Curve.Caption = ts$(325)   ' "Wet Curve"
        progress.W_Curve.ForeColor = color2
        DoEvents
        If Aborted Then Exit Sub
    
        NOWHERE% = 0
        If status_lights_enable Then setStatusLights 2
        ' now, before we actually start this pass of the test, set the load prompt
        ' back to what it was
        nowait_at_beginning = original_nowait_at_beginning
        Run_C_Pass x_array
        SPOINTS = points
        DoEvents
    Else
        pass = 1
    End If

    ' now massage data in second_array to make it compatible with results
    ' normally found with running type 1 tests
    ' if did dry first, swap files so dry becomes second
    If TMode%(current_unit%) = 3 Then
        ' make sure each array can hold the results of the
        ' other array
        dat_size_check first_array, SPOINTS
        dat_size_check second_array, FPOINTS
        points = FPOINTS
        If SPOINTS < points Then points = SPOINTS
        ' for smallest, swap items
        For i% = 1 To points
            TDAT = first_array.a(i%)
            first_array.a(i%) = second_array.a(i%)
            second_array.a(i%) = TDAT
        Next i%
        ' for rest, just copy items
        If FPOINTS > points Then
            For i% = points + 1 To FPOINTS
                second_array.a(i%) = first_array.a(i%)
            Next i%
        ElseIf SPOINTS > points Then
            For i% = points + 1 To SPOINTS
                first_array.a(i%) = second_array.a(i%)
            Next i%
        End If
        points = SPOINTS
        SPOINTS = FPOINTS
        FPOINTS = points
        Rem swap P0 and p0first so that p0first equals the P0 for the wet test
        T = P0
        P0 = P0First
        P0First = T
    ElseIf TMode%(current_unit%) <> 4 Then
        ' if not calculated dry, then did dry last and temperature data for dry is in temperature1
        Rem so swap temperature1 and temperature2
        If dryChamberTemperature <> 0 Then
            For i% = 1 To temperature_array_size
                T = temperature1(i%)
                temperature1(i%) = temperature2(i%)
                temperature2(i%) = T
            Next i%
        End If
        ' temperature1 now holds wet curve temperature data
        ' and temperature2 holds dry curve temperature data
    End If

    ' now swap order of second points, fixing dry
    ' pressures if there is a different p0first than p0.
    DoEvents
    For i% = 1 To Int(SPOINTS / 2 + 0.6)
        j% = SPOINTS - i% + 1
        tempfl = second_array.a(i%).fl
        T = second_array.a(i%).pr - P0 + P0First
        TE% = second_array.a(i%).eqd
        tt = second_array.a(i%).time
        hh = second_array.a(i%).humidity
        
        second_array.a(i%).pr = second_array.a(j%).pr - P0 + P0First
        second_array.a(i%).eqd = second_array.a(j%).eqd
        second_array.a(i%).fl = second_array.a(j%).fl
        second_array.a(i%).time = second_array.a(j%).time
        second_array.a(i%).humidity = second_array.a(j%).humidity
        
        second_array.a(j%).fl = tempfl
        second_array.a(j%).pr = T
        second_array.a(j%).eqd = TE%
        second_array.a(j%).time = tt
        second_array.a(j%).humidity = hh
        
    Next i%
    If dryChamberTemperature <> 0 Then
        For i% = 1 To Int(SPOINTS / 2 + 0.6)
            j% = SPOINTS - i% + 1
            T = temperature2(i%)
            temperature2(i%) = temperature2(j%)
            temperature2(j%) = T
        Next i%
    End If
    Rem set P0 to equal P0first because this was P0 for first run
    Rem and second run has been changed to reflect this P0
    P0 = P0First

    Test_Done
    
End Sub

Sub setup_simple_qc_mode()
    TitleScrn.Hide
    qcmain.Show
End Sub

Sub SetV2Limits()

    Static OldPW
    
    
    OldPW = PULSEWIDTH
    If PA = 0 Then Exit Sub
    If nov2 Then Exit Sub
    If geoPoreValve = True Or skipLimits = True Then
        Exit Sub
    End If
    ReadXReturnX4 16
    cLimit = x4 + valve_limit_offset
    ReadXReturnX4 17
    ' show error message if olimit is over 65000 counts (or close to that)
    If x4 > DAC_over - (DAC_span / 120) Then MsgBox "Warning:  Valve 2 open limit may be too high for proper operation of the valve"
    oLimit = x4 - (DAC_span / 20) - valve_limit_offset

    WPPS "Capstuff", "OLIMIT", str$(oLimit), CSFile$
    WPPS "Capstuff", "CLIMIT", str$(cLimit), CSFile$
    PULSEWIDTH = OldPW
    
    If hasMultipleMVs Then SetAuxV2Limits
        
End Sub
'AJB 12-15-09
Sub SetAuxV2Limits()
    
    If PA = 0 Then Exit Sub
    If Not hasMultipleMVs Then Exit Sub
    
    ReadXReturnX4 32
    CLIMIT2 = x4 + valve_limit_offset
    ReadXReturnX4 33
    ' show error message if olimit is over 65000 counts (or close to that)
    If x4 > DAC_over - (DAC_span / 120) Then MsgBox "Warning:  Aux Valve 2 open limit may be too high for proper operation of the valve"
    olimit2 = x4 - (DAC_span / 20) - valve_limit_offset

    WPPS "Capstuff", "OLIMIT2", str$(olimit2), CSFile$
    WPPS "Capstuff", "CLIMIT2", str$(CLIMIT2), CSFile$
    
    If numberOfMotorValves > 2 Then
        ReadXReturnX4 25
        CLIMIT3 = x4 + valve_limit_offset
        
        ReadXReturnX4 26
        If x4 > DAC_over - (DAC_span / 120) Then MsgBox "Warning:  MV3 open limit may be too high for proper operation of the valve"
        olimit3 = x4 - (DAC_span / 20) - valve_limit_offset
        
        WPPS "Capstuff", "OLIMIT3", str$(olimit3), CSFile$
        WPPS "Capstuff", "CLIMIT3", str$(CLIMIT3), CSFile$
    End If
End Sub
Function shorten(s As String) As String

    Dim i As Integer, a$
    
    If Testscrn.TextWidth(s) < Testscrn.Label2.Width Then
        shorten = s
    Else
        For i = 2 To Len(s) - 1
            a$ = ".." + Mid$(s, i)
            If Testscrn.TextWidth(a$) < Testscrn.Label2.Width Then Exit For
        Next i
        shorten = a$
    End If

End Function

Public Function File_Exists(filepath As String) As Boolean
    File_Exists = ((GetFileAttributes(filepath)) <> -1)
End Function

Function splitString(a$, split$) As SplitStringResult
' Take a string a$ delimited by character split$
' Result type SplitStringResult consists of the number of fields (numberOfValues)
' and the values themselves in the values() array, which must be dimensioned before
' being filled.

    Dim count As Integer
    Dim position As Integer
    
    If Len(a$) = 0 Then
        count = 0
    Else
        count = 1           ' There is at least one field
        ' This procedure is not very efficient, but right now it is only called once
        ' per file, so it shouldn't really affect performance.
        position = InStr(a$, split$)
        While position > 0
            ReDim Preserve splitString.values(count)
            splitString.values(count) = Left$(a$, position - 1) ' Locate the next string
            a$ = Right$(a$, Len(a$) - position)                 ' Truncate the source
            count = count + 1
            position = InStr(a$, split$)
        Wend
        ' Pick up the last value
        ReDim Preserve splitString.values(count)
        splitString.values(count) = a$
    End If
    
    splitString.numberOfValues = count
    
End Function

Sub SWAP(index1 As Integer, index2 As Integer, da As pf_array)
    
    Dim temp As pfdata
    
    temp = da.a(index1)
    da.a(index1) = da.a(index2)
    da.a(index2) = temp

End Sub

Sub test_compression_pressure(P As Single)
' this tests to make sure that the compression pressure is high enough to withstand the
' current pressure inside the sample chamber
' if not, it bumps the compression pressure up a bit
' Pass the differential pressure in p
Dim Temp_X5 As Single
Dim temp_x4 As Long
Temp_X5 = x5
temp_x4 = x4
ReadXReturnX4 35
If (x5 - 14.7) < compression_pressure + P * Compression_Increase_Factor Then inc_creg 20
x5 = Temp_X5
x4 = temp_x4
End Sub
Sub Test_Done()

    Dim i%, j%, n%, fstr$, pstr$, outStr$
    Dim fn1 As Integer
    Dim P As Single
    Dim current_f As Single
    Dim current_p As Single
    Dim current_perm As Single
    Dim xf As Single
    Dim min_v_seen As Long
    Dim min_seen_at As Single
    Dim fn As Integer
    Dim first_point As Boolean
    Dim ds$
    Dim pt As pfdata2
    Dim fn2 As Integer
    Dim k As Single
    Dim retval As Double
    Dim l1 As Long, l2 As Long
    Dim a$
    Dim rval As Single
    Dim EJP0, EJP1 As Single
    BUBLFLOW = oldBloop
    'Dim setLeft As Integer
    If BPPostPurge = True Then
        Load BPPurgeDialog
        BPPurgeDialog.Show
    End If
    close_v2_completely
    If geoPoreValve = True Then
        Move_GeoValves "C"
        geoValveClosed = True
    End If
    
    If status_lights_enable Then setStatusLights 1
    Set_Athena Athena2Channel, 0
    Set_Athena Athena1Channel, 0
    ' 6.71.102 switch back to air inlet 1, if necessary
    If air_inlets > 1 And current_air_inlet = 2 Then
        Move_Valve 15, "C"
        current_air_inlet = 1
    End If
    
    'AJB 11-02-09
    If zeroTempAtEndOfTest And dryChamberTemperature <> 0 And recirculation = False Then setNewTemperature dryChamberTemperature, 0
    If zeroTempAtEndOfTest And airTemperature <> 0 And recirculation = False Then setNewTemperature airTemperature, 0
    

'    If special_ambient Then
'        Move_Valve 0, "C"
'        Move_Valve 2, "O"
'        Dry_Chamber_Control "O"
'        Move_Valve 8, "C"
'    End If
    ' don't release the compression pressure just yet
'    If autocompress And TType%(current_unit%) <> 4 Then
'        move_piston "C"
'    End If
710 If TType%(current_unit%) = 2 And TMode%(current_unit%) = 3 Then
        Rem end of HydroHead test
        If externalhydrohead Then
            ' open external vent valve
            Move_Valve 13, "O"
            Move_Valve 12, "O" ' also open "fill" since miswired
            ' close external pressure valve
            Move_Valve 11, "C"
        Else
            Move_Valve 8, "C"
            Dry_Chamber_Control "O"
        End If
    ElseIf TType%(current_unit%) = 4 Then
        Rem this is how we end a liquid permeability test
        Rem we used to pressurize assuming that it would drain all of the liquid out,
        Rem but for some samples this doesn't work and when the regulator is zeroed
        Rem it causes the water to backup into the flow meters.  This should work better
        Rem though it will leave water in the sample chamber.
        ' first, open valve 3 to allow system to drain
        If Drain12 Then

' **********
' BEGIN Balance Not Pentrometer code entered by search for Tim Richards on Tuesday 040728 2:46PM
' End of test, so open the drain valve
'
    If g_bBalanceNotPenet = True Then Test_Done_Drain 0   ' TAR 040805---since it's tared at start, target zero
'
' END code entered by Tim Richards on 040728
' **********

            ' for systems with valve 12 and a lower penetrometer, we actually want
            ' to close this valve (this is also done earlier, but just in case we do it again now)
            If PEN20500 < 0 Then
                Move_Valve 11, "C"
                ' delay for 2 seconds to make sure the valve is all the way closed
                ' before we release the air pressure
                waitseconds 2
            Else
            
' Tim Richards, 1PM Thursday 6/17/04 AutoTest
' This is during test run on the 1293 with the penetrometer. There was one click, perhaps valve 12
' being closed on the 1293 with the penetrometer. Upon visual inspection, the penetrometer is now empty.

                Move_Valve 11, "O" '1293 6/7
            End If
        Else
            ' if there is no drain valve, we want to close valve 9 first while there is still
            ' pressure in the system so the air pressure leaves the penetrometer through valve 9
            ' and not through the entire pressure manifold
            Move_Valve 8, "C"
            waitseconds 2 ' just in case
            ' now it is safe to open valve 3 and vent the rest of the system
            ' note that the pressure regulator is probably still at high pressure
            ' so there will be some pressure venting through valve 3 for a short period of
            ' time.  This is good to keep the system clean and keep the liquid out.
            ' If there is a valve 4, then we won't actually be venting anything just yet.
            Move_Valve 2, "O"
        End If
        ' second, close valve 9 to allow top of penetrometer to reach atmospheric pressure
        Move_Valve 8, "C"
        If slurry_tube_exists Then '6.71.123.19
            Move_Valve Slurry_tube_vent_valve, "C" 'slurry tube vent valve V29
        End If
        Rem now the bottom of the sample and the top of the sample should be at atmospheric pressure,
        Rem though the regulator is still pressurized and valve 4 is still sending pressure to the other
        Rem side of valve 9.
        Rem Ask the user to disconnect the penetrometer and let the water drain from the sample chamber
        ' special case for auto compression
        If autocompress And recirculation = False Then
            'MsgBox ts$(353)             ' "Disconnect the penetrometer from the sample chamber and prepare for release of the compression piston"
            If safetyup And Vpos(15) = 1 Then
                If safetyupdoor Then
                    ' do auto door switch thing instead of key press thing
                    check_safety_door False
                Else
                    safetykeypress.mainlabel.Caption = ts$(166)         ' "Piston About To Raise"
                    safetykeypress.cancelbutton.Visible = False
                    safetykeypress.Show 1, progress
                End If
            End If
            move_piston "C"
            'MsgBox ts$(354)             ' "Open the sample chamber and allow all the liquid to drain out"

' **********
' Begin balance not penetrometer code inserted by search for Tim Richards on Friday 040618 11:17AM
' change ElseIf recirculation = False Then
'
        ElseIf recirculation = False And g_bBalanceNotPenet = False Then
'
' End code inserted by Tim Richards 040618
' **********
            If liqpermonly = False Then
                MsgBox ts$(355)             ' "Disconnect the penetrometer from the sample chamber and open the sample chamber to allow the fluid to drain out."
            End If
        End If
        Rem now that the fluid is out, we can safely close valve 4
        Rem this only happens if you have one chamber
        If chambers = 1 And Not AirTop Then
            ' no need for the warning for special ambient machines
'            If TMode%(current_unit%) <> 1 Or Not special_ambient Then
                If liqpermonly = False Then
                    MsgBox ts$(356), 16, ts$(357)          ' "DO NOT CONTINUE unless the penetrometer has been disconnected, the sample has been removed from the chamber, and the water drained out!"/ "Warning!!!"
                    MsgBox ts$(358), 16, ts$(357)       ' "When you press 'OK', there may be a burst of air through the sample chamber!  Cover the chamber with a cloth BEFORE pressing 'OK'!"/"Warning!!!"
                End If
'            End If
            Dry_Chamber_Control "O"
        End If
        Rem on a 2 chamber machine it is now time to close valve 4
        If chambers = 2 Or AirTop Then Dry_Chamber_Control "O"
        Rem with the regulator still at high pressure, a spray of gas will be coming out of the sample chamber.
        Rem now zero the regulator to stop the spray
        Zero_Reg
        Rem Finally, relieve the pressure in the tube between valves 4 and 9 by pulsing 9 a few times
        Rem only do this on non-airtop and non-version 6 machines, as on newer models valve 4 is a 2-way valve
        Rem and there is no area that needs to be vented.
        If (Not AirTop) And version < 6 Then
            Move_Valve 8, "O"
            Move_Valve 8, "C"
            Move_Valve 8, "O"
            Move_Valve 8, "C"
            Move_Valve 8, "O"
            Move_Valve 8, "C"
            Move_Valve 8, "O"
            Move_Valve 8, "C"
        End If
    End If

    If hasSampleEject Then
        MsgBox "Ejecting sample.", vbInformation
        Zero_Reg
        Move_Valve sampleEjectValve, "O"
        
        ReadXReturnX4 37
        EJP0 = x5
        EJP1 = x5
        Do
            EJP0 = EJP1
            inc_reg 50
            waitseconds 1
            ReadXReturnX4 37
            EJP1 = x5
            
            If ((EJP0 < EJP1) And (REGPOS < 4000)) Then
                Exit Do
            End If
        Loop
       
        Zero_Reg
        Move_Valve sampleEjectValve, "C"
        MsgBox "The sample should be ejected.", vbInformation
    End If

    ' these were for a rare case where test_done could have been
    ' called without setting fpoints properly
    ' This shouldn't be able to happen any more, and this was
    ' causing a problem when you aborted a two-pass test during
    ' the first pass, spoints should not have been set to anything
'    If FPOINTS = 0 Then FPOINTS = points
'    If SPOINTS = 0 Then SPOINTS = points
    If FPOINTS > 0 Then
        '  put first data into f$ file
        fn = FreeFile
        'Open OutFilename$(current_unit%) For Append As #fn
        Open EXE_Path$ + "lastdata.cft" For Append As #fn
        If TType%(current_unit%) = 4 And ((TMode%(current_unit%) = 2 And DELTAP > 0) Or (TMode%(current_unit%) = 1)) Then
            ' sort the data points as they may be out of order
            ' due to multiple passes
            ' don't sort if they didn't use any pressure increment - just store data in raw format
            ' The data from ambient can be out of order as well because of lohm correction
            For i% = 2 To FPOINTS - 1
                n% = i%
                pt = first_array.a(i%)
                P = pt.pr
                For j% = i% + 1 To FPOINTS
                    If first_array.a(j%).pr < P Then
                        n% = j%
                        P = first_array.a(j%).pr
                    End If
                Next j%
                ' swap i% and n%
                ' pt already holds original value of first_array.a(i%)
                first_array.a(i%) = first_array.a(n%)
                first_array.a(n%) = pt
                If use_temperature Or recirculation Then
                    P = temperature1(n%)
                    temperature1(n%) = temperature1(i%)
                    temperature1(i%) = P
                    If reservoirTemperature <> 0 Then
                        P = temperature2(n%)
                        temperature2(n%) = temperature2(i%)
                        temperature2(i%) = P
                    End If
                End If
                If temperatureControl Then
                    
                End If
            Next i%
        End If
        ' old ambient data store method:
        'If TType%(current_unit%) = 4 And TMode%(current_unit%) = 1 Then
        '    Print #fn, Str$(P0)
        '    ' send the points backwards because the
        '    ' highest pressure points will be first
        '    ' and the pressure will drop as the liquid
        '    ' level goes down
        '    For i% = FPOINTS To 2 Step -1
        '        pt = first_array.a(i%)
        '        GoSub sendpoint
        '        'Print #fn, Str$(f); ","; Str$(p)
        '    Next i%
        '    If use_temperature Then
        '        If reservoirTemperature <> 0 Then
        '            Print #fn, "0,0,0,0"
        '        Else
        '            Print #fn, "0,0,0"
        '        End If
        '    ElseIf use_time Then
        '        Print #fn, "0,0,0"
        '    Else
        '        Print #fn, "0,0"
        '    End If
        '    Close #fn
        '    GoTo 714
        'End If
        
        For i% = 1 To FPOINTS
            pt = first_array.a(i%)
            If i% = 1 Then
                If TType%(current_unit%) < 3 Then
                  pt.pr = P0
                  ' first line of data is always f and p0 regardless of temperature sensor status
                  Print #fn, str$(pt.fl); ","; str$(P0)
                Else
                  Print #fn, str$(P0)
                End If
            Else
                GoSub sendpoint
                'Print #fn, Str$(f); ","; Str$(p)
            End If
        Next i%
        
        If TType%(current_unit%) <> 2 Or TMode%(current_unit%) <> 2 Then
          ' note that it doesn't matter if there are some extra "0"s on the end of
          ' a hydrohead test.  These will be ignored.  (And they will be truncated by the final copy)
          If use_fluid_sensor Then
            Print #fn, "0,0,0"
          ElseIf dryChamberTemperature <> 0 And airTemperature = 0 And TType%(current_unit%) <> 4 Then
            Print #fn, "0,0,0"
          ElseIf dryChamberTemperature <> 0 And airTemperature <> 0 And TType%(current_unit%) <> 4 Then
            Print #fn, "0,0,0,0"
          ElseIf use_temperature Or (recirculation And TType%(current_unit%) = 4) Then
            If reservoirTemperature <> 0 Then
                Print #fn, "0,0,0,0"
            Else
                Print #fn, "0,0,0"
            End If
          ElseIf use_time Then
            Print #fn, "0,0,0"
          ElseIf recordHumidityForAutoTests Then
            Print #fn, "0,0,0"
          Else
            Print #fn, "0,0"
          End If
        Else
          ' integrity test always ends in "-1,-1" regardless of temperature or other status
          Print #fn, "-1,-1"
        End If
        If TType%(current_unit%) = 1 And TMode%(current_unit%) = 4 Then
            Rem put in extrapolated dry down curve now
            Rem the last wet point will already be in pt
            Rem just use the temperature from the wet point
            If recordHumidityForAutoTests Then
                If dryChamberTemperature <> 0 Then
                    If airTemperature <> 0 Then
                        Print #fn, str$(pt.fl); ","; str$(pt.pr); ","; temperature1(FPOINTS); ","; temperature2(FPOINTS); ","; str$(first_array.a(1).humidity)
                    Else
                        Print #fn, str$(pt.fl); ","; str$(pt.pr); ","; temperature1(FPOINTS); ","; str$(pt.humidity)
                    End If
                Else
                    Print #fn, str$(pt.fl); ","; str$(pt.pr); ","; str$(pt.humidity)
                End If
            Else
                If dryChamberTemperature <> 0 Then
                    If airTemperature <> 0 Then
                        Print #fn, str$(pt.fl); ","; str$(pt.pr); ","; temperature1(FPOINTS); ","; temperature2(FPOINTS)
                    Else
                        Print #fn, str$(pt.fl); ","; str$(pt.pr); ","; temperature1(FPOINTS)
                    End If
                Else
                    Print #fn, str$(pt.fl); ","; str$(pt.pr)
                End If
            End If
            first_point = True
            GoSub drawpoint
            'MsgBox "putting in linear dry type=" + Str$(linear_type%)
            If linear_type% = 1 Then
                current_perm = pt.fl / ((pt.pr / P0) ^ 2 - 1)
            Else
                current_f = pt.fl
                current_p = pt.pr - P0
            End If
            For i% = FPOINTS - 1 To 2 Step -1
                pt = first_array.a(i%)
                Rem make sure that extrapolated dry curve not under wet curve
                If linear_type% = 1 Then
                    ' calculate new permeability
                    xf = pt.fl / ((pt.pr / P0) ^ 2 - 1)
                    If xf > current_perm Then
                        current_perm = xf
                    Else
                        pt.fl = current_perm * ((pt.pr / P0) ^ 2 - 1)
                    End If
                    GoSub sendpoint
                    GoSub drawpoint
                Else
                    If linear_type% = 2 And pt.pr > P0 And current_p > 0 Then
                        xf = current_f * Sqr(pt.pr - P0) / Sqr(current_p)
                    Else ' linear
                        xf = current_f * (pt.pr - P0) / current_p
                    End If
                    If xf < pt.fl Then
                        current_f = pt.fl
                        current_p = pt.pr - P0
                        GoSub sendpoint
                        GoSub drawpoint
                        'Print #fn, Str$(f); ","; Str$(p)
                    ElseIf linear_type% = 2 Then
                        ' only need to send the points if we are
                        ' non-linear.  For straight line, if we
                        ' are higher than wet flow we don't
                        ' need to send the point because it is on
                        ' a straight line to 0,0 from the last data
                        ' point (or on a straight line to the next
                        ' point on the wet curve that would intersect this
                        ' straight line).
                        pt.fl = xf
                        GoSub sendpoint
                        GoSub drawpoint
                    End If
                End If
            Next i%
            i% = 1
            'Print #fn, "0,"; Str$(P0)
            pt.fl = 0
            pt.pr = P0
            pt.eqd = 0
            pt.time = Timer
            pt.fluid = 0
            GoSub sendpoint
            GoSub drawpoint
            If dryChamberTemperature <> 0 And airTemperature = 0 Then
                Print #fn, "0,0,0"
            ElseIf dryChamberTemperature <> 0 And airTemperature <> 0 Then
                Print #fn, "0,0,0,0"
            ElseIf recordHumidityForAutoTests Then
                Print #fn, "0,0,0"
            Else
                Print #fn, "0,0"
            End If
            progress.Refresh
        End If
        Close fn
    End If
'    If setsToDo > 0 Then
'    GoTo 789
'    End If
        
714 If SPOINTS > 0 And TType%(current_unit%) = 1 And TMode%(current_unit%) <> 4 Then
        If dryChamberTemperature <> 0 Then
            ' need to move second set of temperature data over
            For i% = 1 To temperature_array_size
                temperature1(i%) = temperature2(i%)
            Next i%
        End If
        '  put second data into f$ file and kill it
        fn = FreeFile
        'Open OutFilename$(current_unit%) For Append As #fn
        Open EXE_Path$ + "lastdata.cft" For Append As #fn
        For i% = 1 To SPOINTS
            pt = second_array.a(i%)
            GoSub sendpoint
            'Print #fn, Str$(f); ","; Str$(p)
        Next i%
        If use_fluid_sensor Then
          Print #fn, "0,0,0"
        ElseIf dryChamberTemperature <> 0 And airTemperature = 0 Then
          Print #fn, "0,0,0"
        ElseIf dryChamberTemperature <> 0 And airTemperature <> 0 Then 'AJB 11-22-09
          Print #fn, "0,0,0,0" 'AJB 11-22-09
        Else
          Print #fn, "0,0"
        End If
        Close fn
    End If

'put parameters at end of file
    fn = FreeFile
    'Open OutFilename$(current_unit%) For Append As #fn
    Open EXE_Path$ + "lastdata.cft" For Append As #fn
    Print #fn, S_Version
    If TType%(current_unit%) = 1 Or (TType%(current_unit%) = 2 And TMode%(current_unit%) <> 2) Then
'print bubble point parameters
        Print #fn, BPParams
    End If
    If TType%(current_unit%) = 1 Or (TType%(current_unit%) = 2 And TMode%(current_unit%) = 2) Then
'print wet parameters
        Print #fn, WETParams
    End If
    If TType%(current_unit%) = 3 Or (TType%(current_unit%) = 1 And (TMode%(current_unit%) <> 4 And TMode%(current_unit%) <> 10 And TMode%(current_unit%) <> 11)) Then
'print dry parameters
        Print #fn, DRYParams
    End If
    If TType%(current_unit%) = 4 And TMode%(current_unit%) = 2 Then
'print elevated liquid permeability parameters
        Print #fn, "L," + str(lperm_maxp) + "," + str(lperm_stepp) + "," + str(lperm_maxwait) + "," + str(lperm_maxpoints)
    End If
    Print #fn, "0,0"
    Close #fn
        
    If GP_multiAverageTest And TType%(current_unit%) = 3 Then Exit Sub      ' If we are running multiple gas perm tests, we just want the save - no valve changes
    
    If (bpRunMultipleTests And TType%(current_unit%) = 2) Or _
       (lpRunMultipleTests And TType%(current_unit%) = 4) Then
        Exit Sub
    End If
    
    

    If ExtraPG Then Pres% = 2 Else Pres% = 1
    HFLOW% = 1

      
    If bubbler_enable Then
        ' for the bubbler, we do things a little differently
        Move_Valve 24, "C" ' divert flow from bubbler
        waitseconds 5 ' wait 3 seconds for 25 to actually move
        ' now do rest of normal sequence
    End If
    Move_Valve 0, "C"
    If Not RUNNING Then
        If hasMultipleMVs Then
            ManualControl1.show_valve_closed 1
        Else
            ManualControl.show_valve_closed 1
        End If
    End If
    Zero_Reg
    Move_Valve 2, "O"
    If Not RUNNING Then
        If hasMultipleMVs Then
            ManualControl1.show_valve_open 2
        Else
            ManualControl.show_valve_open 2
        End If
    End If
    If Drain12 Then

' Tim Richards, 1PM Thursday 6/17/04 AutoTest
' On the 1293, on the penetrometer, this is after it tells you to disconnect the sample chamber
' from the penetrometer and open the sample chamber to let all the fluid drain out.
' This is the last point in the AutoTest for the 1293 penetrometer setup.

        If PEN20500 > 0 Then Move_Valve 11, "O" '1293 7/7
    End If
    If slurry_tube_exists Then '6.71.123.19
        Move_Valve Slurry_tube_vent_valve, "C" 'slurry tube vent valve V29
    End If
    If H2OPERM Then
        Move_Valve 8, "C"
    End If

    ReadXReturnX4 3
    min_v_seen = x4
    min_seen_at = Timer
    If cLimit >= x4 Then GoTo 789
    Send_RS232 ("C" + mv1_index_char)

788 ReadXReturnX4 3
    If x4 < min_v_seen Then
        min_v_seen = x4
        min_seen_at = Timer
    End If
    If min_seen_at > Timer + 0.1 Then min_seen_at = min_seen_at - 86400
    If Timer - min_seen_at > 10 Then GoTo 789
    If cLimit < x4 Then GoTo 788
789
    If (autocompress Or autopiston Or (FrazierPiston And FrazierRunning)) And (recirculation = False) Then
        If safetyup And Vpos(15) = 1 Then
            If safetyupdoor Then
                ' do auto door switch thing instead of key press thing
                check_safety_door False
            Else
                safetykeypress.mainlabel.Caption = ts$(166)             ' "Piston About To Raise"
                safetykeypress.cancelbutton.Visible = False
                safetykeypress.Show 1, progress
            End If
        End If
        'added on 12-17-07 --Denis
        'closes piston 2 if thats the one that is selected and not sequentialTesting
        'will add sequentialtesting later when 2nd sample chamber can work indepentently
        If sequentialTesting = False And manuallySelectedChamber = 2 Then
'            Move_Valve SecondPiston, "C"
     '       move_piston "C"     'Delete needed
        ElseIf sequentialTesting = True Then
            If manuallySelectedChamber = 1 Then
                move_piston "C"
            Else
'                Move_Valve SecondPiston, "C"
            End If
        Else
            move_piston "C"
        End If
'Before the above edit        move_piston "C"
    End If
    Beep
    
'JDF 02-03-10 Adding code to open report for pass/fail CFP test based on median pore size
    If runAsPassFail(current_unit%) = True And passFailType(current_unit%) = 1 Then
        rval = Shell(EXE_Path$ + "Caprep.exe resultcall " + OutFilename$(current_unit%), 1)
    End If
    
'edc 12-15-06 sound effects added to the end of test
    If Not nowait_at_end And (auto_report_type = 3 Or WESA_exclusive) Then     ' auto_report_type replace show_result
        
        Select Case TType%(current_unit%)
        Case 1
            ' calcalate mfp if we can
            CalcMFP EXE_Path$ + "lastdata.cft"
            If LoopingDemo = False Then
                sndPlaySound EXE_Path & "test.wav", SND_ASYNC Or sndLoop    'add sound and loop
                ds$ = ts$(76) + vbCr + FResult              ' "Test Done. Remove Sample."
                MsgBox ds$, 0, ts$(77)                      ' "Done"
                sndStopSound 0, SND_ASYNC               'stop sound
            End If
        Case 2
            If TMode%(current_unit%) < 2 Then
                sndPlaySound EXE_Path & "test.wav", SND_ASYNC Or sndLoop    'add sound and loop
                ds$ = ts$(76) + vbCr + FResult          ' "Test Done. Remove Sample."
                MsgBox ds$, 0, ts$(77)                  ' "Done"
                sndStopSound 0, SND_ASYNC                'stop sound
            Else
                sndPlaySound EXE_Path & "test.wav", SND_ASYNC Or sndLoop    'add sound and loop
                MsgBox ts$(359), 0, ts$(77)             ' "All done.  Remove Sample."/"Done"
                sndStopSound 0, SND_ASYNC                'stop sound
            End If
            If auto_wet_enable Then
                Move_Valve Drain_ValveA, "O"
                waitseconds val(gpps2(Curr_U$, "drain_time", IFile$, "10"))
                Move_Valve Drain_ValveA, "C"
                DoEvents
            End If
        Case 3, 4
            CalcGP EXE_Path$ + "lastdata.cft"
            If LoopingDemo Then
                GoTo Bailout
            Else
                sndPlaySound EXE_Path & "test.wav", SND_ASYNC Or sndLoop    'add sound and loop
                'If GP_multisetTest = True And (setsToDo > 1) Then
                '    ds$ = "Set Done." + vbCr + "Insert next sample."
                '    MsgBox ds$, 0, ts$(77)                      ' "Done"
                '    sndStopSound 0, SND_ASYNC               'stop sound
                '    Exit Sub
                'ElseIf GP_multisetTest = True And (setsToDo <= 1) Then
                '    setLeft = setsToDo - 1
                '   ds$ = "Set Done." + CStr(setLeft) + "sets left to do." + vbCr + "Insert next sample."
                '    MsgBox ds$, 0, ts$(77)                      ' "Done"
                '    sndStopSound 0, SND_ASYNC               'stop sound
                '    Exit Sub
                'Else
                ds$ = ts$(76) + vbCr + FResult              ' "Test Done. Remove Sample."
                MsgBox ds$, 0, ts$(77)                      ' "Done"
                sndStopSound 0, SND_ASYNC               'stop sound
                'End If
                
            End If
        Case Else
            sndPlaySound EXE_Path & "test.wav", SND_ASYNC Or sndLoop    'add sound and loop
            MsgBox ts$(359), 0, ts$(77)                 ' "All done.  Remove Sample."/"Done"
            sndStopSound 0, SND_ASYNC               'stop sound
        End Select
    ElseIf Not nowait_at_end Then
    ' If GP_multisetTest = True And (setsToDo > 1) Then
    '                   setLeft = setsToDo - 1
    '                ds$ = "Set Done." + CStr(setLeft) + "sets left to do." + vbCr + "Insert next sample."
    '                MsgBox ds$, 0, ts$(77)                      ' "Done"
    '                sndStopSound 0, SND_ASYNC               'stop sound
    '               Exit Sub
    '                End If
    '                 If GP_multisetTest = True And (setsToDo <= 1) Then
    '                ds$ = "Set Done." + vbCr + "Test over, remove sample."
    '                MsgBox ds$, 0, ts$(77)                      ' "Done"
    '                sndStopSound 0, SND_ASYNC               'stop sound
    '                Exit Sub
    '                End If
        If LoopingDemo = False Then
        sndPlaySound EXE_Path & "test.wav", SND_ASYNC Or sndLoop    'add sound and loop
        MsgBox ts$(359), 0, ts$(77)                   ' "All done.  Remove Sample."/"Done"
        sndStopSound 0, SND_ASYNC                'stop sound
        End If
    End If
    If pass = 0 Then MsgBox ts$(360), 0, ts$(361)       ' "Something was wrong with the test.  Data is invalid."/"Test Error"
    If uselog Then
        ' If this is a bubble point or MFP test, get our statistical values
        If TType%(current_unit%) = 1 Or (TType%(current_unit%) = 2 And TMode%(current_unit%) = 1) Then appendLogStatistics
        
        fn2 = FreeFile
        Open logpath For Append As fn2
        Print #fn2, date$
        Print #fn2, time$
        Print #fn2, FResult
        Print #fn2, "---------------------------------------------------------"
        Close #fn2
    
    End If
    'AJB 11-03-09
    ' must allow them to open the door now
    If doorlock Then
        If MsgBox(ts$(463), vbYesNo) = vbYes Then       ' "Do you want to open the door now?"
            Send_RS232 ("O@")
            Move_Valve 2, "O"
            MsgBox ts$(478)     ' "Open Door Now"
            Move_Valve 2, "C"
            Send_RS232 ("C@")
        End If
    End If
    Rem added by jsd to get rid of cv file
    Rem added by jsd for case of overcorrection of Lohm !
    'If cv = 99 And bad_cv_correction = True Then
        'reply% = MsgBox("A Pressure Correction Error Was Logged - Wish to See ??", 4, "Lohm Error")
        'If reply% = 6 Then retval = Shell("notepad.exe " + EXE_Path$ + "Cv error.log", 3)                                                'Process_CVError Testscrn.hwnd didn't work correctly
    'End If
    If V2Percent = 21 Then
        fn2 = FreeFile
        k = 1
        Open EXE_Path$ + "Lohm Correction File.dat" For Append As #fn2
        While k <= lohm_counter
            Print #fn2, Raw_P(k); ","; Lohm_P(k); ","; Lohm_F(k); ","; Lohm_Val(k)
            DoEvents
            k = k + 1
        Wend
        Close #fn
    End If
    If cv_flag Then
        ' "The program automatically turned the test because it was calculated that"/"the pressure drop across the sample was within"/"of"/"The pressure drop across an empty sample chamber"/"You must reduce the sample area to reduce flow and rerun for more accurate results."/"Lohm Correction Limit Warning"
        MsgBox ts$(362) + vbCrLf + ts$(363) + " " + Format$((-1 * (100 - (Lohm_Ratio * 100))), "#.0") + " % " + ts$(235) + vbCrLf + ts$(364) + vbCrLf + ts$(365), 48, ts$(366)
        cv_warning_flag = False ' if we got here, it had to be greater than 80% !!  no need for 2 messages with the same content
    End If
    ' "The program has detected that the pressure drop across the sample was within 80% of"/"The pressure drop across an empty sample chamber"/"You may wish to lessen the sample area to reduce the flow and rerun if possible."/"Lohm Correction Limit Warning"
    If cv_warning_flag Then MsgBox ts$(367) + vbCrLf + ts$(364) + vbCrLf + ts$(368), 48, ts$(366)
    ' copy over the tempfile to the desired output file
    'If TType%(current_unit%) = 7 Then
    '    FileCopy EXE_Path$ + "lastdata.cft", OutFilename$(current_unit%)
    'Else
        do_final_copy
    'End If
    If BPTLEnable And (BPTLNumPoints > 0) Then
        fn = FreeFile
        Open EXE_Path$ + "BPTL_Log.txt" For Input As #fn
        fn2 = FreeFile
        Open Left$(OutFilename$(current_unit%), Len(OutFilename$(current_unit%)) - 4) + "-BPLOG.txt" For Output As #fn2
        ' calculate how many points to skip after every copied point
        l1 = Int((BPTLNumPoints + BPTLMaxPoints - 1) / BPTLMaxPoints) - 1
        While EOF(fn) = False
            Line Input #fn, a$
            Print #fn2, a$
            l2 = l1
            While EOF(fn) = False And l2 > 0
                Line Input #fn, a$
                l2 = l2 - 1
            Wend
        Wend
        Close #fn
        Close #fn2
    End If
    
    Unload Testscrn
    ' Run a report in Caprep, if appropriate. If auto_report_type = 1, just show the summary sheet and quit.
    ' If auto_report_type =2, then run a regular report.
    If auto_report_type = 1 Then retval = Shell(EXE_Path$ + "Caprep.exe " + "resultcall " + OutFilename$(current_unit%), 1)
    If auto_report_type = 2 Then retval = Shell(EXE_Path$ + "Caprep.exe " + OutFilename$(current_unit%), 1)
    
    'AJB 12-20-09
    If hasMultipleMVs And motorValveIndex > 0 Then
        'We must have switched over during the test and over wrote the values, refresh them
        SetV2Limits
    End If
    
    Exit Sub
    
drawpoint:
    ' draw f and p on simulated dry curve
    If Not first_point Then
        progress.Picture1.Line (LastPr - P0, LastFl / 1000)-(pt.pr - P0, pt.fl / 1000), color2
    End If
    first_point = False
    LastPr = pt.pr
    LastFl = pt.fl
    Return
sendpoint:
    ' send out f and p in the manner dictated by eqd
    fstr$ = Trim$(str$(pt.fl))
    pstr$ = Trim$(str$(pt.pr))
    Select Case pt.eqd
        Case 0
            outStr$ = " " + fstr$ + " , " + pstr$
        Case 1
            outStr$ = " " + fstr$ + ", " + pstr$
        Case 2
            outStr$ = " " + fstr$ + "," + pstr$
        Case 3
            outStr$ = " " + fstr$ + " ," + pstr$
        Case Else
            outStr$ = fstr$ + "," + pstr$
    End Select
    ' hydrohead test can't handle temperature information
    If TType%(current_unit%) <> 2 Or TMode%(current_unit%) <> 3 Then
        If use_fluid_sensor Then
            outStr$ = outStr$ + "," + Trim$(str$(pt.fluid))
        End If
        If use_temperature Or (recirculation And TType%(current_unit%) = 4) Or (dryChamberTemperature <> 0 And TType%(current_unit%) <> 4) And Not temperatureControl Then
            If reservoirTemperature <> 0 And (use_temperature Or (recirculation And TType%(current_unit%) = 4)) Then
                outStr$ = outStr$ + "," + Trim$(str$(temperature2(i%)))
            End If
            outStr$ = outStr$ + "," + Trim$(str$(temperature1(i%)))
        End If
        'AJB 10-22-09
        If recordHumidityForAutoTests Then
            If temperatureControl Then
                If dryChamberTemperature <> 0 Then
                    If airTemperature <> 0 Then
                        outStr$ = outStr$ + "," + Trim$(str$(pt.temp1)) + "," + Trim$(str$(pt.temp2)) + "," + Trim$(str$(pt.humidity))
                    Else
                        outStr$ = outStr$ + "," + Trim$(str$(pt.temp1)) + "," + Trim$(str$(pt.humidity))
                    End If
                End If
            End If
        Else
            If temperatureControl Then
                If dryChamberTemperature <> 0 Then
                    If airTemperature <> 0 Then
                        outStr$ = outStr$ + "," + Trim$(str$(pt.temp1)) + "," + Trim$(str$(pt.temp2))
                    Else
                        outStr$ = outStr$ + "," + Trim$(str$(pt.temp1))
                    End If
                End If
            End If
        End If
    End If
    If use_time Then
        outStr$ = outStr$ + "," + Trim$(str$(pt.time))
    End If
    If recordHumidityForAutoTests Then
        Print #fn, outStr$ + " , " + Trim$(str$(pt.humidity))
    Else
        Print #fn, outStr$
    End If
    Return

Bailout:

End Sub

Sub test_record()
' don't let record button be pressed until 1 second after
' the last time we took a point.
' This is to trap the case where the user decides that the
' waiting is long enough and presses the record button just
' when the program decides to take the point anyway.  This
' record button press would be kept until the next data point
' and then used immediately.   This would cause the next
' data point to be taken way too soon.

    Dim current_t As Single

    current_t = Timer
    While current_t + 0.1 < took_point_time
        took_point_time = took_point_time - 86400
    Wend
    If current_t - took_point_time < 1 And HKey$ = "R" Then
        HKey$ = " "
    End If
    
End Sub

Function TestName$()

    Dim XTemp$
 
    Select Case TType%(current_unit%)
    Case 1
        Select Case TMode%(current_unit%)
        Case 1
            XTemp$ = ts$(369) + "/" + ts$(371)                      ' "Wet Up/Dry Down"
        Case 2
            XTemp$ = ts$(369) + "/" + ts$(370)                      ' "Wet Up/Dry Up"
        Case 3
            XTemp$ = ts$(370) + "/" + ts$(369)                      ' "Dry up/wet up"
        Case 4
            XTemp$ = ts$(369) + "/" + ts$(372) + ", " + ts$(373)    '  "Wet Up/Calc. Dry, Linear"
        Case 5
            XTemp$ = ts$(369) + "/" + ts$(371) + ", " + ts$(374)    ' "Wet Up/Dry Down, Stop Dry at Bubble Point"
        Case 6
            XTemp$ = ts$(369) + "/" + ts$(370) + ", " + ts$(375)    ' "Wet Up/Dry Up, with fluid sensing"
        Case 7
            XTemp$ = ts$(370) + "/" + ts$(369) + ", " + ts$(375)    ' "Dry Up/Wet Up, with fluid sensing"
        Case 8
            XTemp$ = ts$(369) + "/" + ts$(370) + ", " + ts$(376)    ' "Wet Up/Dry Up, No Wait at Dry"
        Case 9
            XTemp$ = ts$(369) + "/" + ts$(370) + ", " + ts$(376) + ", " + ts$(375)  ' "Wet Up/Dry Up, No Wait, fluid sense"
        Case 10
            XTemp$ = ts$(369) + "/" + ts$(372) + ", " + ts$(377)    ' "Wet Up/Calc. Dry, Darcy"
        Case 11
            XTemp$ = ts$(369) + "/" + ts$(372) + ", " + ts$(378)    ' "Wet Up/Calc. Dry, Square Root"
        End Select
        If diffpgflow(current_unit%) Then
            XTemp$ = XTemp$ + " - " + ts$(379)                      ' "microflow"
        End If
        If threestagetest(current_unit%) Then
            XTemp$ = XTemp$ + " - " + ts$(524)                      ' "3 Stage Test"
        End If
        TestName$ = ts$(380) + " - " + XTemp$                       ' "Capillary Flow Porometry"
        Exit Function
    Case 2
    ' if they ask for integrity and can't do it, use bubble point
        If TMode%(current_unit%) = 2 And Not integrity Then TMode%(current_unit%) = 1
        Select Case TMode%(current_unit%)
        Case 3
            If hhRunAsMullen(current_unit%) Then
                XTemp$ = ts$(523)
            ElseIf hhRunAsBurst(current_unit%) Then
                XTemp$ = ts$(526)
            Else
                XTemp$ = ts$(83)                                        ' "HydroHead"
            End If
        Case 1
            XTemp$ = ts$(96) + " - " + ts$(381)                     ' "Bubble Point - Standard Mode"
        Case 0
            XTemp$ = ts$(96) + " - " + ts$(382)                     ' "Bubble Point - Manual Mode"
        Case 2
            XTemp$ = ts$(383)                                       ' "Integrity Test on Saturated Sample"
        End Select
        TestName$ = XTemp$
        Exit Function
    Case 3
        TestName$ = ts$(384)                                        ' "Gas Permeability"
        Select Case TMode%(current_unit%)
        Case 1
            TestName$ = ts$(385)                                    ' "Envelope Surface Area Analysis"
            If diffpgflow(current_unit%) Then
                TestName$ = TestName$ + " - " + ts$(379)                      ' "microflow"
            End If
            If threestagetest(current_unit%) Then
                TestName$ = TestName$ + " - " + ts$(524)                      ' "3 Stage Test"
            End If
        Case 10
            TestName$ = ts$(516)                                    ' "Gurley Test"
        Case 11
            TestName$ = ts$(517)                                    ' "High Pressure Gurley"
        Case 12
            TestName$ = ts$(518)                                    ' "Sheffield Method"
        Case Else
            If diffpgflow(current_unit%) Then
                TestName$ = TestName$ + " - " + ts$(379)                      ' "microflow"
            End If
            If threestagetest(current_unit%) Then
                TestName$ = TestName$ + " - " + ts$(524)                      ' "3 Stage Test"
            End If
        End Select
       
        Exit Function
    Case 4
        If TMode%(current_unit%) = 1 Then
            TestName$ = ts$(386) + " - " + ts$(387)                 ' "Liquid Permeability - Ambient Pressure"
        '6.71.123.12 Else
        ElseIf TMode%(current_unit%) = 2 Then
            TestName$ = ts$(386) + " - " + ts$(388)                 ' "Liquid Permeability - Elevated Pressure"
        ElseIf TMode%(current_unit%) = 13 Then
            TestName$ = ts$(386) + " - " + ts$(503)                 ' "Liquid Permeability - Build Cake By Pressure"
        ElseIf TMode%(current_unit%) = 14 Then
            TestName$ = ts$(386) + " - " + ts$(504)                 ' "Liquid Permeability - Build Cake By Flow"
        ElseIf TMode%(current_unit%) = 15 Then
            TestName$ = ts$(386) + " - " + ts$(505)                 ' "Liquid Permeability - Slurry Tube Wash Cycle"
        Else
            MsgBox ("Invalid liquid perm choice")
        End If
        Exit Function
    Case 5
        TestName$ = ts$(327)                                        ' "Pressure Hold Test"
        Exit Function
    Case 6
        If lvperm_enable Then
            TestName$ = ts$(389)                                    ' "Liq. Vapor Permeability"
        Else
            TestName$ = ts$(390)                                    ' "Microflow Pressure vs. Time Analysis"
        End If
        Exit Function
    Case 7
        TestName$ = ts$(519)                                        ' "Resin Test"
    End Select

End Function

Function time_difference(t1 As LARGE_INTEGER, t2 As LARGE_INTEGER) As Double
' returns time difference in seconds between t1 and t2

    Dim d1 As Double, d2 As Double, d3 As Double, d4 As Double

    d1 = t1.lowpart
    d2 = t2.lowpart
    If d1 < 0 Then d1 = d1 + 4294967296#
    If d2 < 0 Then d2 = d2 + 4294967296#

    If t1.highpart <> t2.highpart Then
    ' we must deal with the highpart change as well
    
        d3 = t1.highpart
        d4 = t2.highpart
        If d3 < 0 Then d3 = d3 + 4294967296#
        If d4 < 0 Then d4 = d4 + 4294967296#
        d3 = d4 - d3 ' highpart difference
        If d3 < 0 Then d3 = d3 + 4294967296# ' handle wrap-around problem
        ' d3 is now the difference in the highpart
        ' increase d2 by this highpart
        d2 = d2 + d3 * 4294967296#
    
    End If
        
    d1 = d2 - d1 ' time difference in counts
    d2 = PerformanceFrequencyValue.lowpart

    If d2 < 0 Then d2 = d2 + 4294967296#
    If PerformanceFrequencyValue.highpart <> 0 Then
        d3 = PerformanceFrequencyValue.highpart
        If d3 < 0 Then d3 = d3 + 4294967296#
        d2 = d2 + d3 * 4294967296#
    End If

    time_difference = d1 / d2 ' final result in seconds

End Function

Sub tryhold()
' only call this routine when it is safe to pause things

DoEvents
If want_to_hold And Not holding Then
    holding = True
    progress.mainmenu(0).Caption = ts$(391)     ' "&Resume"
    progress.mainmenu(1).Enabled = True
    progress.mainmenu(2).Enabled = True
    progress.mainmenu(3).Enabled = True
    If TType%(current_unit%) = 4 Then
        If Drain12 Then
            Move_Valve 11, "C"  'TAR note 040617 'pause on BD
        Else
            Move_Valve 2, "C"
        End If
    End If
    While want_to_hold
        DoEvents
    Wend
    holding = False
    progress.mainmenu(1).Enabled = False
    progress.mainmenu(2).Enabled = False
    progress.mainmenu(3).Enabled = False
    progress.mainmenu(0).Caption = ts$(392)     ' "&Pause"
    If TType%(current_unit%) = 4 Then
        If Drain12 Then

' **********
' Begin Balance Not Penet code by search for Tim Richards on Thursday 6/17/04 10:16AM
' make sure the iso valve is closed when using a Mettler balance
'
    If g_bBalanceNotPenet = True Then
            Move_Valve 11, "C"  'TAR note 040617 'resume on BD
    Else
            Move_Valve 11, "O"  'TAR note 040617 'not changed
    End If
'
' End code entered by Tim Richards 6/17/04
' **********

        Else
            ' don't open 3 on liquid perm only machines
            If liqpermonly = False Then
                Move_Valve 2, "O"
            End If
        End If
        ' reset some things so it doesn't think that we have been flowing all this time
        LastFlowTime = Timer
        fsum = 0
        FlowN = 0
    End If
End If

End Sub

Sub select_next_microflow_volume()
    If Current_Microflow_Volume_Index < Num_Microflow_Volumes Then
        Current_Microflow_Volume_Index = Current_Microflow_Volume_Index + 1
        update_microflow_volume_valves
    End If
End Sub

Sub update_microflow_volume_valves()
    If Current_Microflow_Volume_Index = 1 Then
        Move_Valve Microflow_Volume2_Valve - 1, "C"
        If Num_Microflow_Volumes > 2 Then
            Move_Valve Microflow_Volume3_Valve - 1, "C"
        End If
    ElseIf Current_Microflow_Volume_Index = 2 Then
        Move_Valve Microflow_Volume2_Valve - 1, "O"
        If Num_Microflow_Volumes > 2 Then
            Move_Valve Microflow_Volume3_Valve - 1, "C"
        End If
    ElseIf Current_Microflow_Volume_Index = 3 Then
        Move_Valve Microflow_Volume2_Valve - 1, "O"
        Move_Valve Microflow_Volume3_Valve - 1, "O"
    End If
End Sub

Function update_PSR(P As Single, f As Single)
' updates parallel stability routine and returns true only if
' P and F variations haven't gotten any worse in last 30 seconds
' (3 iterations minimum).  Otherwise returns false.

update_PSR = False ' default return value
If PSR.n = 0 Then
  Rem first time called
  PSR.LowF = f
  PSR.HighF = f
  PSR.LowP = P
  PSR.HighP = P
  PSR.SumP = P
  PSR.SumF = f
  PSR.startTime = Timer
  PSR.n = 1
Else
 If f < PSR.LowF Then
  PSR.LowF = f
  PSR.n = 0
 End If
 If f > PSR.HighF Then
  PSR.HighF = f
  PSR.n = 0
 End If
 If P > PSR.HighP Then
  PSR.HighP = P
  PSR.n = 0
 End If
 If P < PSR.LowP Then
  PSR.LowP = P
  PSR.n = 0
 End If
 If PSR.n = 0 Then
  PSR.startTime = Timer
  PSR.SumP = P
  PSR.SumF = f
  PSR.n = 1
 Else
  PSR.n = PSR.n + 1
  PSR.SumP = PSR.SumP + P
  PSR.SumF = PSR.SumF + f
 End If
 If PSR.startTime > Timer + 0.1 Then PSR.startTime = PSR.startTime - 86400
 If (Timer - PSR.startTime) >= 30 And PSR.n > 3 Then
  update_PSR = True
 End If
End If
If stability_debug Then
    stabilitydebug.Label3(0).Caption = "Time=" + str$(Timer - PSR.startTime)
    stabilitydebug.Label3(1).Caption = "MinP=" + str$(PSR.LowP)
    stabilitydebug.Label3(2).Caption = "MaxP=" + str$(PSR.HighP)
    stabilitydebug.Label3(3).Caption = "MinF=" + str$(PSR.LowF)
    stabilitydebug.Label3(4).Caption = "MaxF=" + str$(PSR.HighF)
End If

End Function

Sub update_regulator_display()

Dim temp_pres As Long, regulator_was_running As Boolean

temp_pres = raw_reading(18)
If temp_pres <= reg_cl Then
    x5 = 0
ElseIf temp_pres >= reg_ol Then
    x5 = 100
Else
    x5 = 100# * (temp_pres - reg_cl) / (reg_ol - reg_cl)
End If
If hasMultipleMVs Then
    ManualControl1.Regulator.Caption = ts$(315) + ": " + Xformat$(x5, "##0.0") + "%"     ' "Regulator"
Else
    ManualControl.Regulator.Caption = ts$(315) + ": " + Xformat$(x5, "##0.0") + "%"     ' "Regulator"
End If
regulator_was_running = regulator_running
regulator_running = RSEcho("VE", 1) <> Asc("S")
If regulator_was_running And Not regulator_running Then
    If hasMultipleMVs Then
        'ManualControl1.regrew.Enabled = True
        'ManualControl1.regff.Enabled = True
        'ManualControl1.regstop.Enabled = False
    Else
        ManualControl.regrew.Enabled = True
        ManualControl.regff.Enabled = True
        ManualControl.regstop.Enabled = False
    End If
End If

End Sub

Sub update_compression_regulator_display()

Dim temp_pres As Long, regulator_was_running As Boolean

If ip_creg_enable Then
    temp_pres = CREGPOS
Else
    temp_pres = raw_reading(31)
End If
If temp_pres <= creg_cl Then
    x5 = 0
ElseIf temp_pres >= creg_ol Then
    x5 = 100
Else
    x5 = 100# * (temp_pres - creg_cl) / (creg_ol - creg_cl)
End If
If hasMultipleMVs Then
    ManualControl1.creg.Caption = "CReg: " + Xformat$(x5, "##0.0") + "%  " + "Cts" + ":" + str$(temp_pres)
Else
    ManualControl.creg.Caption = "CReg: " + Xformat$(x5, "##0.0") + "%  " + "Cts" + ":" + str$(temp_pres)
End If
If ip_creg_enable Then
    compression_regulator_running = False
Else
    regulator_was_running = compression_regulator_running
    compression_regulator_running = RSEcho("VP", 1) <> Asc("S")
    If regulator_was_running And Not compression_regulator_running Then
        If hasMultipleMVs Then
            ManualControl1.cregrew.Enabled = True
            ManualControl1.cregff.Enabled = True
            ManualControl1.cregstop.Enabled = False
        Else
            ManualControl.cregrew.Enabled = True
            ManualControl.cregff.Enabled = True
            ManualControl.cregstop.Enabled = False
        End If
    End If
End If

End Sub

Sub update_slurry_wash_pump_flow_display() '6.71.123.10
    x5 = slurry_wash_pump_max_flow_cc * (SlurryPumpSpeedPOS / 4000)
    If hasMultipleMVs Then
        'ManualControl1.slurry_wash_pump_flow.Caption = "Slurry Pump Target Flow: " + Xformat$(SlurryPumpSpeedPOS, "##0") + " counts " + Xformat$(x5, "##0.0") + " cc"
    Else
        ManualControl.slurry_wash_pump_flow.Caption = "Slurry Pump Target Flow: " + Xformat$(SlurryPumpSpeedPOS, "##0") + " counts " + Xformat$(x5, "##0.0") + " cc"
    End If
End Sub

Sub update_units_check(PU$)
' update the check box in the unit menu
' note that this will mess up if they create a user unit that has the same
' name as a previous unit - the check mark will show up on the first unit
' that has the name

    Dim i As Integer, j As Integer

    For i = 0 To 7
        If UCase$(prefsForm.pressCombo.List(i)) = UCase$(PU$) Then Exit For
    Next i
'    For j = 1 To 8
 '       TitleScrn.unitmenu(j).Checked = (j = i)
  '  Next j
    ' if the pressure unit they want is not in the list
    ' default back to PSI
    If i > 7 Then i = 0
    press_unit_index% = i
    
End Sub

Sub UpdateLine26(newCaption As String)
    progress.Line26.Caption = newCaption
    progress.Line26.Refresh
End Sub

Sub UpdateLine25(Optional wetTest As Boolean = False)
' Updated in v6.71.53: if wetTest is true, then include a calculation of pore diameter
' in the line update. If not, then the parameter is meaningless and confusing.

    Dim pore_size As Single
    Dim ztemp$
    Dim temp_vol_flow As Single
    Dim pre_temp_cv As Single
    Dim NoDryCurve As Boolean
    
    ztempPressure$ = ""
    ztempFlow$ = ""
    ztempDiam$ = ""
    
    '============Code alterations made on 04-20-07 by edc=======================================================
    NoDryCurve = False
    If TType(current_unit) = 1 And TMode(current_unit) <> 4 Then
        NoDryCurve = True
    End If
    '============End code addition 04-20-07=====================================================================
    If P < P0 And (Not lock_p0) Then
        P0 = P
    End If
    If f < 0 Then f = 0
    On Error Resume Next
    If wetTest Then pore_size = 0.58042 * tfactor * surfTen(current_unit%) / (P - P0)   ' if not wettest then diam=0 and code below does not execute
    ztemp$ = ts$(229) + ": " + Xformat$((P - P0) * PCNV, "###0.000  ") + PU$    ' "Pressure"
    ztempPressure$ = Xformat$((P - P0) * PCNV, "###0.000  ")
    'ztempPressure$ = ts$(229) + ": " + vbTab + Xformat$((P - P0) * PCNV, "###0.000  ") + vbTab + PU$ ' "Pressure"
    
    If Not diffpgflow(current_unit%) Then
        ztempFlow$ = flowformat$(f)
      'ztempFlow$ = "   " + ts$(30) + ": " + vbTab + flowformat$(f) + vbTab + " cc/min" ' "Flow"/"cc/min"
      ztemp$ = ztemp$ + "   " + ts$(30) + ": " + flowformat$(f) + " cc/min"  ' "Flow"/"cc/min"
    End If
    '============Code alterations made on 04-20-07 by edc=======================================================
    ' removed this test until we figure out whas it should actually be doing - rvw 7-30-07
    ' added in test of pass variable, which may do what is needed - rvw 8-1-07
    If pore_size > 0 And pass < 2 Then 'And NoDryCurve = False Then
        'ztempDiam$ = ts$(277) + ": " + vbTab                           ' "Diam"
        ztemp$ = ztemp$ + "   " + ts$(277) + ": "                               ' "Diam"
        If pore_size >= 100 Then
            ztemp$ = ztemp$ + Xformat$(0.58042 * tfactor * surfTen(current_unit%) / (P - P0), "######0.") + " " + ts$(278)      ' "microns"
            ztempDiam$ = Xformat$(0.58042 * tfactor * surfTen(current_unit%) / (P - P0), "######0.")
            'ztempDiam$ = ztempDiam$ + Xformat$(0.58042 * tfactor * surfTen(current_unit%) / (P - P0), "######0.") + vbTab + ts$(278)     ' "microns"
        ElseIf pore_size >= 10 Then
            ztemp$ = ztemp$ + Xformat$(0.58042 * tfactor * surfTen(current_unit%) / (P - P0), "##0.0") + " " + ts$(278)      ' "microns"
            ztempDiam$ = Xformat$(0.58042 * tfactor * surfTen(current_unit%) / (P - P0), "##0.0")
            'ztempDiam$ = ztempDiam$ + Xformat$(0.58042 * tfactor * surfTen(current_unit%) / (P - P0), "##0.0") + vbTab + ts$(278)     ' "microns"
        ElseIf pore_size >= 1 Then
            ztemp$ = ztemp$ + Xformat$(0.58042 * tfactor * surfTen(current_unit%) / (P - P0), "#0.00") + " " + ts$(278)      ' "microns"
            ztempDiam$ = Xformat$(0.58042 * tfactor * surfTen(current_unit%) / (P - P0), "#0.00")
            'ztempDiam$ = ztempDiam$ + Xformat$(0.58042 * tfactor * surfTen(current_unit%) / (P - P0), "#0.00") + vbTab + ts$(278)      ' "microns"
        ElseIf pore_size >= 0.1 Then
            ztemp$ = ztemp$ + Xformat$(0.58042 * tfactor * surfTen(current_unit%) / (P - P0), "0.000") + " " + ts$(278)      ' "microns"
            ztempDiam$ = Xformat$(0.58042 * tfactor * surfTen(current_unit%) / (P - P0), "0.000")
            'ztempDiam$ = ztempDiam$ + Xformat$(0.58042 * tfactor * surfTen(current_unit%) / (P - P0), "0.000") + vbTab + ts$(278)      ' "microns"
        Else
            ztemp$ = ztemp$ + Xformat$(0.58042 * tfactor * surfTen(current_unit%) / (P - P0), "0.0000") + " " + ts$(278)      ' "microns"
            ztempDiam$ = Xformat$(0.58042 * tfactor * surfTen(current_unit%) / (P - P0), "0.0000")
            'ztempDiam$ = ztempDiam$ + Xformat$(0.58042 * tfactor * surfTen(current_unit%) / (P - P0), "0.0000") + vbTab + ts$(278)      ' "microns"
        End If
    Else
       ztemp$ = ztemp$
       ztempDiam$ = ztempDiam$
       
    '============End code addition 04-20-07=====================================================================
    End If
    If diffpgflow(current_unit%) Then
        ztemp$ = ztemp$ + "   " + ts$(311) + ": " + Xformat$(diffp * PCNV, "###0.0000  ") + PU$ ' "DiffP"
    End If
    progress.Line25.Caption = ztemp$
    On Error GoTo 0
    progress.Line25.Refresh
    
End Sub


Sub Valve_Test()

    Dim Valve_Iter As Integer
    Dim i%, r As Integer
    Dim XTime As Single
    
    GetValue.Label1.Caption = ts$(393)      ' "Enter number of iterations for Valve 2 Test"
    GetValue.Continue.default = True
    GetValue.Show 1
    If Got_Value > 0 Then
        Valve_Iter = Got_Value
    Else
        MsgBox ts$(394)                     ' "Valve 2 testing cancelled"
        Exit Sub
    End If
    reply% = MsgBox(ts$(395) + " " + str$(Valve_Iter) + " " + ts$(396) + "." + vbCrLf + ts$(397), 1, ts$(398)) ' "Valve 2 will open and close"/"times"/"Press 'A' to abort test."/"Valve 2 Test"
    If reply% = 2 Then Exit Sub

    Cancel_Aborted = False
    If hasMultipleMVs Then
        ManualControl1.Timer1.Enabled = False
    Else
        ManualControl.Timer1.Enabled = False
    End If
    For i% = 1 To Valve_Iter
        If Cancel_Aborted = True Then Exit For
        r = Move2_Error("O", i%, Valve_Iter)
        If r = 1 Then
            MsgBox ts$(399) + vbCrLf + ts$(400)          ' "Valve 2 failed to open completely and timed-out."/"Please check."
            Cancel_Aborted = True
        End If
        If Cancel_Aborted = True Then Exit For
        'XTime = Timer: While (Timer - XTime) < 4: DoEvents: Wend
        waitseconds 4
        r = Move2_Error("C", i%, Valve_Iter)
        If r = 0 Then
            MsgBox ts$(401) + vbCrLf + ts$(400)          ' "Valve 2 failed to close completely and timed-out."/"Please check."
            Cancel_Aborted = True
        End If
        'XTime = Timer: While (Timer - XTime) < 4: DoEvents: Wend
        waitseconds 4
    Next i%
    If hasMultipleMVs Then
        ManualControl1.Timer1.Enabled = True
    Else
        ManualControl.Timer1.Enabled = True
    End If
    
End Sub

Sub VPulse(Index As Integer)

    Send_RS232 ("I" + Chr$(64 + Index))
    
End Sub

Function Xformat$(ByVal XVal, XStr$)

    Dim a$
    
    a$ = Format$(XVal, XStr$)
    a$ = String$(Abs(Len(XStr$) - Len(a$)), " ") + a$
    Xformat$ = a$

End Function

Sub zero_creg()
' version 6 always does the zero_reg thing since it
' is so simple and fast if already zero

Dim bestseen As Long, timeout As Single, lasttime As Single

If ip_creg_enable Then
    Send_RS232 "Z3"
    CREGPOS = 0
Else
    Send_RS232 ("CP")
    bestseen = raw_reading(31)
    timeout = Timer
    While RSEcho("VP", 1) <> Asc("S")
        tryhold
        CREGPOS = raw_reading(31)
        If CREGPOS < bestseen Then timeout = Timer
        lasttime = Timer
        If timeout > lasttime + 0.1 Then timeout = timeout - 86400
        If (lasttime - timeout) > 5 Then
            Send_RS232 ("SP")
            MsgBox (ts$(402))       ' "The compression regulator may have a problem with the low limit setting"
        End If
    Wend
End If

End Sub

Sub zero_SlurryPumpSpeed() '6.71.123.23
    Send_RS232 "Z3"
    SlurryPumpSpeedPOS = 0
End Sub

Sub zero_lfctrl()
    Send_RS232 "Z2"
    lfcpos = 0
End Sub



Sub Zero_Reg()

    Dim T As Single
    Dim bestseen As Long, timeout As Single, lasttime As Single
  
    If hasHumidityControls Then
        'disable bubbler enable
        Move_Valve 3, "O" 'set bubbler enable
        If manrunning Then
            If hasMultipleMVs Then
                ManualControl1.show_valve_closed 18
            Else
                ManualControl.show_valve_closed 18
            End If
        End If
        Waitms 500, False
        
        'open vent valve
        Move_Valve 2, "O" 'open vent valve (hardware valve 3)
        If manrunning Then
            If hasMultipleMVs Then
                ManualControl1.show_valve_open 3
            Else
                ManualControl.show_valve_open 3
            End If
        End If
        
        Waitms 500, False
    End If
  
    If PA <> 0 Then
        If newreg Then
        ' motorized regulator always does the zero_reg thing since it
        ' is so simple and fast if already zero
            Send_RS232 ("CE")
            bestseen = raw_reading(18)
            timeout = Timer
            If Not manrunning Then
                While RSEcho("VE", 1) <> Asc("S")
                    tryhold
                    REGPOS = raw_reading(18)
                    If REGPOS < bestseen Then timeout = Timer
                    lasttime = Timer
                    If timeout > lasttime + 0.1 Then timeout = timeout - 86400
                    If (lasttime - timeout) > 5 Then
                        Send_RS232 ("SE")
                        MsgBox (ts$(403))       ' "The motorized regulator may have a problem with the low limit setting"
                    End If
                Wend
            End If
        ElseIf ip_reg_enable Then
        ' ip regulator is always zeroed since it is so fast
            Send_RS232 "Z1"
        ElseIf (Not last_reg_status) Or manrunning Then
        ' we don't zero it if not in manual control and we last did this.

            ' old regulator on version 6
            Move_Valve 7, "O"
            Move_Valve 6, "O"
            'T = Timer
            'While (Timer - T) < reg_zero_time And Timer >= T          ' 5 SECOND DELAY
            '    DoEvents
            'Wend
            waitseconds reg_zero_time
            Move_Valve 7, "C" ' this will also close 7(G)
        End If
  End If
  REGPOS = 0
  last_reg_status = True
  
    If hasHumidityControls Then
        'Wait until the pressure is low before closing the vent valve
'        ReadXReturnX4 2
'        Dim start As Single
'        start = Timer
'        While x5 > 16 And Timer - start < 10 'make sure the pressure is below 16 psi or 10 seconds have passed
'            ReadXReturnX4 2
'            DoEvents
'        Wend
        
        Status.Command1.Visible = False
        Status.Label2.Caption = "Waiting for pressure to vent..."
        Status.Label2.Visible = True
        Status.Show 0
        Waitms zeroRegVentTime, False 'wait 20 seconds for air to vent
        Status.Hide
        Status.Label2.Caption = ""
        Status.Command1.Visible = True
        
        Move_Valve 2, "C" 'close vent valve (hardware valve 3)
        If manrunning Then
            If hasMultipleMVs Then
                ManualControl1.show_valve_closed 3
            Else
                ManualControl.show_valve_closed 3
            End If
        End If
    End If
  
End Sub

Function CalcGP(a$) As Single

Dim X As tcftfile, abc As Single, i As Integer, mu As Single
Dim j As Integer, k As Single, ksum, fl0, klast, kfinal, fllast, plast As Single
Dim formstat As String
Dim pfirst As Single
Dim goodCount As Integer

load_cftfile X, a$

If X.cfttype <> ect_efd And X.cfttype <> ect_esa And X.cfttype <> ect_permeability Then
    FResult = FResult + vbCrLf + ts$(404)       ' "Couldn't calculate final result due to incorrect data file type"
    CalcGP = -1000
    Exit Function
End If

If Not X.diam_valid Then
    FResult = FResult + vbCrLf + ts$(405)       ' "Couldn't calculate final result due to invalid diameter"
    CalcGP = -1001
    Exit Function
End If

If X.P0 = 0 Then
    FResult = FResult + vbCrLf + ts$(406)       ' "Couldn't calculate final result due to 0 atmospheric pressure"
    CalcGP = -1002
    Exit Function
End If

If X.cyl_len = 0 Then
    abc = 3.14159265 * X.diameter * X.diameter / 4
Else
    abc = 2 * 3.14159265 * X.cyl_len * X.thickness / Log((X.diameter + 2 * X.thickness) / X.diameter)
End If

Select Case X.pgl.type
    Case epgl_undefined
        mu = 0
    Case epgl_nitrogen
        mu = 0.0185
    Case epgl_water
        mu = 1
    Case epgl_air
        mu = 0.0185
    Case epgl_helium
        mu = 0.0198
    Case epgl_argon
        mu = 0.0221
    Case epgl_other
        mu = X.pgl.viscosity
End Select

If mu <= 0 Then
    FResult = FResult + vbCrLf + ts$(407)       ' "Couldn't calculate final result due to invalid viscosity value"
    CalcGP = -1003
    Exit Function
End If

' make sure first data point is not atmospheric pressure
Do While X.num_dry_points > 0
    If X.dry_data.a(1).pr <> X.P0 Then
        Exit Do
    End If
    ' skip the first point
    X.num_dry_points = X.num_dry_points - 1
    For i = 1 To X.num_dry_points
        X.dry_data.a(i) = X.dry_data.a(i + 1)
    Next i
Loop

If X.num_dry_points = 0 Then
    FResult = FResult + vbCrLf + ts$(408)       ' "Couldn't calculate final result due to no valid data points"
    CalcGP = -1004
    Exit Function
End If

' make sure all subsequent data points do not have the same pressure as the previous
i = 2
Do While X.num_dry_points >= i
    If X.dry_data.a(i).pr <> X.dry_data.a(i - 1).pr Then
        i = i + 1
    Else
        ' skip this point
        X.num_dry_points = X.num_dry_points - 1
        For j = i To X.num_dry_points
            X.dry_data.a(j) = X.dry_data.a(j + 1)
        Next j
    End If
Loop

' now go through remaining data point
goodCount = 0
For i = 1 To X.num_dry_points
    With X.dry_data.a(i)
        ' subtract atmospheric pressure
        .pr = .pr - X.P0
        ' divide flow by 60
        .fl = .fl / 60
        ' calculate darcys
        k = .fl * X.thickness * mu * 14.7
        ' added to prevent a possible divide by zero error
        If mu < 0.25 Then
            k = 2 * k * 14.7 / abc / ((X.P0 + .pr) * (X.P0 + .pr) - X.P0 * X.P0) 'Darcy's permeability constant
        Else
            k = k / abc / .pr ' for liquid tests
        End If
        ' now that we have the darcy value in K, process it so we can find the average
        If .pr <> 0 And .fl <> 0 Then
            goodCount = goodCount + 1
            If pfirst = 0 Then        ' 6.71.64: if i = 1
               ' ksum = 0
                fl0 = .fl
                pfirst = .pr
            End If
            If goodCount > 1 Then           ' 6.71.64: if i > 1
                ' 6.71.64 Previous form of next line:
                ' ksum = ksum + (k + Abs(k - klast) / 2) * (.fl - fllast)
                ksum = ksum + ((k + klast) / 2) * (.pr - plast)
            End If
            If i = X.num_dry_points Then ' last data point - do final calcs
                If X.num_dry_points > 1 Then
                    kfinal = ksum / (.pr - pfirst)                          ' 6.71.64 changed from (.fl - fl0)
                Else
                    kfinal = k
                End If
            End If
            klast = k 'used to hold last k value
            fllast = .fl
            plast = .pr
        End If
        
    End With
Next i
formstat = "##0.000"
If kfinal > 999.999 Or kfinal < 0.01 Then formstat = "Scientific"
FResult = ts$(409) + " = " + Format(kfinal, formstat)       ' "Average Darcy Permeability Constant"
CalcGP = kfinal

If LoopingDemo Then LDtempValue = kfinal

End Function

Sub CalcMFP(a$)

Dim X As tcftfile
Dim i As Integer, j As Integer, f As Single, original_j As Integer
Dim BD As Single, BW As Single, MD As Single, MW As Single


load_cftfile X, a$
' must be porometry test
If X.cfttype <> ect_porometry Then
    FResult = FResult + vbCrLf + ts$(410)           ' "Couldn't calculate Mean Flow Pressure due to incorrect data file type"
    Exit Sub
End If
' must have at least two wet points and at least two dry points
If X.num_dry_points < 2 Then
    FResult = FResult + vbCrLf + ts$(411)           ' "Couldn't calculate Mean Flow Pressure due to not enough dry points"
    Exit Sub
End If
If X.num_wet_points < 2 Then
    FResult = FResult + vbCrLf + ts$(412)           ' "Couldn't calculate Mean Flow Pressure due to not enough wet points"
    Exit Sub
End If
' scan through the wet and dry curves and throw out points that are going in
' the wrong direction - pressure must always be going up for this to work
i = 2
Do
    If X.wet_data.a(i).pr <= X.wet_data.a(i - 1).pr Then
        ' remove point at i
        If i < X.num_wet_points Then
            For j = i + 1 To X.num_wet_points
                X.wet_data.a(i) = X.wet_data.a(j)
            Next j
        End If
        X.num_wet_points = X.num_wet_points - 1
        ' recheck current i point on next pass
        ' if we just ran into the end, the exit condition will take care of this
    Else
        ' current i point is ok, go to next one
        i = i + 1
    End If
Loop Until i > X.num_wet_points
If X.num_wet_points < 2 Then
    FResult = FResult + vbCrLf + ts$(413)       ' "Couldn't calculate Mean Flow Pressure due to not enough wet points after removing duplicates and backwards going points"
    Exit Sub ' just in case we threw away everything
End If
i = 2
Do
    If X.dry_data.a(i).pr <= X.dry_data.a(i - 1).pr Then
        ' remove point at i
        If i < X.num_dry_points Then
            For j = i + 1 To X.num_dry_points
                X.dry_data.a(i) = X.dry_data.a(j)
            Next j
        End If
        X.num_dry_points = X.num_dry_points - 1
        ' recheck current i point on next pass
        ' if we just ran into the end, the exit condition will take care of this
    Else
        ' current i point is ok, go to next one
        i = i + 1
    End If
Loop Until i > X.num_dry_points
If X.num_dry_points < 2 Then
    FResult = FResult + vbCrLf + ts$(414)       ' "Couldn't calculate Mean Flow Pressure due to not enough dry points after removing duplicates and backwards going points"
    Exit Sub ' just in case we threw away everything
End If

i = 1 ' current wet point we are looking at
j = 2 ' current dry point we are looking at - we are actually looking between
    ' dry point j and dry point j-1
Do
    ' for current wet point, increment j until dry points j and j-1 are bounding
    ' the pressure of the wet point
    ' but don't let j go over the number of dry points
    While X.dry_data.a(j).pr < X.wet_data.a(i).pr And j < X.num_dry_points
        j = j + 1
    Wend
    ' now find the flow (f) for the current dry point pair at the current wet point
    ' pressure
    f = (X.wet_data.a(i).pr - X.dry_data.a(j - 1).pr) / (X.dry_data.a(j).pr - X.dry_data.a(j - 1).pr) * (X.dry_data.a(j).fl - X.dry_data.a(j - 1).fl) + X.dry_data.a(j - 1).fl
    ' if the flow is less than or equal to twice the flow of the current wet point,
    ' we have found our MFP (unless we are on the first wet point).  In either case,
    ' we want to exit
    If f <= X.wet_data.a(i).fl * 2 Then Exit Do
    ' otherwise, we want to go to the next wet point (if any)
    ' if there are no more wet points, we want to exit the sub because we
    ' don't have enough wet points to find the mfp
    If i = X.num_wet_points Then
        FResult = FResult + vbCrLf + ts$(415)       ' "Couldn't calculate Mean Flow Pressure due to not enough wet flow to reach 1/2 dry flow"
        Exit Sub
    End If
    i = i + 1
Loop
' if we are still on the first wet point, then we can't find the mfp
If i = 1 Then
    FResult = FResult + vbCrLf + ts$(416)           ' "Couldn't calculate Mean Flow Pressure due to first wet point being too high flow"
    Exit Sub
End If
' the mfp is now at the intersection of dry (j-1),j and wet (i-1,i)
' using 1/2 of the flow for the dry
original_j = j
mfp_calc_retry:
MD = (X.dry_data.a(j).fl / 2 - X.dry_data.a(j - 1).fl / 2) / (X.dry_data.a(j).pr - X.dry_data.a(j - 1).pr)
BD = X.dry_data.a(j).fl / 2 - MD * X.dry_data.a(j).pr
MW = (X.wet_data.a(i).fl - X.wet_data.a(i - 1).fl) / (X.wet_data.a(i).pr - X.wet_data.a(i - 1).pr)
BW = X.wet_data.a(i).fl - MW * X.wet_data.a(i).pr
' just in case - to avoid divide by zero
If MD = MW Then
    FResult = FResult + vbCrLf + ts$(417)       ' "Couldn't calculate Mean Flow Pressure due to intersection calculation problem"
    Exit Sub
End If
MFP = (BW - BD) / (MD - MW)
' since we did not look at every dry point pair, we may need to go back one
' to find the dry points that intersect properly
If MFP < X.dry_data.a(j - 1).pr And j > 2 Then
    j = j - 1
    GoTo mfp_calc_retry
End If
' double check to see if the MFP is within the wet point bounds
If MFP < X.wet_data.a(i - 1).pr And i > 2 Then
    ' try going back one in the wet data
    i = i - 1
    ' this should never happen, so if it does let the user know about this
    ' so they can tell us
    MsgBox ts$(418) + "..."     ' "Notice: The MFP calculation had a problem finding the proper wet curve pair - retrying"
    ' also set back to original j just in case we skipped to low on the dry curve
    j = original_j
    GoTo mfp_calc_retry
End If
If X.wet_data.a(i).pr >= MFP And MFP >= X.wet_data.a(i - 1).pr Then
    ' make sure MFP is above the lowest dry pressure value (though it can be above the
    ' highest dry pressure value as we can extrapolate a dry curve that didn't go high
    ' enough
    If MFP < X.dry_data.a(j - 1).pr Then
        ' don't trust the calculation, so don't report it
        FResult = FResult + vbCrLf + ts$(419)   ' "Couldn't calculate Mean Flow Pressure due to dry pressure problem"
        Exit Sub
    End If
    ' we can now trust the MFP value, so report it
    FResult = FResult + vbCrLf + ts$(420) + ": " + Format$((MFP - X.P0) * PCNV, "###0.000 (") + PU$ + "),   " + ts$(277) + ": " + Format$(0.58042 * X.tfactor * X.surfTen / (MFP - X.P0), "######0.0000") + " (" + ts$(278) + ")" ' "Mean Flow Pressure"/"Diam"/"microns"
    logFileResults(2) = 0.58042 * X.tfactor * X.surfTen / (MFP - X.P0)
    Exit Sub
End If
FResult = FResult + vbCrLf + ts$(421)       ' "Couldn't calculate Mean Flow Pressure due to wet pressure problem"

End Sub

Sub do_final_copy()

    Dim X As tcftfile, i As Integer
    Dim Y As tcftfile, j As Integer
    Dim fnum As Integer
    Dim a$
    Dim filenameBase$
    Dim filenamewithPreBPdata$
    

top:
    If LCase$(Right$(OutFilename$(current_unit%), 25)) = "do not save data file.cft" Then
        Exit Sub
    End If
    
    On Error Resume Next

    ' before we copy the file over to the final place, update some information in the header
    load_cftfile X, EXE_Path$ + "lastdata.cft"
    ' search through the extended stuff for things we need to change
    ' more things may be added here
    For i = 1 To X.num_extended
        If X.extended_name(i) = "Total Settling Time" Then
            X.extended_value(i) = str$(MF_Total_Settling_time) + " Seconds"
        End If
    Next i
    ' now, if we are a gas permeability test and we were doing the pressure step
    ' routine, interpolate the data
    ' 6.71.61 -- or CFT or liquid perm, too

    If PS_usingList And (X.cfttype = ect_permeability Or ect_porometry) Then
    
        Y = X   ' Copy over original data file - Y is the temporary copy of the old data
        ' add the name of the pressure list file to the extended values
        X.num_extended = X.num_extended + 1
        ReDim Preserve X.extended_name(X.num_extended)
        ReDim Preserve X.extended_value(X.num_extended)
        X.extended_name(X.num_extended) = "Pressure List"
        X.extended_value(X.num_extended) = PS_path$
        
        ' Adjust the dry data file if needed
        If (X.num_dry_points > 1) Then
            ' Now go through pressure step and reset all the data
            i = 2   ' Current starting point in the raw data
            pf_size_check X.dry_data, pressure_steps.count
            If X.temperaturesensor = 1 Then
                ts1_size_check X.ts1_data, pressure_steps.count
            ElseIf X.temperaturesensor = 2 Then
                ts2_size_check X.ts2_data, pressure_steps.count
            End If
            For j = 1 To pressure_steps.count
                X.dry_data.a(j).pr = pressure_steps.values(j) + X.P0
                ' Find i such that original dry_data(i) > current pressure step
                While i < Y.num_dry_points And Y.dry_data.a(i).pr < pressure_steps.values(j) + X.P0
                    i = i + 1
                Wend
                X.dry_data.a(j).fl = (pressure_steps.values(j) + X.P0 - Y.dry_data.a(i - 1).pr) / (Y.dry_data.a(i).pr - Y.dry_data.a(i - 1).pr) * (Y.dry_data.a(i).fl - Y.dry_data.a(i - 1).fl) + Y.dry_data.a(i - 1).fl
                ' for temperature, don't interpolate, just use first value from file
                If X.temperaturesensor = 1 Then
                    X.ts1_data.a(j) = Y.ts1_data.a(i)
                ElseIf X.temperaturesensor = 2 Then
                    X.ts2_data.a(j) = Y.ts2_data.a(i)
                End If
                
            Next j
        End If

        ' Adjust the wet curve if needed
        If (X.num_wet_points > 1) Then
            ' Now go through pressure step and reset all the data
            i = 2   ' Current starting point in the raw data
            pf_size_check X.wet_data, pressure_steps.count
            If X.temperaturesensor = 1 Then
                ts1_size_check X.wet_ts1_data, pressure_steps.count
            ElseIf X.temperaturesensor = 2 Then
                ts2_size_check X.wet_ts2_data, pressure_steps.count
            End If
            For j = 1 To pressure_steps.count
                X.wet_data.a(j).pr = pressure_steps.values(j) + X.P0
                ' Find i such that original wet_data(i) > current pressure step
                While i < Y.num_wet_points And Y.wet_data.a(i).pr < pressure_steps.values(j) + X.P0
                    i = i + 1
                Wend
                X.wet_data.a(j).fl = (pressure_steps.values(j) + X.P0 - Y.wet_data.a(i - 1).pr) / (Y.wet_data.a(i).pr - Y.wet_data.a(i - 1).pr) * (Y.wet_data.a(i).fl - Y.wet_data.a(i - 1).fl) + Y.wet_data.a(i - 1).fl
                If X.temperaturesensor = 1 Then
                    X.wet_ts1_data.a(j) = Y.wet_ts1_data.a(i)
                ElseIf X.temperaturesensor = 2 Then
                    X.wet_ts2_data.a(j) = Y.wet_ts2_data.a(i)
                End If
            Next j
        End If
        
        ' 6.71.63: Reset number of wet and dry points in the interpolated file
        ' If this is not done, the interpolated data could be cut off if there were fewer data points
        ' collected than points in the pressure step list. The interpolations could still all be valid,
        ' though, as long as the maximum pressure in the test went high enough. Thus, we do this:
        X.num_dry_points = pressure_steps.count
        X.num_wet_points = pressure_steps.count
        
    End If      ' pressure step list handling
        
'    If X.cfttype = ect_permeability And PS_usingList And (ltmode% = 2 Or X.num_dry_points > 1) Then
'        Y = X ' copy over original data file
'        ' now go through pressure step and reset all the data
'        i = 2 ' current starting point in the raw data
'        pf_size_check X.dry_data, pressure_steps.count
'        For j = 1 To pressure_steps.count
'            X.dry_data.a(j).pr = pressure_steps.values(j) + X.P0
'            ' find i such that original dry_data(i) > current pressure step
'            While i < Y.num_dry_points And Y.dry_data.a(i).pr < pressure_steps.values(j) + X.P0
'                i = i + 1
'            Wend
'            X.dry_data.a(j).fl = (pressure_steps.values(j) + X.P0 - Y.dry_data.a(i - 1).pr) / (Y.dry_data.a(i).pr - Y.dry_data.a(i - 1).pr) * (Y.dry_data.a(i).fl - Y.dry_data.a(i - 1).fl) + Y.dry_data.a(i - 1).fl
'        Next j
'    End If
    
    save_cftfile X, EXE_Path$ + "lastdata2.cft"
    
    ' Check to see if automatic curve fitting is selected. If so, call the fitting routine. (Do not
    ' do this if we're using a pressure step list.)
    ' 6.71.62 Don't do this for tests where it doesn't make sense: bubble point/integrity/hydro
    If autoCurveFit And Not PS_usingList And TType%(current_unit%) <> 2 Then
        ' This uses the default settings - user must call the routine manually for now to set them.
        Curve.CapCurve curve_nump, curve_perc / 100, curve_maxd * PCNV, EXE_Path$ + "lastdata2.cft"
    End If
    
    ' if we are doing gas permeability and want the new gas permeability logging feature...
    If X.cfttype = ect_permeability And permeabilityLogging = True Then
        fnum = FreeFile
        If Dir$(permeabilityLoggingFile) = "" Then
            Open permeabilityLoggingFile For Output As #fnum
            Print #fnum, "Measurement #"; vbTab; "Permeability"
            i = 1
        Else
            Open permeabilityLoggingFile For Input As #fnum
            While Not EOF(fnum)
                Line Input #fnum, a$
                j = InStr(a$, vbTab)
                If j > 1 Then
                    i = val(Left$(a$, j - 1))
                Else
                    i = 0
                End If
                'MsgBox "Line=" + a$ + vbCrLf + "i=" + Str$(i)
            Wend
            i = i + 1
            Close #fnum
            Open permeabilityLoggingFile For Append As #fnum
        End If
        Print #fnum, i; vbTab; str$(CalcGP(EXE_Path$ + "lastdata2.cft"))
        Close #fnum
    End If
    
    FileCopy EXE_Path$ + "lastdata2.cft", OutFilename$(current_unit%)
    
    If savePreBPdata Then
        filenameBase$ = Left$(OutFilename$(current_unit%), Len(OutFilename$(current_unit%)) - 4) '7.73.011.01
        filenamewithPreBPdata$ = filenameBase$ + "_PreBPdata.dat" '7.73.011.01
        FileCopy EXE_Path$ + "PreBPdata.dat", filenamewithPreBPdata$ '7.73.011.02
    End If
    
    'Edited 12-20-07 --Denis
    'Increase file name ID for some test file name if sequential testing is being done
    If sequentialTesting = True Then
        Name OutFilename$(current_unit%) As Left$(OutFilename$(current_unit%), _
            Len(OutFilename$(current_unit%)) - 4) + "-" + str(fileIncreaseNum) + ".cft"
    End If
    
    If Err.Number = 0 Then Exit Sub
    
'    On Error GoTo 0
'
'    MsgBox ts$(422)         ' "There was an error saving your data file to the location you specified.  Please choose a valid destination for your data file."
'    fsel_name$ = OutFilename$(current_unit%)
'    fsel_title$ = ts$(423)          ' "Output Data File"
'    fsel_path$ = path(0)
'    fsel_io = False
'    fsel TitleScrn.hwnd
'    If fsel_return$ = "" Then
'        MsgBox ts$(424)             ' "You have not selected an output file location.  The data from the last test is located in the same directory as the CAPWIN.EXE program, with the name LASTDATA.CFT.  This file will only be valid until the next test is run."
'        Exit Sub
'    End If
'    OutFilename$(current_unit%) = fsel_return$
'
'    GoTo top

End Sub

Sub do_purge_system()

    Dim T As Single, i As Integer

    If MsgBox(ts$(464), vbOKCancel) = vbCancel Then Exit Sub        ' "Install sample, close chamber, connect vacuum tubing with valve turned off in preparation for purge"

    GetValue.Label1.Caption = ts$(465)  ' "Enter number of purge cycles"
    GetValue.Text1.Text = Format$(num_vacuum_purge_cycles)
    GetValue.Text1.SelStart = 0
    GetValue.Text1.SelLength = 0
    GetValue.Continue.default = True
    GetValue.Show 1
    If Got_Value = -9 Then Exit Sub
    If Got_Value < 10 Then num_vacuum_purge_cycles = Got_Value Else num_vacuum_purge_cycles = 10
    If num_vacuum_purge_cycles < 1 Then num_vacuum_purge_cycles = 1

    WPPS "Capstuff", "num_vacuum_purge_cycles", str$(num_vacuum_purge_cycles), CSFile$
    Status.Caption = ts$(466)       ' "Status of Purge System"
    Status.Show 0
    
    If autocompress And compression_pressure <> 0 And current_unit% = 1 Then
        Status.Label1.Caption = ts$(467)        ' "Compressing Sample Chamber"
        If safetydown Then
            If safetydowndoor Then
                ' do auto door switch thing instead of key press thing
                check_safety_door True
            Else
                safetykeypress.mainlabel.Caption = ts$(206)         ' "Piston About To Lower"
                safetykeypress.Show 1
            End If
            If safety_canceled Then
                Aborted = True
                Exit Sub
            End If
        End If
        move_piston "O"
        '6.71.61 Give piston time to close
        'T = Timer
        'While (Timer - T <= pistonDelayTime): DoEvents: Wend
'        waitseconds pistonDelayTime
        '****
    End If
    
    For i = 1 To num_vacuum_purge_cycles
        GoSub flow_gas
        GoSub evacuate
    Next i
    
    GoSub flow_gas

    ' vent - close valve 2 and return
    Send_RS232 "C" + mv1_index_char
    Status.Label1.Caption = ts$(468)        ' "Venting"
    Status.Label2.Caption = ts$(469)        ' "Waiting for valve 2 to close"
    Status.Command1.Enabled = True ' cancel previous aborts
    
    While RSEcho("V" + mv1_index_char, 1) <> Asc("S") And Status.Command1.Enabled = True
        DoEvents
    Wend
    Send_RS232 "S" + mv1_index_char
    
    MsgBox ts$(470)         ' "Remove vacuum tubing"
    Unload Status
    just_did_vacuum_purge = True
    
    Exit Sub
    
flow_gas:

    Status.Label1.Caption = ts$(471)        ' "Flow Gas"
    Status.Label2.Caption = ts$(71)         ' "Opening valve 2"
    Send_RS232 "O" + mv1_index_char
    Status.Command1.Enabled = True ' cancel previous aborts
    Do
        ReadXReturnX4 3
        If x4 > (cLimit + oLimit) / 2 Or Status.Command1.Enabled = False Then Exit Do
    Loop
    Send_RS232 "S" + mv1_index_char
    
    ' open venting valves
    Move_Valve 2, "O"
    Move_Valve 11, "O"
    Move_Valve 13, "O"
    Move_Valve 19, "O"
    
    ' increase regulator until above 1 liter/min flow rate on hflow1
    HFLOW% = 1 ' low range of hflow1 should be ok
    Status.Command1.Enabled = True ' cancel previous aborts
    Do
        ReadXReturnX4 1
        Status.Label2.Caption = ts$(305) + "=" + Xformat$(x5, "####0.0")    ' "Flow rate"
        If x5 >= 1000 Or Status.Command1.Enabled = False Then Exit Do
        inc_reg 10
    Loop
    
    Status.Label2.Caption = ts$(472)        ' "Flowing for 10 seconds"
    T = Timer
    Do
        ReadXReturnX4 1
        If x5 >= 1000 Then lower_reg 10 Else inc_reg 10
        If T > Timer + 0.1 Then T = T - 86400
        If (Timer - T) >= 10 Or Status.Command1.Enabled = False Then Exit Do
    Loop
    
    Zero_Reg
    Return
    
evacuate:
    Status.Label1.Caption = ts$(473)        ' "Evacuating System"
    Status.Label2.Caption = ts$(474)        ' "Setup"
    Move_Valve 2, "C"
    Move_Valve 11, "C"
    Move_Valve 13, "C"
    Move_Valve 19, "C"
    
    MsgBox ts$(475)                         ' "Turn on vacuum valve"
    Send_RS232 "C" + mv1_index_char
    Status.Label2.Caption = ts$(469)        ' "Waiting for valve 2 to close"
    Status.Command1.Enabled = True ' cancel previous aborts
    While RSEcho("V" + mv1_index_char, 1) <> Asc("S") And Status.Command1.Enabled = True
        DoEvents
    Wend
    Send_RS232 "S" + mv1_index_char
    
    Status.Label1.Caption = ts$(476)        ' "Evacuating for 30 seconds"
    T = Timer
    Do
        Pres% = 1
        ReadXReturnX4 2
        Status.Label2.Caption = ts$(229) + "=" + Xformat$(x5, "###0.####")  ' "Pressure"
        If T > Timer + 0.1 Then T = T - 86400
        If (Timer - T) >= 30 Or Status.Command1.Enabled = False Then Exit Do
    Loop
    
    MsgBox ts$(477)                         ' "Turn off vacuum valve"
    Return
    
End Sub

Sub Dry_Chamber_Control(d As String)

    If hasHumidityControls Then
        Exit Sub
    End If

    ' this replaces most calls to move_valve 3,X, with d set to the opposite of X
    If d = "O" Then
        If (dry_chambers <= 1) Or (manuallySelectedChamber = 1) Then
            ' close 4 so flow is not diverted to the penetrometer
            Move_Valve 3, "C"
            If dry_chambers > 1 Then
                ' close 5 so flow does not go to second chamber
                Move_Valve 4, "C"
            End If
        Else
            ' open 4 so flow is diverted to the penetrometer (where it will be trapped by a close valve 9)
            Move_Valve 3, "O"
            ' open 5 so flow goes to the second chamber
            Move_Valve 4, "O"
        End If
    Else
        ' open 4 so flow is diverted to the penetrometer (where it may go, depending on valve 9)
        Move_Valve 3, "O"
        If dry_chambers > 1 Then
            ' close 5 so flow doesn't go to the second chamber
            Move_Valve 4, "C"
        End If
    End If

End Sub

Sub EFD_Jump()
' This is to jump up the flow to near maxflow for EFD tests

    Dim initf As Single
    Dim time_s As Single
    Dim time_n As Single

    ReadXReturnX4 1
    initf = x5

    If TType%(current_unit%) = 3 And TMode%(current_unit%) = 2 Then
        V2POS = 0.5 * (oLimit + cLimit)
        OpenV2Pos
        ReadXReturnX4 1
        Do While x5 - initf < 0.95 * MAXFLOW
            inc_reg 10
            'time_s = Timer
            'Do
            '    DoEvents
            '    time_n = Timer
            '    If time_n + 0.1 < time_s Then time_s = time_s - 86400
            'Loop While time_n < time_s + 1
            waitseconds 1
            ReadXReturnX4 1
        Loop
        Do While x5 - initf >= 0.95 * MAXFLOW
            V2POS = V2POS - 100
            Move2V2Pos
            'time_s = Timer
            'Do
            '    DoEvents
            '    time_n = Timer
            '    If time_n + 0.1 < time_s Then time_s = time_s - 86400
            'Loop While time_n < time_s + 0.25
            waitseconds 0.25
            ReadXReturnX4 1
        Loop
    End If
    
End Sub
Sub load_user_stuff(u$)

    If u$ = "" Then
        load_user_global_stuff
    End If
    load_user_unit_stuff u$
    
End Sub

Sub save_user_stuff(u$)
    
    If u$ = "" Then
        save_user_global_stuff
    End If
    save_user_unit_stuff (u$)

End Sub

Sub load_user_unit_stuff(u$)
    Dim temp As String
    Dim Ret$, r As Long
    Dim i As Integer
    
    Ret$ = String$(255, vbNullChar)
    Curr_U$ = LTrim$(RTrim$(Curr_U$))
    r = GPPS(Curr_U$, "File" & u$, "", Ret$, 255, IFile$)
    OutFilename$(current_unit%) = nulltrim(Ret$)
    r = GPPS(Curr_U$, "Line1" & u$, "", Ret$, 255, IFile$)
    Line1$(current_unit%) = nulltrim(Ret$)
    r = GPPS(Curr_U$, "Line2" & u$, "", Ret$, 255, IFile$)
    Line2$(current_unit%) = nulltrim(Ret$)
    r = GPPS(Curr_U$, "Operator" & u$, "", Ret$, 255, IFile$)
    operator$(current_unit%) = nulltrim(Ret$)
    r = GPPS(Curr_U$, "Lot_Number" & u$, "", Ret$, 255, IFile$)
    lot_number$(current_unit%) = nulltrim(Ret$)
    r = GPPS(Curr_U$, "Sid" & u$, "", Ret$, 255, IFile$)
    sid$(current_unit%) = nulltrim(Ret$)
    r = GPPS(Curr_U$, "Fluid" & u$, "PoreWick", Ret$, 255, IFile$)
    fluid$(current_unit%) = nulltrim(Ret$)
    r = GPPS(Curr_U$, "SURFTEN" & u$, "15.9", Ret$, 255, IFile$)
    surfTen(current_unit%) = val(Ret$)
    If surfTen(current_unit%) <= 0 Then surfTen(current_unit%) = 16
    r = GPPS(Curr_U$, "lastdry" & u$, EXE_Path$ + "users\" + Curr_U$ + "\Default.tpf", Ret$, 255, IFile$)
    TPFDRY$(current_unit%) = UCase$(nulltrim(Ret$))
    r = GPPS(Curr_U$, "lastwet" & u$, EXE_Path$ + "users\" + Curr_U$ + "\Default.tpf", Ret$, 255, IFile$)
    TPFWET$(current_unit%) = UCase$(nulltrim(Ret$))
    r = GPPS(Curr_U$, "Diam" & u$, "1", Ret$, 255, IFile$)
    Diam(current_unit%) = val(Ret$)
    
    r = GPPS(Curr_U$, "InnerDiam" & u$, "1", Ret$, 255, IFile$)
    innerDiam(current_unit%) = val(Ret$)
    r = GPPS(Curr_U$, "OuterDiam" & u$, "1", Ret$, 255, IFile$)
    outerDiam(current_unit%) = val(Ret$)
    

    
    If Diam(current_unit%) <= 0 Then Diam(current_unit%) = 1
    r = GPPS(Curr_U$, "Cyl_Len" & u$, "0", Ret$, 255, IFile$)
    cyl_len(current_unit%) = val(Ret$)
    r = GPPS(Curr_U$, "thick" & u$, "1", Ret$, 255, IFile$)
    thick(current_unit%) = val(Ret$)
    If thick(current_unit%) <= 0 Then thick(current_unit%) = 1
    r = GPPS(Curr_U$, "density" & u$, "1", Ret$, 255, IFile$)
    density(current_unit%) = val(Ret$)
    If density(current_unit%) <= 0 Then density(current_unit%) = 1
    r = GPPS(Curr_U$, "mass" & u$, "1", Ret$, 255, IFile$)
    mass(current_unit%) = val(Ret$)
    If mass(current_unit%) <= 0 Then mass(current_unit%) = 1
    r = GPPS(Curr_U$, "minp_set" & u$, "0", Ret$, 255, IFile$)
    minp_set(current_unit%) = val(Ret$)
    r = GPPS(Curr_U$, "maxp_set" & u$, str$(PY2(0)), Ret$, 255, IFile$)
    maxp_set(current_unit%) = val(Ret$)
    r = GPPS(Curr_U$, "Hold_Press" & u$, "20", Ret$, 255, IFile$)
    Hold_Press(current_unit%) = val(Ret$)
    r = GPPS(Curr_U$, "mf_Press" & u$, "20", Ret$, 255, IFile$)
    mf_press(current_unit%) = val(Ret$)
    r = GPPS(Curr_U$, "Hold_Time" & u$, "10", Ret$, 255, IFile$)
    Hold_Time(current_unit%) = val(Ret$)
    r = GPPS(Curr_U$, "mf_Time" & u$, "10", Ret$, 255, IFile$)
    mf_time(current_unit%) = val(Ret$)
    r = GPPS(Curr_U$, "Hold_Delay" & u$, "0", Ret$, 255, IFile$)
    Hold_Delay(current_unit%) = val(Ret$)
    r = GPPS(Curr_U$, "Hold_Rate" & u$, "0", Ret$, 255, IFile$)
    Hold_Rate(current_unit%) = val(Ret$)
    r = GPPS(Curr_U$, "Step_Time" & u$, "1", Ret$, 255, IFile$)
    Step_Time(current_unit%) = val(Ret$)
    r = GPPS(Curr_U$, "TType" & u$, "1", Ret$, 255, IFile$)
    TType%(current_unit%) = val(Ret$)
    r = GPPS(Curr_U$, "TMode" & u$, "1", Ret$, 255, IFile$)
    TMode%(current_unit%) = val(Ret$)
    r = GPPS(Curr_U$, "Liquid" & u$, "Water", Ret$, 255, IFile$)
    Liquid$(current_unit%) = nulltrim(Ret$)
    temp = Liquid$(current_unit%)
    runAsPassFail(current_unit%) = (gpps2(Curr_U$, "RunPassFail" & u$, IFile$, "0") = "1")
    stopTestOnFail(current_unit%) = (gpps2(Curr_U$, "StopOnFail" & u$, IFile$, "0") = "1")
    minPassDiameter(current_unit%) = val(gpps2(Curr_U$, "minPass" & u$, IFile$, ""))
    maxPassDiameter(current_unit%) = val(gpps2(Curr_U$, "maxPass" & u$, IFile$, ""))
    minMedianPass(current_unit%) = val(gpps2(Curr_U$, "minMedianPass", IFile$, "0"))
    maxMedianPass(current_unit%) = val(gpps2(Curr_U$, "maxMedianPass", IFile$, "500"))
    passFailType(current_unit%) = val(gpps2(Curr_U$, "passFailType" & u$, IFile$, "0"))
    
    runFrazierAsPassFail(current_unit%) = (gpps2(Curr_U$, "runFrazierAsPassFail", IFile$, "0") = "1")
    minFrazierPass(current_unit%) = val(gpps2(Curr_U$, "minFrazierPass", IFile$, "0"))
    maxFrazierPass(current_unit%) = val(gpps2(Curr_U$, "maxFrazierPass", IFile$, "10"))
    
    hhRunAsMullen(current_unit%) = (gpps2(Curr_U$, "hhRunAsMullen", IFile$, "0") = "1")
    hhRunAsBurst(current_unit%) = (gpps2(Curr_U$, "hhRunAsBurst", IFile$, "0") = "1")
    hhRunAsHydrohead(current_unit%) = (gpps2(Curr_U$, "hhRunAsHydrohead", IFile$, "0") = "1")
    threestagetest(current_unit%) = (gpps2(Curr_U$, "threeStageTest", IFile$, "0") = "1")
    
    dryChamberTargetTemperature(current_unit%) = val(gpps2(Curr_U$, "DryChamberTargetTemperature" & u$, IFile$, "25"))
    wetChamberTargetTemperature(current_unit%) = val(gpps2(Curr_U$, "WetChamberTargetTemperature" & u$, IFile$, "25"))
    reservoirTargetTemperature(current_unit%) = val(gpps2(Curr_U$, "ReservoirTargetTemperature" & u$, IFile$, "25"))
    airTargetTemperature(current_unit%) = val(gpps2(Curr_U$, "AirTargetTemperature" & u$, IFile$, "25"))
    bubblerTargetTemperature(current_unit%) = val(gpps2(Curr_U$, "BubblerTargetTemperature" & u$, IFile$, "25"))
    cabinetTargetTemperature(current_unit%) = val(gpps2(Curr_U$, "CabinetTargetTemperature" & u$, IFile$, "25"))
    hydroHeadTargetTemperature(current_unit%) = val(gpps2(Curr_U$, "HydroHeadTargetTemperature" & u$, IFile$, "25"))
    mullenTargetTemperature(current_unit%) = val(gpps2(Curr_U$, "MullenTargetTemperature" & u$, IFile$, "25"))
    
    For i = 0 To 7
        setTemperatureForAuto(current_unit%, i) = (gpps2(Curr_U$, "SetTemperatureForAuto" & u$ & i, IFile$, "0") = "1")
        delayTestForTemperature(current_unit%, i) = (gpps2(Curr_U$, "DelayTestForTemperature" & u$ & i, IFile$, "0") = "1")
    Next i
    
    useTemperatureControlForAuto(current_unit%) = (gpps2(Curr_U$, "UseTemperatureControlForAuto" & u$, IFile$, "0") = "1")
    'delayTestForTemperatureControl(current_unit%) = (gpps2(Curr_U$, "DelayTestForTemperatureControl" & u$, IFile$, "0") = "1")
    
    For i = 0 To numberOfAdditionalInfoLines - 1
        infoLineValues(current_unit%, i) = gpps2(Curr_U$, "InfoLineValues" & u$ & i, IFile$, "")
    Next i
    
End Sub

Sub save_user_unit_stuff(u$)
    Dim i As Integer

    WPPS Curr_U$, "File" & u$, OutFilename$(current_unit%), IFile$
    WPPS Curr_U$, "Line1" & u$, Line1$(current_unit%), IFile$
    WPPS Curr_U$, "Line2" & u$, Line2$(current_unit%), IFile$
    WPPS Curr_U$, "Operator" & u$, operator$(current_unit%), IFile$
    WPPS Curr_U$, "Lot_Number" & u$, lot_number$(current_unit%), IFile$
    WPPS Curr_U$, "Sid" & u$, sid$(current_unit%), IFile$
    WPPS Curr_U$, "Fluid" & u$, fluid$(current_unit%), IFile$
    WPPS Curr_U$, "SURFTEN" & u$, str$(surfTen(current_unit%)), IFile$
    WPPS Curr_U$, "lastdry" & u$, TPFDRY$(current_unit%), IFile$
    WPPS Curr_U$, "lastwet" & u$, TPFWET$(current_unit%), IFile$
    WPPS Curr_U$, "Diam" & u$, str$(Diam(current_unit%)), IFile$
    WPPS Curr_U$, "InnerDiam" & u$, str$(innerDiam(current_unit%)), IFile$
    WPPS Curr_U$, "OuterDiam" & u$, str$(outerDiam(current_unit%)), IFile$
    WPPS Curr_U$, "Cyl_Len" & u$, str$(cyl_len(current_unit%)), IFile$
    WPPS Curr_U$, "thick" & u$, str$(thick(current_unit%)), IFile$
    WPPS Curr_U$, "density" & u$, str$(density(current_unit%)), IFile$
    WPPS Curr_U$, "mass" & u$, str$(mass(current_unit%)), IFile$
    WPPS Curr_U$, "minp_set" & u$, str$(minp_set(current_unit%)), IFile$
    WPPS Curr_U$, "maxp_set" & u$, str$(maxp_set(current_unit%)), IFile$
    WPPS Curr_U$, "Hold_Press" & u$, str$(Hold_Press(current_unit%)), IFile$
    WPPS Curr_U$, "Hold_Time" & u$, str$(Hold_Time(current_unit%)), IFile$
    WPPS Curr_U$, "mf_Press" & u$, str$(mf_press(current_unit%)), IFile$
    WPPS Curr_U$, "mf_Time" & u$, str$(mf_time(current_unit%)), IFile$
    WPPS Curr_U$, "Hold_Delay" & u$, str$(Hold_Delay(current_unit%)), IFile$
    WPPS Curr_U$, "Hold_Rate" & u$, str$(Hold_Rate(current_unit%)), IFile$
    WPPS Curr_U$, "Step_Time" & u$, str$(Step_Time(current_unit%)), IFile$
    WPPS Curr_U$, "TType" & u$, str$(TType%(current_unit%)), IFile$
    WPPS Curr_U$, "TMode" & u$, str$(TMode%(current_unit%)), IFile$
    WPPS Curr_U$, "Liquid" & u$, Liquid$(current_unit%), IFile$
    WPPS Curr_U$, "RunPassFail" & u$, IIf(runAsPassFail(current_unit%), "1", "0"), IFile$
    WPPS Curr_U$, "StopOnFail" & u$, IIf(stopTestOnFail(current_unit%), "1", "0"), IFile$
    WPPS Curr_U$, "minPass" & u$, str$(minPassDiameter(current_unit%)), IFile$
    WPPS Curr_U$, "maxPass" & u$, str$(maxPassDiameter(current_unit%)), IFile$
    WPPS Curr_U$, "minMedianPass", str$(minMedianPass(current_unit%)), IFile$
    WPPS Curr_U$, "maxMedianPass", str$(maxMedianPass(current_unit%)), IFile$
    WPPS Curr_U$, "passFailType", str$(passFailType(current_unit%)), IFile$
    
    WPPS Curr_U$, "runFrazierAsPassFail", IIf(runFrazierAsPassFail(current_unit%), "1", "0"), IFile$
    WPPS Curr_U$, "minFrazierPass", str$(minFrazierPass(current_unit%)), IFile$
    WPPS Curr_U$, "maxFrazierPass", str$(maxFrazierPass(current_unit%)), IFile$
    


    
    If threestagetest(current_unit%) Then
        WPPS Curr_U$, "threeStageTest", "1", IFile$
    Else
        WPPS Curr_U$, "threeStageTest", "0", IFile$
    End If
    
    WPPS Curr_U$, "TargetPercPorosity" & u$, TargetPercPorosity, IFile$ '6.71.123.16
    WPPS Curr_U$, "target_thickness" & u$, target_thickness, IFile$ '6.71.123.16
    WPPS Curr_U$, "BuildCakeByPressureTargetPressure" & u$, BuildCakeByPressureTargetPressure, IFile$ '6.71.123.16
    WPPS Curr_U$, "BuildCakeByPressureEndFlow" & u$, BuildCakeByPressureEndFlow, IFile$ '6.71.123.16
    WPPS Curr_U$, "BuildCakeByFlowTargetFlow" & u$, BuildCakeByFlowTargetFlow, IFile$ '6.71.123.16
    WPPS Curr_U$, "BuildCakeByFlowEndPressure" & u$, BuildCakeByFlowEndPressure, IFile$ '6.71.123.16
    WPPS Curr_U$, "SlurryTubeWashCycleTargetFlow" & u$, SlurryTubeWashCycleTargetFlow, IFile$ '6.71.123.16
    
    WPPS Curr_U$, "DryChamberTargetTemperature" & u$, str$(dryChamberTargetTemperature(current_unit%)), IFile$
    WPPS Curr_U$, "WetChamberTargetTemperature" & u$, str$(wetChamberTargetTemperature(current_unit%)), IFile$
    WPPS Curr_U$, "ReservoirTargetTemperature" & u$, str$(reservoirTargetTemperature(current_unit%)), IFile$
    WPPS Curr_U$, "AirTargetTemperature" & u$, str$(airTargetTemperature(current_unit%)), IFile$
    WPPS Curr_U$, "BubblerTargetTemperature" & u$, str$(bubblerTargetTemperature(current_unit%)), IFile$
    WPPS Curr_U$, "CabinetTargetTemperature" & u$, str$(cabinetTargetTemperature(current_unit%)), IFile$
    WPPS Curr_U$, "HydroHeadTargetTemperature" & u$, str$(hydroHeadTargetTemperature(current_unit%)), IFile$
    WPPS Curr_U$, "MullenTargetTemperature" & u$, str$(mullenTargetTemperature(current_unit%)), IFile$
    
    
    For i = 0 To 7
        WPPS Curr_U$, "SetTemperatureForAuto" & u$ & i, IIf(setTemperatureForAuto(current_unit%, i), "1", "0"), IFile$
        WPPS Curr_U$, "DelayTestForTemperature" & u$ & i, IIf(delayTestForTemperature(current_unit%, i), "1", "0"), IFile$
    Next i
    
    WPPS Curr_U$, "UseTemperatureControlForAuto" & u$, IIf(useTemperatureControlForAuto(current_unit%), "1", "0"), IFile$
    'WPPS Curr_U$, "DelayTestForTemperatureControl" & u$, IIf(delayTestForTemperatureControl(current_unit%), "1", "0"), IFile$
    
    For i = 0 To numberOfAdditionalInfoLines - 1
        WPPS Curr_U$, "InfoLineValues" & u$ & i, infoLineValues(current_unit%, i), IFile$
    Next i
    
    
End Sub

Sub update_linear_unit(Index As Integer)

Select Case Index
    Case 1 ' mm
        linear_unit_name$ = "mm"
        linear_unit_conversion# = 0.1
    Case 3 ' in
        linear_unit_name$ = "in"
        linear_unit_conversion# = 2.54
    Case Else ' cm
        linear_unit_name$ = "cm"
        linear_unit_conversion# = 1
        Index = 2
End Select

linear_unit_index% = Index

WPPS Curr_U$, "linear_unit", str$(Index), IFile$

End Sub

Sub update_thick_unit(Index As Integer)

Select Case Index
    Case 1 ' mm
        thick_unit_name$ = "mm"
        thick_unit_conversion# = 0.1
    Case 3 ' in
        thick_unit_name$ = "mil"
        thick_unit_conversion# = 0.00254
    Case Else ' cm
        thick_unit_name$ = "cm"
        thick_unit_conversion# = 1
        Index = 2
End Select

thick_unit_index% = Index

WPPS Curr_U$, "thick_unit", str$(Index), IFile$

End Sub

Sub update_mass_unit(Index As Integer)

    Select Case Index
        Case 1
            mass_unit = " g"
            mass_unit_c = 1
        Case 2
            mass_unit = " lb"
            mass_unit_c = 1000# / 2.205
    End Select
    
    mass_unit_index% = Index
    WPPS Curr_U$, "mass_unit", str$(Index), IFile$
    
End Sub

Sub update_dens_unit(Index As Integer)
    
    Select Case Index
        Case 1
            dens_unit = " g/cm^3" ' "g/cm^3"
            dens_unit_c = 1
        Case 2
            dens_unit = " lb/in^3"
            dens_unit_c = 1000# / (2.205 * 2.54 * 2.54 * 2.54)
    End Select
    
    dens_unit_index = Index
    WPPS Curr_U$, "dens_unit", str$(Index), IFile$
    
End Sub

Sub load_user_global_stuff()

    Dim Ret$, r As Long
    Dim i As Integer
    Dim j As Integer
    Dim main_lohm_path$
    Dim errNum As Integer
    
    On Error GoTo UnknownErrorHandler
    errNum = 1
    
    Ret$ = String$(255, " ")
    r = GPPS(Curr_U$, "unit", "PSI", Ret$, 255, IFile$)
    PU$ = LTrim$(RTrim$(Ret$))
    While Right$(PU$, 1) = vbNullChar
        PU$ = Left$(PU$, Len(PU$) - 1)
    Wend
    errNum = 2
    TitleScrn.Label3.Caption = Curr_U$
    TitleScrn.Label6.Caption = PU$
    PCNV = val(gpps2(Curr_U$, "unitval", IFile$, "1"))
    linear_unit_index% = val(gpps2(Curr_U$, "linear_unit", IFile$, "2"))
    update_linear_unit linear_unit_index%
    i = GPPS(Curr_U$, "BPPostPurgeCounts", "400", Ret$, 255, IFile$)
    BPPostPurgeCounts = CInt(nulltrim(Ret$))
    thick_unit_index% = val(gpps2(Curr_U$, "thick_unit", IFile$, "2"))
    update_thick_unit thick_unit_index%
    mass_unit_index% = val(gpps2(Curr_U$, "mass_unit", IFile$, "1"))
    update_mass_unit mass_unit_index%
    dens_unit_index% = val(gpps2(Curr_U$, "dens_unit", IFile$, "1"))
    update_dens_unit dens_unit_index%
    advanced_settings = (val(gpps2(Curr_U$, "auto_advanced", IFile$, "0")) = 1)
    use_second_regulator_only = val(gpps2("Capstuff", "use_second_regulator_only", CSFile$, "0"))
    'advanced_low_flow = False
    auto_advanced = advanced_settings
    preloaded_sample = (val(gpps2(Curr_U$, "preloaded_sample", IFile$, "0")) = 1)
    use_min_pressure_in_dry = (val(gpps2(Curr_U$, "use_min_pressure_in_dry", IFile$, "0")) = 1)
    use_min_flow_in_dry = (val(gpps2(Curr_U$, "use_min_flow_in_dry", IFile$, "0")) = 1)
    min_flow_in_dry = val(gpps2(Curr_U$, "min_flow_in_dry", IFile$, "0"))
    auto_increment = (val(gpps2(Curr_U$, "auto_increment", IFile$, "0")) = 1)
   ' AutoSamplID = (Val(gpps2(Curr_U$, "auto_sampl_id", IFile$, "0")) = 1)
    autoCurveFit = (gpps2(Curr_U$, "auto_curve_fit", IFile$, "Y") = "Y")
    path(0) = gpps2(Curr_U$, "path0", IFile$, EXE_Path$ + "data\*.cft")
    path(1) = gpps2(Curr_U$, "path1", IFile$, EXE_Path$ + "parms\*.tpf")
    manual_data_path$ = gpps2(Curr_U$, "manual_data_path", IFile$, EXE_Path$ + "data\*.txt")
    tfactor = val(gpps2(Curr_U$, "TFactor", IFile$, ".715"))
    SCDiam = val(gpps2(Curr_U$, "SCDiam", IFile$, "0"))
    Gas$ = gpps2(Curr_U$, "Gas", IFile$, "Air")
    errNum = 3
        ' Get the reduce flow rate option
    GPPS Curr_U$, "ReduceFlowAtTarget", "N", Ret$, 2, IFile$
    ReduceFlowAtTarget = IIf(Left(Ret$, 1) = "Y", True, False)
    ReduceFlowPressureTarget = val(gpps2(Curr_U$, "ReduceFlowPressureTarget", IFile$, "0"))
    qcshow(0) = val(gpps2(Curr_U$, "qcshow0", IFile$, "1"))
    For i = 1 To 15
        qcshow(i) = val(gpps2(Curr_U$, "qcshow" + Format$(i), IFile$, "0"))
    Next i
    For i = 16 To 20
        qcshow(i) = val(gpps2(Curr_U$, "qcshow" + Format$(i), IFile$, "1"))
    Next i
    For i = 21 To 26 '6.71.123.15
        qcshow(i) = val(gpps2(Curr_U$, "qcshow" + Format$(i), IFile$, "0"))
    Next i
    
    errNum = 4
    i = GPPS(Curr_U$, "PneumaticMotor", "N", Ret$, 255, IFile$)
    If (Left$(UCase$(LTrim$(Ret$)), 1) = "Y") Then
        PneumaticMotor = True
        i = GPPS(Curr_U$, "PneumaticMotorVNum", "1", Ret$, 255, IFile$)
        pnumValve% = CInt(nulltrim(Ret$))
    End If
    leak_max_p = val(gpps2(Curr_U$, "leak_max_p", IFile$, "0"))
    leak_step_p = val(gpps2(Curr_U$, "leak_step_p", IFile$, "0"))
    leak_wait = val(gpps2(Curr_U$, "leak_wait", IFile$, "0"))
    curve_perc = val(gpps2(Curr_U$, "curve_perc", IFile$, "0.01"))
    curve_nump = val(gpps2(Curr_U$, "curve_nump", IFile$, "5"))
    curve_maxd = val(gpps2(Curr_U$, "curve_maxd", IFile$, "10"))
    lperm_startp = val(gpps2(Curr_U$, "lperm_startp", IFile$, "0"))
    lperm_maxp = val(gpps2(Curr_U$, "lperm_maxp", IFile$, "50"))
    lperm_stepp = val(gpps2(Curr_U$, "lperm_stepp", IFile$, "2"))
    lperm_temperature = val(gpps2(Curr_U$, "lperm_temperature", IFile$, "75"))
    lperm_maxwait = val(gpps2(Curr_U$, "lperm_maxwait", IFile$, "30"))
    g_iBalanceNotPenet_SettlingTime = val(gpps2(Curr_U$, "g_iBalanceNotPenet_SettlingTime", IFile$, "0"))  'TAR 040804
    lperm_maxpoints = val(gpps2(Curr_U$, "lperm_maxpoints", IFile$, "100"))
    lperm_last_target_pressure = val(gpps2(Curr_U$, "lperm_last_target_pressure", IFile$, "0"))
    lperm_last_pressure_overshoot = val(gpps2(Curr_U$, "lperm_last_pressure_overshoot", IFile$, "0"))
    lperm_init_wait = val(gpps2(Curr_U$, "lperm_init_wait", IFile$, "5"))
    Show_Result = (val(gpps2(Curr_U$, "show_result", IFile$, "0")) <> 0)
    cyclic_compression_pressure = val(gpps2(Curr_U$, "cyclic_compression_pressure", IFile$, "1"))
    cyclic_compression_timedown = val(gpps2(Curr_U$, "cyclic_compression_timedown", IFile$, "5"))
    cyclic_compression_timeup = val(gpps2(Curr_U$, "cyclic_compression_timeup", IFile$, "5"))
    cyclic_compression_numcycles = val(gpps2(Curr_U$, "cyclic_compression_numcycles", IFile$, "10"))
    uselog = (val(gpps2(Curr_U$, "uselog", IFile$, "0")) = 1)
    permeabilityLogging = (val(gpps2(Curr_U$, "permeabilityLogging", IFile$, "0")) = 1)
    minmaxunits = gpps2(Curr_U$, "minmaxunits", IFile$, "p")
    logpath = gpps2(Curr_U$, "logpath", IFile$, EXE_Path$ + "log.txt")
    permeabilityLoggingFile = gpps2(Curr_U$, "permeabilityLoggingFile", IFile$, EXE_Path$ + "permlog.txt")
    start_caprep = val(gpps2(Curr_U$, "start_caprep", IFile$, "0"))
    lohmStartMultiplier = val(gpps2(Curr_U$, "lohm_start_multiplier", IFile$, "0"))
    pressHoldUnit = gpps2(Curr_U$, "pressHoldUnit", IFile$, "S")
    num_PH_AvePoints = val(gpps2(Curr_U$, "num_PH_AvePoints", IFile$, "0"))
    PH_reading_freq = val(gpps2(Curr_U$, "PH_reading_freq", IFile$, "5"))
    PH_fail_method$ = gpps2(Curr_U$, "PH_fail_method", IFile$, "dpdt")
    PH_stopOnFail = (val(gpps2(Curr_U$, "PH_stoponfail", IFile$, "0")) = 1)
    PH_autoscale = (gpps2(Curr_U$, "PH_autoscale", IFile$, "N") = "Y")
    PH_minY = val(gpps2(Curr_U$, "PH_minY", IFile$, "0"))
    PH_maxY = val(gpps2(Curr_U$, "PH_maxY", IFile$, "20"))
    LP_mintime = val(gpps2(Curr_U$, "LP_mintime", IFile$, "1"))
    auto_report_type = val(gpps2(Curr_U$, "auto_report_type", IFile$, "1"))
    PH_regression = (gpps2(Curr_U$, "PH_regression", IFile$, "1") = "1")
    microflowregulator = (gpps2(Curr_U$, "microflowregulator", IFile$, "Y") = "Y")
    norefill = (gpps2(Curr_U$, "norefill", IFile$, "N") = "Y")
    
    lperm_v6_reginccount = val(gpps2(Curr_U$, "LP_V6_RegIncCount", IFile$, "1"))
    lperm_v6_regincwait = val(gpps2(Curr_U$, "LP_V6_RegIncWait", IFile$, "1000"))
    
    errNum = 5
    
    LP_CCsToFlush = val(gpps2(Curr_U$, "LP_CCsToFlush", IFile$, "20"))
    LP_FlushPressure = val(gpps2(Curr_U$, "LP_FlushPressure", IFile$, "4"))
    LP_FlushBeforeTest = (gpps2(Curr_U$, "LP_FlushBeforeTest", IFile$, "N") = "Y")
    
    LP_DrainAfterTest = (gpps2(Curr_U$, "LP_DrainAfterTest", IFile$, "N") = "Y")
    LP_DrainTime = val(gpps2(Curr_U$, "LP_DrainTime", IFile$, "15"))
    
    If (autocompress Or autopiston) And H2OPERM And (PEN20500 < 0) Then
        delaycompressionliquid = (gpps2(Curr_U$, "delaycompressionliquid", IFile$, "Y") = "Y")
    Else
        delaycompressionliquid = False ' just in case
    End If
    If autocompress Then
        compression_pressure = val(gpps2(Curr_U$, "compression_pressure", IFile$, "20"))
        sample_compression_pressure = val(gpps2(Curr_U$, "sample_compression_pressure", IFile$, "0"))
        sample_compression_diameter = val(gpps2(Curr_U$, "sample_compression_diameter", IFile$, "1"))
        use_sample_compression = (gpps2(Curr_U$, "use_sample_compression", IFile$, "N") = "Y")
        
    Else
        use_sample_compression = False
        sample_compression_pressure = 0
        sample_compression_diameter = 1
    End If
    errNum = 6
    
    If piston_position_transducer_exists Then '6.71.123.01
        TargetPercPorosity = val(gpps2(Curr_U$, "TargetPercPorosity", IFile$, "0"))
    End If
    If slurry_tube_exists Then '6.71.123.01
        BuildCakeByPressureTargetPressure = val(gpps2(Curr_U$, "BuildCakeByPressureTargetPressure", IFile$, "0"))
        BuildCakeByFlowTargetFlow = val(gpps2(Curr_U$, "BuildCakeByFlowTargetFlow", IFile$, "0"))
        BuildCakeByFlowEndPressure = val(gpps2(Curr_U$, "BuildCakeByFlowEndPressure", IFile$, "0"))
        BuildCakeByPressureEndFlow = val(gpps2(Curr_U$, "BuildCakeByPressureEndFlow", IFile$, "0"))
        SlurryTubeWashCycleTargetFlow = val(gpps2(Curr_U$, "SlurryTubeWashCycleTargetFlow", IFile$, "0"))
    End If
    MF_linearSeal = (gpps2(Curr_U$, "mf_linear_seal", IFile$, "N") = "Y")
    MF_sealDiam = val(gpps2(Curr_U$, "mf_seal_diam", IFile$, "0"))
    MF_Settle = (gpps2(Curr_U$, "mf_settle", IFile$, "N") = "Y")
    MF_Settle_pressure = val(gpps2(Curr_U$, "mf_settle_pressure", IFile$, "1"))
    MF_Settle_time = val(gpps2(Curr_U$, "mf_settle_time", IFile$, "0"))
    MF_recordTemperature = (gpps2(Curr_U$, "mf_record_temperature", IFile$, "N") = "Y")
    PS_usingList = (gpps2(Curr_U$, "ps_usinglist", IFile$, "N") = "Y")
    PS_path$ = gpps2(Curr_U$, "ps_path", IFile$, "")
    GP_singlePointTest = (gpps2(Curr_U$, "gp_singlepoint", IFile$, "N") = "Y")
    GP_target = val(gpps2(Curr_U$, "gp_target", IFile$, "5"))
    GP_delay = val(gpps2(Curr_U$, "gp_delay", IFile$, "0"))
    GP_duration = val(gpps2(Curr_U$, "gp_duration", IFile$, "10"))
    GP_interval = val(gpps2(Curr_U$, "gp_interval", IFile$, "1"))
    GP_numavg = val(gpps2(Curr_U$, "gp_numavg", IFile$, "1"))
    GP_multiAverageTest = (gpps2(Curr_U$, "gp_multiavgtest", IFile$, "N") = "Y")
    gP_numAvgTests = myVal(gpps2(Curr_U$, "gp_numavgtests", IFile$, "1"))
    errNum = 7
    
    BP_AutoDetectMethod = val(gpps2(Curr_U$, "BP_AutoDetectMethod", IFile$, "0"))
    
    CF_SampleType = val(gpps2(Curr_U$, "CF_SampleType", IFile$, "0"))

    '=== edc 09-19-07 added GP_multitest,GPM_targetVol,GPM_numberSet,GPM_setDuration
    'GP_multisetTest = (gpps2(Curr_U$, "gp_multitest", IFile$, "N") = "Y")
    'GPM_targetVol = Val(gpps2(Curr_U$, "gpm_targetVol", IFile$, "0.5"))
    'GPM_numberSets = Val(gpps2(Curr_U$, "gpm_numberSets", IFile$, "3"))
    'GPM_setDuration = Val(gpps2(Curr_U$, "gpm_setDuration", IFile$, "60"))
    'GPM_numberDataPts = CInt(Val(gpps2(Curr_U$, "gpm_numberDataPts", IFile$, "10")))
    zeroTempAtEndOfTest = (gpps2(Curr_U$, "zerotemp", IFile$, "Y") = "Y")
    BPTLEnable = (gpps2(Curr_U$, "BPTLEnable", IFile$, "N") = "Y")
    BPTLInterval = val(gpps2(Curr_U$, "BPTLInterval", IFile$, "10")) * 10
    BPTLMaxPoints = val(gpps2(Curr_U$, "BPTLMaxPoints", IFile$, "1000"))
    bubbler_selected = (gpps2(Curr_U$, "bubbler_selected", IFile$, "N") = "Y")
    If BPTLMaxPoints < 1 Then BPTLMaxPoints = 1
    If BPTLInterval < 1 Then BPTLInterval = 1
    
    errNum = 8
    
    'JF 9-30-2010 Adding for bubble point detection count
    BP_PointDetectionCount = val(gpps2(Curr_U$, "BP_PointDetectionCount", IFile$, "32767"))
    
    
    ' new things for auto_wet
    'If auto_wet_enable Then
        auto_wet_used = (gpps2(Curr_U$, "auto_wet_used", IFile$, "N") = "Y")
        auto_wet_wet_time = val(gpps2(Curr_U$, "wet_time", IFile$, 10))
        auto_wet_volume = val(gpps2(Curr_U$, "wet_volume", IFile$, 2)) 'auto-wetting volume in cc's
        auto_wet_soak_time = val(gpps2(Curr_U$, "soak_time", IFile$, 5))
        auto_wet_drain_time = val(gpps2(Curr_U$, "drain_time", IFile$, 15))
        chamber_selected1 = val(gpps2(Curr_U$, "chamber select 1", IFile$, "1"))
        chamber_selected2 = val(gpps2(Curr_U$, "chamber select 2", IFile$, "0"))
        use_auto_wet_volume = (gpps2(Curr_U$, "use_auto_wet_volume", IFile$, "N") = "Y")
        auto_wet_reverse_time = val(gpps2(Curr_U$, "wet_reverse_time", IFile$, 5))
        auto_wet_pump_speed = val(gpps2(Curr_U$, "wet_pump_speed", IFile$, 70))
        auto_wet_fill_height = val(gpps2(Curr_U$, "AutoFillHeight", IFile$, 90))
        bubWaitTime = val(gpps2(Curr_U$, "MinBPTime", IFile$, 1))
        bubPressOnWait = IIf(gpps2(Curr_U$, "BPPressOnWait", IFile$, "N") = "Y", True, False)

        'andy is here
'        If rotating_chamber_enable Then
'            auto_wet_pump_speed = val(gpps2(Curr_U$, "rotating_pump_speed", IFile$, 255))
'        End If
    'ElseIf rotating_chamber_enable Then
            
    'End If
    
    errNum = 9
    
    bpRunMultipleTests = (gpps2(Curr_U$, "BP_RunMultipleTests", IFile$, "N") = "Y")
    bpTestCount = gpps2(Curr_U$, "BP_TestCount", IFile$, "1")
    
    lpRunMultipleTests = (gpps2(Curr_U$, "LP_RunMultipleTests", IFile$, "N") = "Y")
    lpTestCount = gpps2(Curr_U$, "LP_TestCount", IFile$, "1")
    
    'New Items for Additional Information
    'JF 2-9-2010
    errNum = 10
    
    useAdditionalInfo = (gpps2(Curr_U$, "UseAdditionalInfo", IFile$, "N") = "Y")
    numberOfAdditionalInfoLines = gpps2(Curr_U$, "NumberOfAdditionalInfoLines", IFile$, "0")
    ReDim infoLineHeaders(numberOfAdditionalInfoLines)
'    ReDim infoLineValues(numberOfAdditionalInfoLines)
    For j = 0 To numberOfAdditionalInfoLines - 1
        infoLineHeaders(j) = gpps2(Curr_U$, "InfoLineHeader" & j, IFile$, "")
    Next j
    
    'New items for automatic temperature contorl
    'JF 2-10-2010
    minimumPossibleTemperature = gpps2(Curr_U$, "MinimumPossibleTemperature", IFile$, "0")
    maximumPossibleTemperature = gpps2(Curr_U$, "MaximumPossibleTemperature", IFile$, "100")
    errNum = 11
    
    'JF 02-16-2010
    'New stuff for humidity control
    recordHumidityForAutoTests = (gpps2(Curr_U$, "RecordHumidityForAutoTests", IFile$, "0") = "1")
    enableHumidityControlForAutoTests = (gpps2(Curr_U$, "EnableHumidityControlForAutoTests", IFile$, "0") = "1")
    targetHumidity = val(gpps2(Curr_U$, "TargetHumidity", IFile$, "0"))
    goToHumidityMaxWaitTime = val(gpps2(Curr_U$, "GoToHumidityMaxWaitTime", IFile$, "60"))
    goToHumidityMinWaitTime = val(gpps2(Curr_U$, "GoToHumidityMinWaitTime", IFile$, "5"))
    goToHumidityTolerance = val(gpps2(Curr_U$, "GoToHumidityTolerance", IFile$, "10"))
    stableHumidityMaxWaitTime = val(gpps2(Curr_U$, "StableHumidityMaxWaitTime", IFile$, "5"))
    stableHumidityMinWaitTime = val(gpps2(Curr_U$, "StableHumidityMinWaitTime", IFile$, "1"))
    stableHumidityTolerance = val(gpps2(Curr_U$, "StableHumidityTolerance", IFile$, "10"))
    stableHumiditySleepTime = val(gpps2(Curr_U$, "StableHumiditySleepTime", IFile$, "500"))
    initialHumidityWaitTime = val(gpps2(Curr_U$, "InitialHumidityWaitTime", IFile$, "300"))
    minHumidityAdjustmentFlow = val(gpps2(Curr_U$, "MinHumidityAdjustmentFlow", IFile$, "3000"))
    
    errNum = 12
    
    'JF 3-11-2010
    'New for ignoring MV errors
    ignoreMVErrors = (gpps2(Curr_U$, "IgnoreMVErrors", IFile$, "N") = "Y")
    
    ' new things for gurley test
'    UsingNonStandardOrificeSize = (gpps2(Curr_U$, "UsingNonStandardOrificeSize", IFile$, False))
'    CircularOrificeDiameter = Val(gpps2(Curr_U$, "CircularOrificeDiameter", IFile$, "0"))
    
    ' Show_Result and start_caprep are superseded by auto_report_type
    Show_Result = False
    If start_caprep Then
        auto_report_type = 2
        start_caprep = False
    End If
    
    errNum = 13
    
    ' Load in the user's current lohm table, overwrite the default, and update the main window
    main_lohm_path$ = EXE_Path$ + "lohmtable.cal"
    current_lohm_path$ = gpps2(Curr_U$, "lohmpath", IFile$, main_lohm_path$)
    If File_Exists(current_lohm_path$) Then
        If LCase$(current_lohm_path$) <> LCase$(main_lohm_path$) Then FileCopy (current_lohm_path$), (EXE_Path$ + "lohmtable.cal")
    ElseIf Not File_Exists(main_lohm_path$) Then
        MsgBox ("CapWin cannot locate a lohm table.")
        current_lohm_path$ = ""
    Else
        MsgBox ("The previous lohm table, """ + current_lohm_path$ + """ was not found. Switching to last lohm used for the machine.")
        current_lohm_path$ = main_lohm_path$
        WPPS Curr_U$, "lohmpath", main_lohm_path$, IFile$
    End If
    TitleScrn.Label1.Caption = get_filename_from_path(current_lohm_path$)
    TitleScrn.Label1.ToolTipText = current_lohm_path$

    runningLohmCalibration = False

    testGasStatus = (gpps2(Curr_U$, "testGasStatus", IFile$, "N") = "Y")
    depressurizeBeforeTest = (gpps2(Curr_U$, "DepressurizeBeforeTest", IFile$, "N") = "Y")
    savePreBPdata = (gpps2(Curr_U$, "SavePreBPdata", IFile$, "N") = "Y")
    ' also load in their default parameters
    errNum = 14
    
    load_default_parameters
    Exit Sub
UnknownErrorHandler:
    MsgBox "Unknown Error " + str$(errNum) + vbCrLf + str$(Err.Number) + " " + Err.Description
End Sub

Sub check_group_change(old_group$, new_group$, thing$)

    Dim a$

    a$ = UCase$(EXE_Path$ + "USERS\" + old_group$)
    If Len(a$) >= Len(thing$) Then Exit Sub
    If a$ = UCase$(Left$(thing$, Len(a$))) Then
        thing$ = UCase$(EXE_Path$ + "USERS\" + new_group$) + Mid$(thing$, Len(a$) + 1)
    End If
    
End Sub

Sub save_user_global_stuff()

    Dim i As Integer
    Dim j As Integer
    
    TitleScrn.Label3.Caption = Curr_U$
    TitleScrn.Label6.Caption = PU$
   ' update_units_check PU$
    WPPS Curr_U$, "unit", PU$, IFile$
    WPPS Curr_U$, "unitval", str$(PCNV), IFile$
    WPPS Curr_U$, "linear_unit", str$(linear_unit_index%), IFile$
    WPPS Curr_U$, "thick_unit", str$(thick_unit_index%), IFile$
    WPPS Curr_U$, "mass_unit", str$(mass_unit_index%), IFile$
    WPPS Curr_U$, "dens_unit", str$(dens_unit_index%), IFile$
        ' save the reduce flow rate option
    
    If auto_advanced Then
        WPPS Curr_U$, "auto_advanced", "1", IFile$
    Else
        WPPS Curr_U$, "auto_advanced", "0", IFile$
    End If
    If auto_increment Then
        WPPS Curr_U$, "auto_increment", "1", IFile$
    Else
        WPPS Curr_U$, "auto_increment", "0", IFile$
    End If
    '============ new Code edc 05-04-07 =====================================
    'If AutoSamplID Then
    '    WPPS Curr_U$, "auto_sampl_id", "1", IFile$
    'Else
    '    WPPS Curr_U$, "auto_sampl_id", "0", IFile$
    'End If
    '============ End New Code ==============================================
    If preloaded_sample Then
        WPPS Curr_U$, "preloaded_sample", "1", IFile$
    Else
        WPPS Curr_U$, "preloaded_sample", "0", IFile$
    End If
    WPPS Curr_U$, "use_min_pressure_in_dry", Format$(IIf(use_min_pressure_in_dry, 1, 0)), IFile$
    WPPS Curr_U$, "use_min_flow_in_dry", Format$(IIf(use_min_flow_in_dry, 1, 0)), IFile$
    WPPS Curr_U$, "min_flow_in_dry", str$(min_flow_in_dry), IFile$
    WPPS Curr_U$, "auto_curve_fit", IIf(autoCurveFit, "Y", "N"), IFile$
    WPPS Curr_U$, "path0", path(0), IFile$
    WPPS Curr_U$, "path1", path(1), IFile$
    WPPS Curr_U$, "manual_data_path", manual_data_path$, IFile$
    WPPS Curr_U$, "TFactor", str$(tfactor), IFile$
    WPPS Curr_U$, "SCDiam", str$(SCDiam), IFile$
    WPPS Curr_U$, "Gas", Gas$, IFile$
    
    For i = 0 To 20
        WPPS Curr_U$, "qcshow" + Format$(i), str$(qcshow(i)), IFile$
    Next i
    WPPS Curr_U$, "leak_max_p", str$(leak_max_p), IFile$
    WPPS Curr_U$, "leak_step_p", str$(leak_step_p), IFile$
    WPPS Curr_U$, "leak_wait", str$(leak_wait), IFile$
    WPPS Curr_U$, "curve_perc", str$(curve_perc), IFile$
    WPPS Curr_U$, "curve_nump", str$(curve_nump), IFile$
    WPPS Curr_U$, "curve_maxd", str$(curve_maxd), IFile$
    WPPS Curr_U$, "lperm_startp", str$(lperm_startp), IFile$
    WPPS Curr_U$, "lperm_maxp", str$(lperm_maxp), IFile$
    WPPS Curr_U$, "lperm_stepp", str$(lperm_stepp), IFile$
    WPPS Curr_U$, "lperm_temperature", str$(lperm_temperature), IFile$
    WPPS Curr_U$, "lperm_maxwait", str$(lperm_maxwait), IFile$
    WPPS Curr_U$, "g_iBalanceNotPenet_SettlingTime", str$(g_iBalanceNotPenet_SettlingTime), IFile$ 'TAR 040804
    WPPS Curr_U$, "lperm_maxpoints", str$(lperm_maxpoints), IFile$
    WPPS Curr_U$, "lperm_init_wait", str$(lperm_init_wait), IFile$
    WPPS Curr_U$, "show_result", str$(CInt(Show_Result)), IFile$
    WPPS Curr_U$, "cyclic_compression_pressure", str$(cyclic_compression_pressure), IFile$
    WPPS Curr_U$, "cyclic_compression_timedown", str$(cyclic_compression_timedown), IFile$
    WPPS Curr_U$, "cyclic_compression_timeup", str$(cyclic_compression_timeup), IFile$
    WPPS Curr_U$, "cyclic_compression_numcycles", str$(cyclic_compression_numcycles), IFile$
    WPPS Curr_U$, "start_caprep", IIf(start_caprep, "1", "0"), IFile$
    WPPS Curr_U$, "lohm_start_multiplier", str$(lohmStartMultiplier), IFile$
    WPPS Curr_U$, "pressHoldUnit", pressHoldUnit, IFile$
    WPPS Curr_U$, "num_PH_AvePoints", str$(num_PH_AvePoints), IFile$
    WPPS Curr_U$, "PH_reading_freq", str$(PH_reading_freq), IFile$
    WPPS Curr_U$, "PH_fail_method", PH_fail_method$, IFile$
    WPPS Curr_U$, "PH_autoscale", IIf(PH_autoscale, "Y", "N"), IFile$
    WPPS Curr_U$, "PH_minY", str$(PH_minY), IFile$
    WPPS Curr_U$, "PH_maxY", str$(PH_maxY), IFile$
    WPPS Curr_U$, "LP_mintime", str$(LP_mintime), IFile$
    WPPS Curr_U$, "PH_regression", IIf(PH_regression, "1", "0"), IFile$
    WPPS Curr_U$, "microflowregulator", IIf(microflowregulator, "Y", "N"), IFile$
    WPPS Curr_U$, "norefill", IIf(norefill, "Y", "N"), IFile$
    
    WPPS Curr_U$, "LP_V6_RegIncCount", str$(lperm_v6_reginccount), IFile$
    WPPS Curr_U$, "LP_V6_RegIncWait", str$(lperm_v6_regincwait), IFile$
    
    If autocompress Then
        WPPS Curr_U$, "compression_pressure", str$(compression_pressure), IFile$
        WPPS Curr_U$, "sample_compression_pressure", str$(sample_compression_pressure), IFile$
        WPPS Curr_U$, "sample_compression_diameter", str$(sample_compression_diameter), IFile$
        WPPS Curr_U$, "use_sample_compression", IIf(use_sample_compression, "Y", "N"), IFile$
    End If
    If (autocompress Or autopiston) And H2OPERM And (PEN20500 < 0) Then
        WPPS Curr_U$, "delaycompressionliquid", IIf(delaycompressionliquid, "Y", "N"), IFile$
    End If
    WPPS Curr_U$, "mf_linear_seal", IIf(MF_linearSeal, "Y", "N"), IFile$
    WPPS Curr_U$, "mf_seal_diam", str$(MF_sealDiam), IFile$
    WPPS Curr_U$, "mf_settle", IIf(MF_Settle, "Y", "N"), IFile$
    WPPS Curr_U$, "mf_settle_pressure", str$(MF_Settle_pressure), IFile$
    WPPS Curr_U$, "mf_settle_time", str$(MF_Settle_time), IFile$
    WPPS Curr_U$, "mf_record_temperature", IIf(MF_recordTemperature, "Y", "N"), IFile$
    WPPS Curr_U$, "ps_usinglist", IIf(PS_usingList, "Y", "N"), IFile$
    WPPS Curr_U$, "ps_path", PS_path$, IFile$
    WPPS Curr_U$, "gp_singlepoint", IIf(GP_singlePointTest, "Y", "N"), IFile$
    WPPS Curr_U$, "gp_target", str$(GP_target), IFile$
    WPPS Curr_U$, "gp_delay", str$(GP_delay), IFile$
    WPPS Curr_U$, "gp_duration", str$(GP_duration), IFile$
    WPPS Curr_U$, "gp_interval", str$(GP_interval), IFile$
    WPPS Curr_U$, "gp_numavg", str$(GP_numavg), IFile$
    WPPS Curr_U$, "gp_multiavgtest", IIf(GP_multiAverageTest, "Y", "N"), IFile$
    WPPS Curr_U$, "gp_numavgtests", str$(gP_numAvgTests), IFile$
    '=============== edc 09-19-07 gas perm multi-set test
   ' WPPS Curr_U$, "gp_multisetTest", IIf(GP_multisetTest, "Y", "N"), IFile$
   ' WPPS Curr_U$, "gpm_targetVol", Str$(GPM_targetVol), IFile$
   ' WPPS Curr_U$, "gpm_numberSets", Str$(GPM_numberSets), IFile$
   ' WPPS Curr_U$, "gpm_setDuration", Str$(GPM_setDuration), IFile$
   ' WPPS Curr_U$, "gpm_numberDataPts", Str$(GPM_numberDataPts), IFile$
    WPPS Curr_U$, "zerotemp", IIf(zeroTempAtEndOfTest, "Y", "N"), IFile$
    WPPS Curr_U$, "BP_PointDetectionCount", str$(BP_PointDetectionCount), IFile$
    WPPS Curr_U$, "BPTLEnable", IIf(BPTLEnable, "Y", "N"), IFile$
    WPPS Curr_U$, "BPTLInterval", str$(BPTLInterval / 10#), IFile$
    WPPS Curr_U$, "BPTLMaxPoints", str$(BPTLMaxPoints), IFile$
    WPPS Curr_U$, "bubbler_selected", IIf(bubbler_selected, "Y", "N"), IFile$
    If auto_wet_enable Then
        WPPS Curr_U$, "auto_wet_used", IIf(auto_wet_used, "Y", "N"), IFile$
        WPPS Curr_U$, "wet_time", str$(auto_wet_wet_time), IFile$
        WPPS Curr_U$, "wet_volume", str$(auto_wet_volume), IFile$
        WPPS Curr_U$, "soak_time", str$(auto_wet_soak_time), IFile$
        WPPS Curr_U$, "drain_time", str$(auto_wet_drain_time), IFile$
        WPPS Curr_U$, "use_auto_wet_volume", IIf(use_auto_wet_volume, "Y", "N"), IFile$
        WPPS Curr_U$, "wet_reverse_time", str$(auto_wet_reverse_time), IFile$
        'WPPS Curr_U$, "wet_pump_speed", str$(auto_wet_pump_speed), IFile$
    End If
    
    WPPS Curr_U$, "BP_AutoDetectMethod", str$(BP_AutoDetectMethod), IFile$
    
    WPPS Curr_U$, "CF_SampleType", str$(CF_SampleType), IFile$
    
    WPPS Curr_U$, "BP_RunMultipleTests", IIf(bpRunMultipleTests, "Y", "N"), IFile$
    WPPS Curr_U$, "BP_TestCount", str$(bpTestCount), IFile$
    
    WPPS Curr_U$, "LP_RunMultipleTests", IIf(lpRunMultipleTests, "Y", "N"), IFile$
    WPPS Curr_U$, "LP_TestCount", str$(lpTestCount), IFile$
    
    'New Items for Additional Information
    'JF 2-9-2010
    WPPS Curr_U$, "UseAdditionalInfo", IIf(useAdditionalInfo, "Y", "N"), IFile$
    WPPS Curr_U$, "NumberOfAdditionalInfoLines", str$(numberOfAdditionalInfoLines), IFile$
    For j = 0 To numberOfAdditionalInfoLines - 1
        WPPS Curr_U$, "InfoLineHeader" & j, infoLineHeaders(j), IFile$
    Next
    
    'New Items for automatic temperature contorl
    'JF 2-10-2010
    WPPS Curr_U$, "MinimumPossibleTemperature", str$(minimumPossibleTemperature), IFile$
    WPPS Curr_U$, "MaximumPossibleTemperature", str$(maximumPossibleTemperature), IFile$
    
    'JF 02-16-2010
    'New stuff for humidity
    WPPS Curr_U$, "RecordHumidityForAutoTests", IIf(recordHumidityForAutoTests, "1", "0"), IFile$
    WPPS Curr_U$, "EnableHumidityControlForAutoTests", IIf(enableHumidityControlForAutoTests, "1", "0"), IFile$
    WPPS Curr_U$, "TargetHumidity", str$(targetHumidity), IFile$
    WPPS Curr_U$, "GoToHumidityMaxWaitTime", str$(goToHumidityMaxWaitTime), IFile$
    WPPS Curr_U$, "GoToHumidityMinWaitTime", str$(goToHumidityMinWaitTime), IFile$
    WPPS Curr_U$, "GoToHumidityTolerance", str$(goToHumidityTolerance), IFile$
    WPPS Curr_U$, "StableHumidityMaxWaitTime", str$(stableHumidityMaxWaitTime), IFile$
    WPPS Curr_U$, "StableHumidityMinWaitTime", str$(stableHumidityMinWaitTime), IFile$
    WPPS Curr_U$, "StableHumidityTolerance", str$(stableHumidityTolerance), IFile$
    WPPS Curr_U$, "StableHumiditySleepTime", str$(stableHumiditySleepTime), IFile$
    WPPS Curr_U$, "InitialHumidityWaitTime", str$(initialHumidityWaitTime), IFile$
    WPPS Curr_U$, "MinHumidityAdjustmentFlow", str$(minHumidityAdjustmentFlow), IFile$
    
    If hhRunAsMullen(current_unit%) Then
        WPPS Curr_U$, "hhRunAsMullen", "1", IFile$
    Else
        WPPS Curr_U$, "hhRunAsMullen", "0", IFile$
    End If
    
    If hhRunAsHydrohead(current_unit%) Then
        WPPS Curr_U$, "hhRunAsHydrohead", "1", IFile$
    Else
        WPPS Curr_U$, "hhRunAsHydrohead", "0", IFile$
    End If
    
    If hhRunAsBurst(current_unit%) Then
        WPPS Curr_U$, "hhRunAsBurst", "1", IFile$
    Else
        WPPS Curr_U$, "hhRunAsBurst", "0", IFile$
    End If
    
'    WPPS Curr_U$, "UsingNonStandardOrificeSize", UsingNonStandardOrificeSize, IFile$
'    WPPS Curr_U$, "CircularOrificeDiameter", CircularOrificeDiameter, IFile$
    
End Sub
Public Sub Zero_HFM2()
' zero high flow meter (2) or (1) depending upon whether machine is QC or not
 
    Dim T As Single
    Dim High_flow As Single
    Dim startcounts As Single
    Dim OldMaxAirFlow As Single
    Dim OldMinAirFlow As Single
    Dim New_Zero As Single
    Dim i As Single
    Dim curflowcount As Single
    Dim curFlow As Single
    Dim sum As Single
     
    If xhflow Then
        HFLOW% = 3  ' high fm 2 low range
        hfmin% = 2 ' rem set to high fm 1 low range
    Else
        HFLOW% = 1
        hfmin% = 0
    End If

    Rem add this to make sure versa is in proper position
    ReadXReturnX4 1
    'T = Timer
    'While (Timer - T < 0.3) And (Timer >= T)
    '    DoEvents
    'Wend
    waitseconds 0.3
    T = Timer
    i = 0
    curFlow = 0
    sum = 0
    curflowcount = 0
    ReadXReturnX4 1
    startcounts = x4
    OldMaxAirFlow = x5
    OldMinAirFlow = x5
    Rem zero LOW range of Highest Flow Meter (1 or 2)
    
    Do
          i = i + 1
          ReadXReturnX4 1
          Msgform.Label1.Caption = ts$(208) + ": " + ts$(30) + " =" + Format$(x4) ' "Waiting for stable values"/"flow"
          Msgform.Refresh
          'curflowcount = X4
          curFlow = x5
          
            If curFlow < OldMinAirFlow Then
                OldMinAirFlow = x5
                T = Timer
                i = 0
                sum = 0
                curflowcount = 0
            End If
            
            If curFlow > OldMaxAirFlow Then
                OldMaxAirFlow = x5
                T = Timer
                i = 0
                sum = 0
                curflowcount = 0
            End If
            curflowcount = curflowcount + x4
            DoEvents
    Loop While i < 50
        New_Zero = curflowcount / i
        
        If New_Zero < DAC_zero - DAC_span * 0.0225 Then
            MsgBox ts$(357) + " " + ts$(106) + " " + ts$(19) ' "Warning: The High Flow Meter is not calibrated correctly"
        End If
        
        Rem set low range of High flow 1 or 2
        If xhflow Then
            FX1(1, 3) = New_Zero
            FY1(1, 3) = 0
            FX2(1, 3) = New_Zero + DAC_span
        Else ' low range of single HFM
            FX1(1, 1) = New_Zero
            FY1(1, 1) = 0
            FX2(1, 1) = New_Zero + DAC_span
        End If
        Rem zero high range High Flow meter (either 1 or 2)
        curflowcount = 0
        sum = 0
        
        If xhflow Then
            HFLOW% = 2
        Else
            HFLOW% = 0
        End If
        i = 0
        'T = Timer
        Do
        ReadXReturnX4 1
        Msgform.Label1.Caption = ts$(208) + ": " + ts$(30) + " =" + Format$(x4)     ' "Waiting for stable: Flow ="
        Msgform.Refresh
        'curflowcount = X4
        curflowcount = curflowcount + x4
        i = i + 1
        Loop While i < 50
        New_Zero = curflowcount / i
        ' 3 counts is 2.485% of span below zero
        If New_Zero < DAC_zero - DAC_span * 0.02485 Then
            MsgBox ts$(357) + " " + ts$(106) + " " + ts$(19) ' "Warning: The High Flow Meter is not calibrated correctly"
        End If
            If xhflow Then
                FX1(1, 2) = New_Zero
                FY1(1, 2) = 0
                FX2(1, 2) = New_Zero + DAC_span
            Else
                FX1(1, 0) = New_Zero
                FY1(1, 0) = 0
                FX2(1, 0) = New_Zero + DAC_span
            End If
            
End Sub

Public Sub Move_v2_for_cvcal()

    Dim valve2_position As Single
    Dim tempval As Single
    Dim v2target As Single
    Dim CV_VALVE_INC As Single

    valve2_position = -9999

    Rem figure out where we are
    tempval = x4
    ReadXReturnX4 3

    Rem gives v2 pos as a percentage
    If Not hasMultipleMVs Then
        valve2_position = ((x4 - cLimit) / (oLimit - cLimit)) * 100
    Else
        If motorValveIndex = 0 Then
            valve2_position = ((x4 - cLimit) / (oLimit - cLimit)) * 100
        Else
            valve2_position = ((x4 - CLIMIT2) / (olimit2 - CLIMIT2)) * 100
        End If
        
    End If
        
    Rem increase v2 by 10 percent each time
    Rem make sure not below V2 starting point from capcal.d8a

    If x4 < SV2P Then
        MsgBox ("V2 Setting Lower than First V2 Flow Point")
        v2target = ((SV2P - cLimit) / (oLimit - cLimit)) * 100
    ElseIf valve2_position >= 99# Then
        v2now_open = True
        x4 = tempval
        Exit Sub
    ElseIf valve2_position < 50# Then
        CV_VALVE_INC = PULSEWIDTH * 100
        v2target = valve2_position + CV_VALVE_INC
    Else
        CV_VALVE_INC = (2# * PULSEWIDTH) * 100
        v2target = valve2_position + CV_VALVE_INC
    End If

    Rem jsd added entire proceedure Jan 4 2001
    Rem put in a loop for future flexibility (i.e. aborting) etc.

    Do
        V2POS = v2target * (oLimit - cLimit) / 100 + cLimit
        OpenV2Pos
    Loop While Not Done_with_v2

    cvpoints = 0
    x4 = tempval
    
End Sub

Sub do_average_test(p_atm As Single, diffp_atm As Single, X As dat_array)
    Dim i As Integer
    Dim j As Integer
    Dim p_avg As Single
    Dim f_avg As Single
    Dim temp1_avg As Single 'AJB 10-22-09
    Dim temp2_avg As Single 'AJB 10-22-09
    
    Dim p_points() As Single
    Dim f_points() As Single
    Dim t_points() As Single
    Dim temp1_points() As Single 'AJB 10-22-09
    Dim temp2_points() As Single 'AJB 10-22-09
    Dim T As Single
    Dim fna As Integer
    ' We have: delay time, duration, interval, average
    Dim startTime As Long
    Dim numPoints As Integer
    Dim count As Long
    Dim elapsedTime As Long
    
    'Microflow Variables
    Dim p1 As Single
    Dim p2 As Single
    Dim f0 As Single
    Dim f1 As Single
    Dim f2 As Single
    Dim currentPressureIncrease As Single
    Dim initAbsP As Single
    Dim initDiffP0 As Single
    Dim initDiffP As Single
    Dim finalAbsP As Single
    Dim finalDiffP As Single
    Dim diffAbsP As Single
    Dim diffDiffP As Single
    
    Dim t2 As Single
    Dim initial_offset%
    Dim local_time As Single
    Dim F_at_2 As Single
    Dim T_at_2 As Single
    
    numPoints = (GP_duration / GP_interval + 1)

    ReDim p_points(numPoints)
    ReDim f_points(numPoints)
    ReDim t_points(numPoints)
    ReDim temp1_points(numPoints) 'AJB 10-22-09
    ReDim temp2_points(numPoints) 'AJB 10-22-09
    singlePointGasTest.Label9.Caption = "0"

    startTime = Timer
    count = 0
    While (Timer - startTime) < GP_duration
        
        T = Timer

        While (Timer - T < GP_interval)
            DoEvents
        Wend
        p_avg = 0: f_avg = 0
        For j = 1 To GP_numavg
            'Might need to change the following variable
            If diffpgflow(current_unit%) Then
                'Open the vent valve and wait 10 seconds for the pressure to release from the chamber
                Move_Valve 13, "O"
                waitseconds 10
                
                'Read initial pressure values
                ReadXReturnX4 2
                p1 = x5
                currentPressureIncrease = p1 - p_atm
                initAbsP = p1
                
                ReadXReturnX4 13 + dpgplus%
                f0 = x5
                
                'Close the vent valve
                Move_Valve 13, "C"
                
                'Read initial pressure on diff pressure gauge with valve closed
                ReadXReturnX4 13 + dpgplus%
                f1 = x5
                initDiffP0 = f1
                t2 = Timer
                initial_offset% = 0
                
                Do
                    DoEvents
                    ReadXReturnX4 13 + dpgplus%
                    local_time = Timer
                    f2 = x5
                    
                    If x4 = DAC_over Then HKey$ = "T"
                    
                    If (local_time + 0.1 < t2) Then
                        t2 = t2 - 86400
                    End If
                    
                    If (local_time - t2 > 2) And (initial_offset% = 0) Then
                        initial_offset% = 1
                        F_at_2 = x5
                        T_at_2 = local_time
                    End If
                    
                    If (local_time - t2 > 4) And (initial_offset% = 1) Then
                        f1 = F_at_2
                        t2 = T_at_2
                        initial_offset% = 2
                    End If
                    
                    If (local_time - t2 > 2) Then
                        ReadXReturnX4 2
                        P = x5 - (f2 - f0)
                        f = (f2 - f1) / (local_time - t2) * 60 / 14.7 * Diff_Volume(manuallySelectedChamber + Current_Microflow_Volume_Index - 1)
                        diffp = f2 - f1
                    End If
                Loop While (local_time - t2 < 30) And (f2 - f1 < 0.5 * (PY2(4) - PY1(4))) And _
                           (f2 - diffp_atm) < (currentPressureIncrease * 0.9) And _
                           (Not Aborted) And _
                           ((f2 - PY1(4)) < 0.95 * (PY2(4) - PY1(4)))
                
                'Read the final pressure on the pressure gauge
                ReadXReturnX4 2
                p2 = x5 - (f2 - f0)
                
                initDiffP = f1
                finalAbsP = x5
                finalDiffP = f2
                
                diffAbsP = finalAbsP - initAbsP
                diffDiffP = finalDiffP - initDiffP
                
                'Open the vent valve
                Move_Valve 13, "O"
                
                If currentPressureIncrease > ((PY2(4) - PY1(4)) * 0.01) Then
                    If (local_time - t2) < 1 Then
                        HKey2$ = "T"
                        f = 99999
                        If microFlowUseAllVolumes Then
                            select_next_microflow_volume
                        End If
                    ElseIf local_time - t2 < 5 Then
                        If microFlowUseAllVolumes Then
                            select_next_microflow_volume
                        End If
                    Else
                        f = (f2 - f1) / (local_time - t2) * 60 / 14.7 * Diff_Volume(manuallySelectedChamber + Current_Microflow_Volume_Index - 1)
                    End If
                Else
                    f = (f2 - f1) / (local_time - t2) * 60 / 14.7 * Diff_Volume(manuallySelectedChamber + Current_Microflow_Volume_Index - 1)
                End If
                
                f_avg = f_avg + f
                p_avg = p_avg + finalAbsP
            Else
                ReadXReturnX4 FUSE%
                f_avg = f_avg + x5
                
                ReadXReturnX4 2
                p_avg = p_avg + x5
            End If
            'AJB 10-22-09
            If dryChamberTemperature <> 0 Then
                temp1_avg = temp1_avg + readNewTemperature(dryChamberTemperature, False)
            End If
            If airTemperature <> 0 Then
                temp2_avg = temp2_avg + readNewTemperature(airTemperature, False)
            End If
        Next j
        elapsedTime = Timer - startTime
        p_avg = p_avg / GP_numavg
        f_avg = f_avg / GP_numavg
        f_points(count) = f_avg
        p_points(count) = CVcalc(p_avg, f_avg)
        t_points(count) = elapsedTime
        
        'AJB 10-22-09 6.71.131
        If dryChamberTemperature <> 0 Then
            temp1_points(count) = temp1_avg / GP_numavg
        End If
        
        If airTemperature <> 0 Then
            temp2_points(count) = temp2_avg / GP_numavg
        End If
        
        singlePointGasTest.Label1.Caption = f_points(count) / 1000
        singlePointGasTest.Label2.Caption = p_points(count) - p_atm
        count = count + 1
        singlePointGasTest.Label9.Caption = count
        singlePointGasTest.Label5.Caption = elapsedTime
    Wend
    
    fna = FreeFile
    Open EXE_Path$ + "singlepointtest.txt" For Output As #fna
    
    Print #fna, "Flow         Pressure          Time (sec)"
    p_avg = 0: f_avg = 0
    dat_size_check X, count
    For i = 0 To count - 1
        p_avg = p_avg + p_points(i)
        f_avg = f_avg + f_points(i)
        'AJB 10-22-09
        If dryChamberTemperature <> 0 Then
            X.a(i).temp1 = temp1_points(i)
            If airTemperature <> 0 Then
                X.a(i).temp2 = temp2_points(i)
                Print #fna, Format(f_points(i) / 1000); "         "; Format(p_points(i) - p_atm); "          "; Format(t_points(i)); "          "; Format(temp1_points(i)); "          "; Format(temp2_points(i))
            Else
                Print #fna, Format(f_points(i) / 1000); "         "; Format(p_points(i) - p_atm); "          "; Format(t_points(i)); "          "; Format(temp1_points(i))
            End If
        Else
            Print #fna, Format(f_points(i) / 1000); "         "; Format(p_points(i) - p_atm); "          "; Format(t_points(i))
        End If
        
        X.a(i).fl = f_points(i)
        X.a(i).pr = p_points(i)
    Next i
    Print #fna, ""
    Print #fna, ""
    Print #fna, ""
    Print #fna, "Average pressure = "; Format(p_avg / count - p_atm)
    Print #fna, "Average flow = "; Format((f_avg / count) / 1000)

    Close #fna
    
    points = count
End Sub

Sub Process_CVError(Handle As Long)
    
F_Input:
    On Error GoTo 0
    fsel_title$ = "Cv " + ts$(425)      ' "Error Log File"
    fsel_name$ = ""
    fsel_io = True
    fsel_path$ = EXE_Path$ + "Cv error.log"
    fsel Handle
    If fsel_return$ = "" Then
        Exit Sub
    End If
    file$ = fsel_return$

    On Error GoTo Error_input
    Name EXE_Path$ + "Cv error.log" As file$
    On Error GoTo 0
    Exit Sub

Error_input:
    MsgBox ts$(426), 0, ts$(134)       ' "Error in renaming file. Try another."/"File Error"
    Resume F_Input

End Sub

Sub lv_valve_open(v%)
    lv_man_ctrl.ValveFill(v%).FillColor = vbGreen
    DoEvents
    Move_Valve -1 - v%, "O"
End Sub

Sub lv_valve_close(v%)
    Move_Valve -1 - v%, "C"
    lv_man_ctrl.ValveFill(v%).FillColor = vbRed
End Sub

Sub lv_valve_pulse(v%)
    lv_valve_open (v%)
    lv_valve_delay
    lv_valve_close (v%)
    lv_man_ctrl.ValveClick(v%).Enabled = True
End Sub

Sub lv_valve_delay()

    'Dim T As Single, lt As Single
    
    'T = Timer
    'Do
    '    lt = Timer
    '    If lt + 0.1 < T Then T = T - 86400
    'Loop Until (lt - T) >= lv_valve_pulse_timing
    waitseconds lv_valve_pulse_timing
End Sub

Sub lv_valve_pair_pulse(i As Integer)
    ' 0 pulses valves e and f, 1 pulses valves g and h
    
    lv_valve_pulse i * 2 + 4 ' 0=>4, 1=>6
    ' add an extra doevents to let the final color show
    DoEvents
    ' add an extra delay to let the valve close
    lv_valve_delay
    lv_valve_pulse i * 2 + 5 ' 0=>5, 1=>7
    
End Sub

Sub lv_goto(MIN, max, zero, Label As Object)
    
    If MIN >= max Then Exit Sub
    Do
        x5! = read_gauge(2) - zero
        Label.Caption = Format$(x5!, "#####0.#####") + " torr"
        If x5! >= MIN And x5! <= max Then Exit Do
        If x5! < MIN Then
            lv_valve_pair_pulse 0
        Else
            lv_valve_pair_pulse 1
        End If
        DoEvents
        lv_valve_delay ' add extra delay to let final valve close
    Loop Until abort_lv_goto
    
End Sub

Sub stagnation_check(Pressure As Single, Flow As Single)
    Dim L As Long, s As Single
    ' this is only valid on dual regulator systems
    If dualregulator = False Then Exit Sub
    ' and the second_regulator_starting_point must be > 0 or we aren't switching
    If second_regulator_starting_point = 0 Then Exit Sub
    ' and we have to be using the low regulator
    If using_low_regulator = False Then Exit Sub
    ' and we have to be using an I/P regulator
    If ip_reg_enable = False Then Exit Sub
    ' if pressure < 30 and flow < 50,000 then we are too low to be stagnant and should reset everything
    If Pressure < 30 And Flow < 50000 Then
        stagnation_check_best_flow = 0
        stagnation_check_best_pressure = 0
        stagnation_check_iterations = 0
        Exit Sub
    End If
    stagnation_check_iterations = stagnation_check_iterations + 1
    'If Pressure > stagnation_check_best_pressure Then
    '    stagnation_check_best_pressure = Pressure
    '    stagnation_check_iterations = 0
    'End If
    If Flow > stagnation_check_best_flow Then
        stagnation_check_best_flow = Flow
        stagnation_check_iterations = 0
    End If
    If stagnation_check_iterations < 2 Then Exit Sub
    ' switch regulators
    ' we start at zero since we can't predict how much choked flow there was through reg1
    Zero_Reg
    
    waitseconds 3
    If (air_inlets = 2) Then
       Move_Valve 15, "O"
       current_air_inlet = 2
    End If

    Move_Valve 16, "O"
    regnum = 1
    waitseconds 3
    fifty_or_seven = 7
    using_low_regulator = False
    ' now increase the regulator until we get to the best flow we have seen before
    ' start at user adjustable parameter
    inc_reg reg2_high_flow_switch_count
    waitseconds 2
    Do
        ReadXReturnX4 1 ' get current flow
        If x5 >= stagnation_check_best_flow Or Aborted Then Exit Do
        Msgform.Label1.Caption = Format$(REGPOS, "#####") + ":" + Format$(x5, "########.") + "<" + Format$(stagnation_check_best_flow, "########.")
        Msgform.Refresh
        If x5 < stagnation_check_best_flow / 10 Then
            inc_reg 7
        Else
            inc_reg 1
        End If
        waitseconds 1
    Loop
End Sub

Sub move_piston(direction$, Optional pretreat As Boolean = False)
    Move_Valve 2, "O"
    Waitms 2000, False
    
    If (direction$ = "O" And dual_stage_compression And pretreat_flow > 0 And pretreat_time > 0) Then
        ' put piston half down
        Move_Valve 23, "O"
        If pneumaticSwitchValveForPiston Then
            Move_Valve 15, "O"
        Else
            Move_Valve 14, "C" ' it should already be closed, but this won't hurt anything
        End If
        info_form.Caption = "Starting Pretreatment - opening valve 2"
        info_form.Label1.Caption = ""
        info_form.Label2.Caption = ""
        info_form.Show 0, pleasewait
        ' open valve 2 to the normal open point
        OPENV2MOSTLY
        HFLOW% = 1
        If pretreat_flow > FY2(1, 1) Then
            HFLOW% = 0
            If pretreat_flow > FY2(1, 0) And xhflow Then
                HFLOW% = 3
                If pretreat_flow > FY2(1, 3) Then
                    HFLOW% = 2
                End If
            End If
        End If
        If pretreat_flow > FY2(1, HFLOW%) Then pretreat_flow = FY2(1, HFLOW%)
        Move_Valve 2, "C" ' flow vent valve
        info_form.Caption = "Incrementing flow to target value"
        ' increment regulator until either 4000 counts or we reach pretreat flow
        Do
            inc_reg 20
            ReadXReturnX4 1
            info_form.Label1.Caption = "Flow=" + Format$(x5, "#####0.0")
        Loop Until (x5 >= pretreat_flow) Or (REGPOS = 4000)
        info_form.Caption = "Waiting for pretreatment time"
        info_form.Label1.Caption = ""
        waitseconds pretreat_time
        Move_Valve 2, "O" ' open vent valve
        If pneumaticSwitchValveForPiston Then
            Move_Valve 14, "O"
        Else
            Move_Valve 14, "O" ' lower piston remaining way down
        End If
        Zero_Reg ' zero the regulator
        info_form.Caption = "Pretreatment finished, closing valve 2"
        excercize_valve_2 ' which ends up with valve 2 all the way closed
        ' leave venting valve open for now since we should have been called with it already open
        ' we return without the normal delay to wait for the piston to move since
        ' we already delayed quite a bit during the pretreatment
        Unload info_form
        Move_Valve 2, "C"
        Exit Sub
    End If
    If pneumaticSwitchValveForPiston Then
        If direction$ = "O" Then
            Move_Valve 14, "O"
        ElseIf direction$ = "C" Then
            Move_Valve 15, "O"
        End If
    Else
        Move_Valve 14, direction$
    End If
    If dual_stage_compression Then Move_Valve 23, direction$
    If direction$ = "O" Then
        waitseconds pistonDelayTime
    End If
    Move_Valve 2, "C"
End Sub

Function capflow_ts(Index As Integer) As String
    capflow_ts = ts$(Index)
End Function

Public Sub appendLogStatistics()
' Append the FResult string with bubble point and mean flow pore statistics.

    Dim fn As Integer
    Dim resultNumber As Integer             ' Each item in the log file is now numbered; this is the current number
    Dim MFPcount As Integer, BPcount As Integer
    Dim MFPs() As Single                     ' array of MFP values in the file
    Dim BPs() As Single                      ' array of BPs in the file
    Dim temp$
    Dim i As Integer
    Dim lowerBound As Integer, upperBound As Integer    ' Bounds for finding the number we need in the string
    Dim tempValue As Single                 ' holder for retrieved value
    Dim MFPavg As Single, BPavg As Single   ' Average values
    Dim MFPstdev As Single, BPstdev As Single   ' Standard deviations
    
' NOTE! Right now this assumes the test is a capflow or bubble point test
        
    ' To put statistics in the file, we need to parse the whole thing
    ' First, figure out how many entries we're dealing with
    fn = FreeFile
    On Error GoTo nofile
    Open logpath For Input As #fn       ' This only works if there is a pre-existing file!
    While Not EOF(fn)
        Line Input #fn, temp$
        If InStr(temp$, "-------") > 0 Then resultNumber = resultNumber + 1 ' Each logged result ends with a line of dashes
    Wend
    Close #fn
    
    ' Now collect the previous values. (Obviously, we only have to do this if
    ' there ARE previous values ....)
    If resultNumber > 0 Then
        i = 0: BPcount = 0: MFPcount = 0
        ReDim MFPs(resultNumber + 1)
        ReDim BPs(resultNumber + 1)
        Open logpath For Input As #fn
        While Not EOF(fn)
            Line Input #fn, temp$
            ' Check each line for divider (dashes), bubble point (commas, but no = sign), or
            ' MFP (includes = sign). This is dangerously inflexible, but the easiest way to do
            ' this since the strings themselves are translatable into other languages!
            If InStr(temp$, "---------") > 0 Then
                i = i + 1     ' keep track of the results we've finished so far
            ElseIf InStr(temp$, "--") Then
                ' Do nothing
            ElseIf InStr(temp$, ",") Then       ' MFP or BP
                ' Both values are found between the second colon and parenthesis in their strings, so
                ' we can get those up here and find the value before we know which it is.
                lowerBound = RInStr(temp$, ":")
                upperBound = RInStr(temp$, "(")
                tempValue = myVal(Mid$(temp$, lowerBound + 1, upperBound - lowerBound - 1))
    
                If InStr(temp$, "=") Then       ' BP
                    BPcount = BPcount + 1
                    BPs(BPcount) = tempValue
                Else                            ' Should be a MFP
                    MFPcount = MFPcount + 1
                    MFPs(MFPcount) = tempValue
                End If
            End If
        Wend
    End If
    
    Close #fn
    
    ' Now we should have all our previous values; add in the current ones
    resultNumber = resultNumber + 1
    '*************************
   '     logFileResults(1) = 0.042
   ' logFileResults(2) = 4
    '************************
    ' logFileResults is filled when these values are calculated elsewhere (cf calcMFP)
    If logFileResults(1) > 0 Then
        BPcount = BPcount + 1
        BPs(BPcount) = logFileResults(1)
    End If
    If logFileResults(2) > 0 Then
        MFPcount = MFPcount + 1
        MFPs(MFPcount) = logFileResults(2)
    End If
    
    ' Do our statistics. Just in case we have mixed porometry and BP tests, we have to calculate all these
    ' in seperate loops.
    ' Standard dev = sqrt((sum(x-xave)^2)/(n-1))
    If BPcount > 0 Then
        For i = 1 To BPcount
            BPavg = BPavg + BPs(i)
        Next i
        BPavg = BPavg / BPcount
        For i = 1 To BPcount
            BPstdev = BPstdev + (BPs(i) - BPavg) ^ 2
        Next i
        BPstdev = Sqr(BPstdev / (BPcount - 1))
        ' Append the string
        FResult = FResult + vbCrLf + "-- Bubble point diameter statistics:  average = " + Format$(BPavg, "###0.0##") + ", stdev = " + Format$(BPstdev, "###0.0##")
    End If
    
    If MFPcount > 0 Then
        For i = 1 To MFPcount
            MFPavg = MFPavg + MFPs(i)
        Next i
        MFPavg = MFPavg / MFPcount
        For i = 1 To MFPcount
            MFPstdev = MFPstdev + (MFPs(i) - MFPavg) ^ 2
        Next i
        MFPstdev = Sqr(MFPstdev / (MFPcount - 1))
        ' Append the string
        FResult = FResult + vbCrLf + "-- Mean flow pore diameter statistics:  average = " + Format$(MFPavg, "###0.0##") + ", stdev = " + Format$(MFPstdev, "###0.0##")
    End If
    
    '*************************
    'FResult = "BP = " + Str$(BPs(resultNumber)) + vbCrLf + "MFP = " + Str$(MFPs(resultNumber))
    '*************************
    
nofile:         ' The log file hasn't been created yet, so there are no statistics
    
   
End Sub
Public Sub Build_Cake_By_Pressure_Sub() '6.71.123.20
'fill the slurry tube and push through the sample with air pressure; repeating until a low flow endpoint is reached.
    Dim level1 As Double
    Dim level2 As Double
    Dim flowRate As Double
    Dim endFlowRate As Double
    Dim flowRateCounter As Integer
    'Dim fnCakePressure As Integer
    Dim cakePressureTime As Integer
    'fnCakePressure = FreeFile
    'Open EXE_Path$ + "BuildCakeByPressureData.txt" For Output As #fnCakePressure
    Dim Data() As Single
    'Dim startTime As Date
    'Dim currentTime As Date
    'Dim deltaT As Double
    
    cakePressureTime = 1
    endFlowRate = BuildCakeByPressureEndFlow
    BuildCakeByPressureAbort = False
    'isolate slurry tube from air side
    Move_Valve Slurry_tube_top_shut_off, "C" 'slurry tube top shut off valve V43
    Move_Valve Slurry_tube_vent_valve, "C" 'slurry tube vent valve V29 O = Air Side C = Vent/Drain
    
    'Close other valves on the air side
    Move_Valve 0, "C" 'V1
    Dry_Chamber_Control "C"       'C = Air to chamber
    Move_Valve 8, "C" 'V9
    Move_Valve 9, "C" 'V10
    
    If Drain12 Then
        Move_Valve 11, "C"
    End If
    
    'Put air on ready to go
    OPENV2MOSTLY
    move_motorized_regulator_to_pressure (BuildCakeByPressureTargetPressure)
        
    Do
        Fill_Slurry_Tube_Sub
        Move_Valve Slurry_tube_fill_valve, "C" 'slurry tube fill valve V44
        If Drain12 Then
            Move_Valve 11, "O"  'drain valve V12
        End If
        Move_Valve Slurry_tube_vent_valve, "O" 'slurry tube vent valve V29 O = Air Side C = Vent/Drain
        
        Status.Label1.Caption = ts$(503)
        Status.Label1.Visible = True
        Status.Label2.Caption = ""
        Status.Label2.Visible = True
        Status.Command1.Visible = True
        Status.Refresh
        Status.Show 0
        'ReadXReturnX4 39 'slurry tube level
        'While x5 > slurry_tube_almost_empty_cm And status.Command1.Enabled
        '    waitseconds 1
        '    ReadXReturnX4 39 'slurry tube level
        '    status.Label2.Caption = ts$(512) + Xformat$(x5, "#####.000") + " " + ts$(310)
        '    status.Label2.Refresh
        'Wend
        
        'Reset flowRate counter
        flowRateCounter = 0
        
        Do
            ReadXReturnX4 39 'slurry tube level
            level1 = x5
            waitseconds 1
            ReadXReturnX4 39 'slurry tube level
            level2 = x5
            flowRate = (level1 - level2) * 20.65 * 60
                       
            ReDim Preserve Data(1 To (cakePressureTime + 1))
            Data(cakePressureTime) = flowRate
                     
            cakePressureTime = cakePressureTime + 1
            
            Status.Label1.Caption = "Current Flow Rate: " + Xformat$(flowRate, "#####.000") + " ml/min"
            Status.Label1.Refresh
                      
            'Print #fnCakePressure, Xformat$(flowRate, "#####.000"); vbTab; cakePressureTime
                       
            'If flowRate < endFlowRate Then
            '    flowRateCounter = flowRateCounter + 1
            'End If
            
            'If flowRateCounter > 1 Then
            
            If flowRate < endFlowRate Then
                BuildCakeByPressureAbort = True
            End If
                
        Loop While x5 > slurry_tube_almost_empty_cm And Status.Command1.Enabled And Not BuildCakeByPressureAbort
         
        Move_Valve Slurry_tube_vent_valve, "C" 'slurry tube vent valve V29 O = Air Side C = Vent/Drain
        
        
    Loop While Not Aborted And Status.Command1.Enabled And Not BuildCakeByPressureAbort
    Status.Label1.Caption = ""
    Status.Label2.Caption = ""
    Unload Status
    Dim header(1 To 2) As String
    header(1) = "Flow (ml/min):"
    header(2) = "Time (Sec):"
    
    Save_Data header, Data, cakePressureTime
    
    Move_Valve Slurry_tube_vent_valve, "C" 'slurry tube vent valve V29 O = Air Side C = Vent/Drain
    Zero_Reg
    'Close #fnCakePressure
    'close path from slurry tank to sample
    Move_Valve Slurry_tube_fill_valve, "C" 'slurry tube fill valve V44
    
End Sub
Public Sub Save_Data(header() As String, Data() As Single, time As Integer)
    Dim i As Variant
    Dim fnOutput As Integer
    
    fnOutput = FreeFile
    Open OutFilename$(current_unit%) For Output As #fnOutput
    
    Print #fnOutput, header(1); vbTab; header(2)
    
    For i = 1 To time
            Print #fnOutput, Xformat$(Data(i), "#####.000"); vbTab; i
    Next i
    Close #fnOutput
End Sub
Public Sub Fill_Slurry_Tube_Sub() '6.71.123.20
'fill the slurry tube based on level with slurry. The top of the tube will be venting.

    ReadXReturnX4 39 'slurry tube level
    If x5 >= slurry_tube_almost_full_cm Then GoTo Level_Finish
    
    If Drain12 Then
        Move_Valve 11, "C" 'drain valve V12
    End If
    'set slurry tube top to vent/drain and then open isolation valve
    Move_Valve Slurry_tube_vent_valve, "C" 'slurry tube vent valve V29 O = Air Side C = Vent/Drain
    waitseconds 1
    Move_Valve Slurry_tube_top_shut_off, "O" 'slurry tube top shut off valve V43
    
    Move_Valve Slurry_wash_valve, "C" 'slurry/wash valve V28 O = Wash C = Slurry
    Move_Valve Slurry_tube_fill_valve, "O" 'slurry tube fill valve V44
    
    'start the flow
    set_slurry_wash_pump_aout_by_flow (0)
    Move_Valve Slurry_wash_pump, "C" 'slurry wash pump 30 O = OFF, C = ON
    set_slurry_wash_pump_aout_by_flow (SlurryTubeWashCycleTargetFlow)
    
    Status.Label1.Caption = ts$(503)
    Status.Label1.Visible = True
    Status.Label2.Caption = ""
    Status.Label2.Visible = True
    Status.Command1.Visible = True
    Status.Refresh
    Status.Show 0
    ReadXReturnX4 39 'slurry tube level
    While x5 < slurry_tube_almost_full_cm And Status.Command1.Enabled
        waitseconds 1
        ReadXReturnX4 39 'slurry tube level
        Status.Label2.Caption = ts$(511) + Xformat$(x5, "#####.000") + " " + ts$(310)
        Status.Label2.Refresh
    Wend
    If Not Status.Command1.Enabled Then
        BuildCakeByPressureAbort = True
    End If
    
Level_Finish:

    'stop the flow
    set_slurry_wash_pump_aout_by_flow (0)
    Move_Valve Slurry_wash_pump, "O" 'slurry wash pump 30 O = OFF, C = ON
    
    Status.Label1.Caption = ""
    Status.Label2.Caption = ""
    Unload Status
    
End Sub
Public Sub Build_Cake_By_Flow_Sub() '6.71.123.20
'line up the slurry tank and pump it through the sample until a high pressure endpoint is reached.
    Dim Data() As Single
    Dim cakeFlowTime As Integer
    Dim abortBuild As Boolean
    
    abortBuild = False
    
    'isolate slurry tube from air side
    Move_Valve Slurry_tube_top_shut_off, "C" 'slurry tube top shut off valve V43
    Move_Valve Slurry_tube_vent_valve, "C" 'slurry tube vent valve V29 O = Air Side C = Vent/Drain
    
    'set up rest of path from slurry tank to sample and past it
    Move_Valve Slurry_wash_valve, "C" 'slurry/wash valve V28 O = Wash C = Slurry
    Move_Valve Slurry_tube_fill_valve, "O" 'slurry tube fill valve V44
    If Drain12 Then
        Move_Valve 11, "O"
    End If
    
    'start the flow
    set_slurry_wash_pump_aout_by_flow (0)
    Move_Valve Slurry_wash_pump, "C" 'slurry wash pump 30 O = OFF, C = ON
    set_slurry_wash_pump_aout_by_flow (BuildCakeByFlowTargetFlow)
    
    Status.Label1.Caption = ts$(504) + ts$(506) + Xformat$(BuildCakeByFlowEndPressure * PCNV, "#####.000") + " " + PU$
    Status.Label1.Visible = True
    Status.Label2.Caption = ""
    Status.Label2.Visible = True
    Status.Command1.Visible = True
    Status.Refresh
    Status.Show 0
    
    ReadXReturnX4 41 'slurry tube pressure
    
    cakeFlowTime = 1
    
    If x5 >= BuildCakeByFlowEndPressure Then
        MsgBox "BuildCakeByFlowEndPressure is set to less than the current pressure.  Aborting Build.", vbInformation
        abortBuild = True
    End If
    
    While x5 < BuildCakeByFlowEndPressure And Status.Command1.Enabled
        waitseconds 1
        ReadXReturnX4 41 'slurry tube pressure
        
        ReDim Preserve Data(1 To cakeFlowTime + 1)
        Data(cakeFlowTime) = x5
        
        cakeFlowTime = cakeFlowTime + 1
        
        Status.Label2.Caption = ts$(507) + Xformat$(x5 * PCNV, "#####.000") + " " + PU$
        Status.Label2.Refresh
    Wend
    Status.Label1.Caption = ""
    Status.Label2.Caption = ""
    Unload Status
    
    'stop the flow
    set_slurry_wash_pump_aout_by_flow (0)
    Move_Valve Slurry_wash_pump, "O" 'slurry wash pump 30 O = OFF, C = ON
    
    'close path from slurry tank to sample
    Move_Valve Slurry_tube_fill_valve, "C" 'slurry tube fill valve V44
    Dim header(1 To 2) As String
    header(1) = "Pressure (PSI):"
    header(2) = "Time (Sec):"
    
    If Not abortBuild Then
        Save_Data header, Data, cakeFlowTime
    End If
    
End Sub
Public Sub Slurry_Tube_Wash_Cycle_Sub() '6.71.123.20
'line up the wash tank and pump it through the sample chamber until flow total exceeds a certain value or the user aborts.

    Dim FTot As Single
    Dim T As Single
    Dim lastT As Single
    Dim firstT As Single
    
    'isolate slurry tube from air side
    Move_Valve Slurry_tube_top_shut_off, "C" 'slurry tube top shut off valve V43
    Move_Valve Slurry_tube_vent_valve, "C" 'slurry tube vent valve V29 O = Air Side C = Vent/Drain
    
    'set up rest of path from wash tank to sample and past it
    Move_Valve Slurry_wash_valve, "O" 'slurry/wash valve V28 O = Wash C = Slurry
    Move_Valve Slurry_tube_fill_valve, "O" 'slurry tube fill valve V44
    If Drain12 Then
        Move_Valve 11, "O"
    End If
    
    'start the flow
    set_slurry_wash_pump_aout_by_flow (0)
    Move_Valve Slurry_wash_pump, "C" 'slurry wash pump 30 O = OFF, C = ON
    set_slurry_wash_pump_aout_by_flow (SlurryTubeWashCycleTargetFlow)
    
    FTot = 0
    T = Timer
    firstT = T

    Status.Label1.Caption = ts$(505)
    Status.Label1.Visible = True
    Status.Label2.Caption = ""
    Status.Label2.Visible = True
    Status.Command1.Visible = True
    Status.Refresh
    Status.Show 0
    While Status.Command1.Enabled
        waitseconds 1
        T = Timer
        FTot = ((T - firstT) / 60) * SlurryTubeWashCycleTargetFlow
        Status.Label2.Caption = ts$(508) + Xformat$(FTot, "##0000") + ts$(509) + Xformat$(WashTankVolume_cc, "##0000") + ts$(510)
        Status.Label2.Refresh
    Wend
    Status.Label1.Caption = ""
    Status.Label2.Caption = ""
    Unload Status
    
    'stop the flow
    set_slurry_wash_pump_aout_by_flow (0)
    Move_Valve Slurry_wash_pump, "O" 'slurry wash pump 30 O = OFF, C = ON
    
    'close path from slurry tank to sample
    Move_Valve Slurry_tube_fill_valve, "C" 'slurry tube fill valve V44
    
End Sub

Public Sub DepressurizeSystemAtBeginning() '7.73.012.01
    ' zero regulator, vent system
    Zero_Reg
    Move_Valve 2, "O"
    Msgform.Label1.AutoSize = True
    Msgform.Label1.Caption = ts$(513) 'Ensuring system is not under pressure.
    Msgform.Label1.Visible = True
    Msgform.Label.Visible = False
    Msgform.lb.Visible = False
    Msgform.ok.Visible = False
    Msgform.cancel.Visible = False
    Msgform.StopTest.Visible = False
    Msgform.Show 0
    Msgform.Refresh
    waitseconds (10)
    Unload Msgform
    Move_Valve 2, "C"
End Sub


Public Sub LoadTextStrings()
' Load text elements for this form from external .ini file
    
    Dim tempname$           ' Name of extra language file
    
    '   This module is so large that it singlehandedly doubles the size of language.ini, bringing it up
    ' to the 32 kB size limit for .ini files. Therefore, we'll create a second .ini file just for this
    ' module's text.
    
    tempname$ = language$   ' Save old name for later
    ' edc 03-05-07 language altered
    If currentLanguagePath = "CapWinLanguageRU.ini" Then
        language$ = App.path + "\languages\CapWinLanguage2RU.ini"
    ElseIf currentLanguagePath = "CapWinLanguageDE.ini" Then
        language = App.path + "\languages\CapWinLanguage2DE.ini"
    ElseIf currentLanguagePath = "CapWinLanguageFR.ini" Then
        language = App.path + "\languages\CapWinLanguage2FR.ini"
    ElseIf currentLanguagePath = "CapWinLanguageJA.ini" Then
        language = App.path + "\languages\CapWinLanguage2JA.ini"
    ElseIf currentLanguagePath = "CapWinLanguageCN.ini" Then
        language = App.path + "\languages\CapWinLanguage2CN.ini"
    ElseIf currentLanguagePath = "CapWinLanguagePT.ini" Then
        language = App.path + "\languages\CapWinLanguage2PT.ini"
    Else
        language = App.path + "\languages\CapWinLanguage2EN.ini"
        End If
    
    ' Text strings for this form
    ts$(1) = gpps2("capflow", "ts1", language$, "Is the fill valve open, the reservoir full, but the float not going up?")
    ts$(2) = gpps2("capflow", "ts2", language$, "Purge is only to be used when trapped air in the line stops the normal flow into the penetrometer")
    ts$(3) = gpps2("capflow", "ts3", language$, "Leave fill valve open during the purge")
    ts$(4) = gpps2("capflow", "ts4", language$, "Ready to purge")
    ts$(5) = gpps2("capflow", "ts5", language$, "Abort")
    ts$(6) = gpps2("capflow", "ts6", language$, "Purging to 92.5% - please wait")
    ts$(7) = gpps2("capflow", "ts7", language$, "Purge")
    ts$(8) = gpps2("capflow", "ts8", language$, "Close the fill valve BEFORE clicking OK")
    ts$(9) = gpps2("capflow", "ts9", language$, "You can now resume filling the penetrometer")
    ts$(10) = gpps2("capflow", "ts10", language$, "Zeroing regulator to start Lohm calibration")
    ts$(11) = gpps2("capflow", "ts11", language$, "Closing valve 2")
    ts$(12) = gpps2("capflow", "ts12", language$, "Venting system for stable atmospheric pressure")
    ts$(13) = gpps2("capflow", "ts13", language$, "Waiting 5 seconds for stability")
    ts$(14) = gpps2("capflow", "ts14", language$, "Checking speed of communication")
    ts$(15) = gpps2("capflow", "ts15", language$, "Done: Reads per second calculated at")
    ts$(16) = gpps2("capflow", "ts16", language$, "Initial Pressure")
    ts$(17) = gpps2("capflow", "ts17", language$, "Initial Pressure (Low PG HR)")
    ts$(18) = gpps2("capflow", "ts18", language$, "Warning: The Low Pressure (High Range)")
    ts$(19) = gpps2("capflow", "ts19", language$, "is not calibrated correctly")
    ts$(20) = gpps2("capflow", "ts20", language$, "Initial Pressure (Low PG LR)")
    ts$(21) = gpps2("capflow", "ts21", language$, "Warning: The Low Pressure (Low Range)")
    ts$(22) = gpps2("capflow", "ts22", language$, "Opening Valve 2 to initiate regulator")
    ts$(23) = gpps2("capflow", "ts23", language$, "Incrementing regulator to achieve full flow on hflow1")
    ts$(24) = gpps2("capflow", "ts24", language$, "Incrementing regulator: Flow")
    ts$(25) = gpps2("capflow", "ts25", language$, "Opening Valve 2 to first flow position")
    ts$(26) = gpps2("capflow", "ts26", language$, "Special Valve 2 Lohm calibration")
    ts$(27) = gpps2("capflow", "ts27", language$, "Opening Valve 2 all the way")
    ts$(28) = gpps2("capflow", "ts28", language$, "Incrementing regulator to initial position")
    ts$(29) = gpps2("capflow", "ts29", language$, "Waiting for stable: Pressure")
    ts$(30) = gpps2("capflow", "ts30", language$, "Flow")
    ts$(31) = gpps2("capflow", "ts31", language$, "Averaging: Pressure")
    ts$(32) = gpps2("capflow", "ts32", language$, "HFlow1 calibration finished - switching to HFlow2 - opening valve 2")
    ts$(33) = gpps2("capflow", "ts33", language$, "Zeroing Regulator")
    ts$(34) = gpps2("capflow", "ts34", language$, "Lohm Calibration Aborted")
    ts$(35) = gpps2("capflow", "ts35", language$, "Lohm Calibration Completed")
    ts$(36) = gpps2("capflow", "ts36", language$, "Lohm was calibrated using a low inlet pressure")
    ts$(37) = gpps2("capflow", "ts37", language$, "You may get a more accurate result if you can increase the inlet pressure.")
    ts$(38) = gpps2("capflow", "ts38", language$, "If you are using your highest inlet pressure, ignore this message.")
    ts$(39) = gpps2("capflow", "ts39", language$, "If you can increase the inlet pressure, do so and rerun Lohm calibration.")
    ts$(40) = gpps2("capflow", "ts40", language$, "Lohm Calculation")
    ts$(41) = gpps2("capflow", "ts41", language$, "Do you want to save this Lohm calibration to a named backup file?")
    ts$(42) = gpps2("capflow", "ts42", language$, "Backup Lohm Calibration File")
    ts$(43) = gpps2("capflow", "ts43", language$, "There was an error copying the file.  You may have to manually copy the file lohmtable.cal if you still want a backup.")
    ts$(44) = gpps2("capflow", "ts44", language$, "Put non-porous disk in sample chamber and seal")
    ts$(45) = gpps2("capflow", "ts45", language$, "Remove non-porous disk and connect top of chamber to instrument")
    ts$(46) = gpps2("capflow", "ts46", language$, "The sample chamber should be empty.")
    ts$(47) = gpps2("capflow", "ts47", language$, "Insert large insert into chamber.")
    ts$(48) = gpps2("capflow", "ts48", language$, "Screw on cap with quick-connect.")
    ts$(49) = gpps2("capflow", "ts49", language$, "Attach penetrometer hose to cap.")
    ts$(50) = gpps2("capflow", "ts50", language$, "Fill sample chamber with water.")
    ts$(51) = gpps2("capflow", "ts51", language$, "Press OK when complete.")
    ts$(52) = gpps2("capflow", "ts52", language$, "Calibration Setup")
    ts$(53) = gpps2("capflow", "ts53", language$, "Liquid Calibration")
    ts$(54) = gpps2("capflow", "ts54", language$, "Can not calculate maximum liquid flow - something is wrong with the penetrometer settings as no flow readings could be taken.")
    ts$(55) = gpps2("capflow", "ts55", language$, "The calibrated liquid flow of")
    'ts$(56) = gpps2("capflow", "ts56", language$, "cc/min")
    ts$(57) = gpps2("capflow", "ts57", language$, "was calculated.")
    ts$(58) = gpps2("capflow", "ts58", language$, "Calibration Done")
    ts$(59) = gpps2("capflow", "ts59", language$, "CleanOut is not really necessary for your machine.  Do you wish to do it anyway?")
    ts$(60) = gpps2("capflow", "ts60", language$, "CleanOut")
    ts$(61) = gpps2("capflow", "ts61", language$, "Do you wish to do a Final Cleanout to remove remaining liquid from the system?")
    ts$(62) = gpps2("capflow", "ts62", language$, "Remove any sample from the chamber, seal the empty chamber, and attach the air hose.")
    ts$(63) = gpps2("capflow", "ts63", language$, "Press OK to continue.")
    ts$(64) = gpps2("capflow", "ts64", language$, "Remove any sample from the chamber and install the nonporous insert.")
    ts$(65) = gpps2("capflow", "ts65", language$, "The drain will now be pulsed to purge any fluid.")
    ts$(66) = gpps2("capflow", "ts66", language$, "Check drain to see if fluid is still coming from the machine.")
    ts$(67) = gpps2("capflow", "ts67", language$, "Is further purging necessary?")
    ts$(68) = gpps2("capflow", "ts68", language$, "Cleanout Complete.")
    ts$(69) = gpps2("capflow", "ts69", language$, "Evacuating - please wait")
    ts$(70) = gpps2("capflow", "ts70", language$, "Zeroing regulator - please wait.")
    ts$(71) = gpps2("capflow", "ts71", language$, "Opening Valve 2 - please wait.")
    ts$(72) = gpps2("capflow", "ts72", language$, "Internal Pressure")
    ts$(73) = gpps2("capflow", "ts73", language$, "External Pressure")
    ts$(74) = gpps2("capflow", "ts74", language$, "Time")
    ts$(75) = gpps2("capflow", "ts75", language$, "min.")
    ts$(76) = gpps2("capflow", "ts76", language$, "Test finished, remove sample")
    ts$(77) = gpps2("capflow", "ts77", language$, "Done")
    ts$(78) = gpps2("capflow", "ts78", language$, "The motorized valve needs to be calibrated.")
    ts$(79) = gpps2("capflow", "ts79", language$, "Please calibrate and restart the test.")
    ts$(80) = gpps2("capflow", "ts80", language$, "Force")
    ts$(81) = gpps2("capflow", "ts81", language$, "Waiting for flow meter to stabilize")
    ts$(82) = gpps2("capflow", "ts82", language$, "Waiting for low flow meter to stabilize")
    ts$(83) = gpps2("capflow", "ts83", language$, "HydroHead")
    ts$(84) = gpps2("capflow", "ts84", language$, "Record")
    ts$(85) = gpps2("capflow", "ts85", language$, "Calculating volumes - part")
    ts$(86) = gpps2("capflow", "ts86", language$, "Pressure has not gone up yet - possible leak")
    ts$(87) = gpps2("capflow", "ts87", language$, "Lowest suggested V2Percent is 20 - setting value to 20")
    ts$(88) = gpps2("capflow", "ts88", language$, "Error: Can't have autopiston and autocompress both on")
    ts$(89) = gpps2("capflow", "ts89", language$, "WARNING:  Fail Safe Mode turned OFF!!!")
    ts$(90) = gpps2("capflow", "ts90", language$, "Version")
    ts$(91) = gpps2("capflow", "ts91", language$, "Improper format for TSUNIT - should be C or F")
    ts$(92) = gpps2("capflow", "ts92", language$, "Liquid Vapor Permeameter")
    ts$(93) = gpps2("capflow", "ts93", language$, "Automated Gas Permeameter")
    ts$(94) = gpps2("capflow", "ts94", language$, "Complete Filter Analyzer")
    ts$(95) = gpps2("capflow", "ts95", language$, "Integrity Tester")
    ts$(96) = gpps2("capflow", "ts96", language$, "Bubble Point Tester")
    ts$(97) = gpps2("capflow", "ts97", language$, "Envelope Surface Area Analyzer")
    ts$(98) = gpps2("capflow", "ts98", language$, "Liquid Permeameter")
    ts$(99) = gpps2("capflow", "ts99", language$, "top")
    ts$(100) = gpps2("capflow", "ts100", language$, "autofilling")
    ts$(101) = gpps2("capflow", "ts101", language$, "Perm-Porometer")
    ts$(102) = gpps2("capflow", "ts102", language$, "Capillary Flow Porometer")
    ts$(103) = gpps2("capflow", "ts103", language$, "Unit")
    ts$(104) = gpps2("capflow", "ts104", language$, "INCLUDES")
    ts$(105) = gpps2("capflow", "ts105", language$, "Low Flow meter")
    ts$(106) = gpps2("capflow", "ts106", language$, "High Flow meter")
    ts$(107) = gpps2("capflow", "ts107", language$, "Pressure Gauge")
    ts$(108) = gpps2("capflow", "ts108", language$, "PSIA")
    ts$(109) = gpps2("capflow", "ts109", language$, "Diff. Press. Gauge")
    ts$(110) = gpps2("capflow", "ts110", language$, "volume above sample chamber")
    'ts$(111) = gpps2("capflow", "ts111", language$, "cc")
    ts$(112) = gpps2("capflow", "ts112", language$, "Integrity meter")
    ts$(113) = gpps2("capflow", "ts113", language$, "Calibrated flow maxima at")
    ts$(114) = gpps2("capflow", "ts114", language$, "gas")
    ts$(115) = gpps2("capflow", "ts115", language$, "liquid.")
    ts$(116) = gpps2("capflow", "ts116", language$, "Motorized Regulator Present")
    ts$(117) = gpps2("capflow", "ts117", language$, "I/P Regulator Present")
    ts$(118) = gpps2("capflow", "ts118", language$, "Optional 5:1 Regulator Present")
    ts$(119) = gpps2("capflow", "ts119", language$, "Standard 1:1 Regulator Present")
    ts$(120) = gpps2("capflow", "ts120", language$, "Machine Specifications")
    ts$(121) = gpps2("capflow", "ts121", language$, "Error - can't read feature number on version < 6")
    ts$(122) = gpps2("capflow", "ts122", language$, "Error - check version number of instrument - hardware=7, software=6")
    ts$(123) = gpps2("capflow", "ts123", language$, "Error - check version number of instrument - hardware=6, software=7")
    ts$(124) = gpps2("capflow", "ts124", language$, "Error reading feature number from instrument")
    ts$(125) = gpps2("capflow", "ts125", language$, "Error reading Test Enable number from instrument")
    ts$(126) = gpps2("capflow", "ts126", language$, "Data File")
    ts$(127) = gpps2("capflow", "ts127", language$, "Bubble Point")
    ts$(128) = gpps2("capflow", "ts128", language$, "Setting Compression Pressure")
    ts$(129) = gpps2("capflow", "ts129", language$, "Cyclic Pressure Initializing")
    ts$(130) = gpps2("capflow", "ts130", language$, "Pressure Not Available")
    ts$(131) = gpps2("capflow", "ts131", language$, "Comp. Press.")
    ts$(132) = gpps2("capflow", "ts132", language$, "Cycle Number")
    ts$(133) = gpps2("capflow", "ts133", language$, "Error in reading file.  Try another.")
    ts$(134) = gpps2("capflow", "ts134", language$, "File Error")
    ts$(135) = gpps2("capflow", "ts135", language$, "You must set the Comm port before running the instrument")
    ts$(136) = gpps2("capflow", "ts136", language$, "Error in Communication to Instrument, starting Demo mode.")
    ts$(137) = gpps2("capflow", "ts137", language$, "Com Error")
    ts$(138) = gpps2("capflow", "ts138", language$, "Error: The capcal.d8a file is not set for a flow controller instrument")
    ts$(139) = gpps2("capflow", "ts139", language$, "Your CAPCAL.D8A file is corrupted.  Please run flow parameter calibration before any tests.")
    ts$(140) = gpps2("capflow", "ts140", language$, "Warning: Make sure your instrument is turned on!")
    ts$(141) = gpps2("capflow", "ts141", language$, "Warning:  Check your pressure gauge settings")
    ts$(142) = gpps2("capflow", "ts142", language$, "You must calibrate your compression regulator before running a test.")
    ts$(143) = gpps2("capflow", "ts143", language$, "Feature number mismatch.")
    ts$(144) = gpps2("capflow", "ts144", language$, "hardware")
    ts$(145) = gpps2("capflow", "ts145", language$, "Do you want to use External Pressure Transducer?")
    ts$(146) = gpps2("capflow", "ts146", language$, "Using External Sample Chamber")
    ts$(147) = gpps2("capflow", "ts147", language$, "Error - you can't initialize hardware on version > 6")
    ts$(148) = gpps2("capflow", "ts148", language$, "Leak Test Setup")
    ts$(149) = gpps2("capflow", "ts149", language$, "Place non-porous insert in chamber")
    ts$(150) = gpps2("capflow", "ts150", language$, "and seal")
    ts$(151) = gpps2("capflow", "ts151", language$, "Enter maximum pressure (differential)")
    ts$(152) = gpps2("capflow", "ts152", language$, "Pressure exceeds maximum differential pressure of")
    ts$(153) = gpps2("capflow", "ts153", language$, "Rerun and enter pressure (differential) lower than")
   ' ts$(154) = gpps2("capflow", "ts154", language$, "30 PSIG")
    ts$(155) = gpps2("capflow", "ts155", language$, "Enter step pressure")
    ts$(156) = gpps2("capflow", "ts156", language$, "Step pressure too high - setting step pressure to equal maximum pressure")
    ts$(157) = gpps2("capflow", "ts157", language$, "Enter wait time (min)")
    ts$(158) = gpps2("capflow", "ts158", language$, "The program will acquire readings from")
    ts$(159) = gpps2("capflow", "ts159", language$, "to")
    ts$(160) = gpps2("capflow", "ts160", language$, "(Gauge)")
    ts$(161) = gpps2("capflow", "ts161", language$, "in")
    ts$(162) = gpps2("capflow", "ts162", language$, "increments, waiting")
    ts$(163) = gpps2("capflow", "ts163", language$, "minutes between each point.")
    ts$(164) = gpps2("capflow", "ts164", language$, "This is as far as you can go with the demo program")
    ts$(165) = gpps2("capflow", "ts165", language$, "Auto Test Demo")
    ts$(166) = gpps2("capflow", "ts166", language$, "Piston about To rise")
    ts$(167) = gpps2("capflow", "ts167", language$, "Leak Test")
    ts$(168) = gpps2("capflow", "ts168", language$, "Note: All pressures are absolute")
    ts$(169) = gpps2("capflow", "ts169", language$, "Rate(%/Hr)")
    ts$(170) = gpps2("capflow", "ts170", language$, "Raising pressure to")
    ts$(171) = gpps2("capflow", "ts171", language$, "Absolute")
    ts$(172) = gpps2("capflow", "ts172", language$, "Pressure at")
    ts$(173) = gpps2("capflow", "ts173", language$, "Waiting for")
    ts$(174) = gpps2("capflow", "ts174", language$, "passed")
    ts$(175) = gpps2("capflow", "ts175", language$, "failed")
    ts$(176) = gpps2("capflow", "ts176", language$, "The instrument")
    ts$(177) = gpps2("capflow", "ts177", language$, "the leak test")
    ts$(178) = gpps2("capflow", "ts178", language$, "over the range of")
    ts$(179) = gpps2("capflow", "ts179", language$, "differential")
    ts$(180) = gpps2("capflow", "ts180", language$, "Do you wish to see the collected data?")
    ts$(181) = gpps2("capflow", "ts181", language$, "Leak Test finished. Remove non-porous insert.")
    ts$(182) = gpps2("capflow", "ts182", language$, "Insert Sample")
    ts$(183) = gpps2("capflow", "ts183", language$, "Insert Samples in Chambers")
    ts$(184) = gpps2("capflow", "ts184", language$, "Insert Sample in Chamber")
    ts$(185) = gpps2("capflow", "ts185", language$, "seal chamber and prepare for automatic compression")
    ts$(186) = gpps2("capflow", "ts186", language$, "engage compression")
    ts$(187) = gpps2("capflow", "ts187", language$, "close cover and prepare for automatic clamping")
    ts$(188) = gpps2("capflow", "ts188", language$, "seal chamber")
    ts$(189) = gpps2("capflow", "ts189", language$, "Make sure fluid level is at bottom of sample, load sample, seal chamber, attach pressure tube.")
    ts$(190) = gpps2("capflow", "ts190", language$, "Press OK to start test")
    ts$(191) = gpps2("capflow", "ts191", language$, "Load sample with fluid on top")
    ts$(192) = gpps2("capflow", "ts192", language$, "attach the air pressure tube")
    ts$(193) = gpps2("capflow", "ts193", language$, "attach penetrometer tube")
    ts$(194) = gpps2("capflow", "ts194", language$, "Load saturated sample")
    ts$(195) = gpps2("capflow", "ts195", language$, "attach integrity tube")
    ts$(196) = gpps2("capflow", "ts196", language$, "Place empty fluid cup on sensor plate.")
    ts$(197) = gpps2("capflow", "ts197", language$, "Load Cell Calibration")
    ts$(198) = gpps2("capflow", "ts198", language$, "attach diff. pg tube")
    ts$(199) = gpps2("capflow", "ts199", language$, "Load and seal sample in liq. vapor sample chamber")
    ts$(200) = gpps2("capflow", "ts200", language$, "Load sample")
    ts$(201) = gpps2("capflow", "ts201", language$, "connect tube to microflow port on instrument")
    ts$(202) = gpps2("capflow", "ts202", language$, "Prefill sample-chamber with fluid.")
    ts$(203) = gpps2("capflow", "ts203", language$, "Completely fill sample chamber with fluid.")
    ts$(204) = gpps2("capflow", "ts204", language$, "attach hose(s) to top of chamber")
    ts$(205) = gpps2("capflow", "ts205", language$, "Make sure empty fluid cup is on sensor plate.")
    ts$(206) = gpps2("capflow", "ts206", language$, "Piston about to lower")
    ts$(207) = gpps2("capflow", "ts207", language$, "Close cover so that chamber may safely clamp")
    ts$(208) = gpps2("capflow", "ts208", language$, "Waiting for stable values")
    ts$(209) = gpps2("capflow", "ts209", language$, "Low flow")
    ts$(210) = gpps2("capflow", "ts210", language$, "High flow")
    ts$(211) = gpps2("capflow", "ts211", language$, "Warning: The low flow")
    ts$(212) = gpps2("capflow", "ts212", language$, "Warning: The high flow")
    ts$(213) = gpps2("capflow", "ts213", language$, "Warning: The pressure gauge")
    ts$(214) = gpps2("capflow", "ts214", language$, "Adjust penetrometer fill valve for a slow fill rate.")
    ts$(215) = gpps2("capflow", "ts215", language$, "Fluid level")
    ts$(216) = gpps2("capflow", "ts216", language$, "Fill until counts are between")
    ts$(217) = gpps2("capflow", "ts217", language$, "and")
    ts$(218) = gpps2("capflow", "ts218", language$, "Begin filling penetrometer")
    ts$(219) = gpps2("capflow", "ts219", language$, "Prefilled")
    ts$(220) = gpps2("capflow", "ts220", language$, "OK")
    ts$(221) = gpps2("capflow", "ts221", language$, "Is the penetrometer full?")
    ts$(222) = gpps2("capflow", "ts222", language$, "YES to continue, NO to try adding more.")
    ts$(223) = gpps2("capflow", "ts223", language$, "Test Setup")
    ts$(224) = gpps2("capflow", "ts224", language$, "If NOT, finish filling and press OK to continue.")
    ts$(225) = gpps2("capflow", "ts225", language$, "Error:  Your low pressure gauge was off scale - possible leak in valve - test aborted.")
    ts$(226) = gpps2("capflow", "ts226", language$, "Evacuating")
   ' ts$(227) = gpps2("capflow", "ts227", language$, "Torr")
    ts$(228) = gpps2("capflow", "ts228", language$, "please wait")
    ts$(229) = gpps2("capflow", "ts229", language$, "Pressure")
    ts$(230) = gpps2("capflow", "ts230", language$, "Valve 2")
    ts$(231) = gpps2("capflow", "ts231", language$, "counts")
    ts$(232) = gpps2("capflow", "ts232", language$, "open")
    ts$(233) = gpps2("capflow", "ts233", language$, "opening")
    ts$(234) = gpps2("capflow", "ts234", language$, "closing")
    ts$(235) = gpps2("capflow", "ts235", language$, "of")
    ts$(236) = gpps2("capflow", "ts236", language$, "Enter starting pressure")
    ts$(237) = gpps2("capflow", "ts237", language$, "Maximum pressure is")
    ts$(238) = gpps2("capflow", "ts238", language$, "Enter maximum pressure")
    ts$(239) = gpps2("capflow", "ts239", language$, "Maximum pressure can not be less than starting pressure")
    ts$(240) = gpps2("capflow", "ts240", language$, "Enter point step pressure")
    ts$(241) = gpps2("capflow", "ts241", language$, "Enter maximum wait between points (sec)")
    ts$(242) = gpps2("capflow", "ts242", language$, "Enter maximum number of points")
    ts$(243) = gpps2("capflow", "ts243", language$, "Height")
    ts$(244) = gpps2("capflow", "ts244", language$, "cm")
    ts$(245) = gpps2("capflow", "ts245", language$, "sec.")
    ts$(246) = gpps2("capflow", "ts246", language$, "Delay time")
    ts$(247) = gpps2("capflow", "ts247", language$, "Test failed - pressure decay was")
    ts$(248) = gpps2("capflow", "ts248", language$, "Test passed - pressure decay was")
    ts$(249) = gpps2("capflow", "ts249", language$, "You are using an older style lohm table.  You may get more accuracy if you re-run the lohm table calibration.")
    ts$(250) = gpps2("capflow", "ts250", language$, "Error reading lohm table - check number of entries!")
    ts$(251) = gpps2("capflow", "ts251", language$, "Lohmtable not found - perform lohm calibration before running tests!")
    ts$(252) = gpps2("capflow", "ts252", language$, "Unknown Error - lohm calibration MUST be run before running any tests!")
    ts$(253) = gpps2("capflow", "ts253", language$, "Refilling penetrometer")
    ts$(254) = gpps2("capflow", "ts254", language$, "Penetrometer should now be full.")
    ts$(255) = gpps2("capflow", "ts255", language$, "You cannot re-zero the flow meters during a test.")
    ts$(256) = gpps2("capflow", "ts256", language$, "Re-Zero")
    ts$(257) = gpps2("capflow", "ts257", language$, "You cannot re-zero the flow meters if Valve 2 is open, Valve 3 is closed, or Valve 1 is open.")
    ts$(258) = gpps2("capflow", "ts258", language$, "Continue with re-zero of flow meters.")
    ts$(259) = gpps2("capflow", "ts259", language$, "Error: Can't call serial port on version < 6")
    ts$(260) = gpps2("capflow", "ts260", language$, "Communications Error! Channel")
    ts$(261) = gpps2("capflow", "ts261", language$, "Not getting a response from the instrument.")
    ts$(262) = gpps2("capflow", "ts262", language$, "Please check communications cable and restart.")
    ts$(263) = gpps2("capflow", "ts263", language$, "Porometer Control")
    ts$(264) = gpps2("capflow", "ts264", language$, "Communications error: No response from read command")
    ts$(265) = gpps2("capflow", "ts265", language$, "Communications Error!")
    ts$(266) = gpps2("capflow", "ts266", language$, "Waiting for temperature to reach")
    ts$(267) = gpps2("capflow", "ts267", language$, "Current temperature")
    ts$(268) = gpps2("capflow", "ts268", language$, "Do you want to start the test at the current temperature?  ('No' will cancel the test)")
    ts$(269) = gpps2("capflow", "ts269", language$, "Height of Liquid")
    ts$(270) = gpps2("capflow", "ts270", language$, "phase")
    ts$(271) = gpps2("capflow", "ts271", language$, "Possible through flow - checking")
    ts$(272) = gpps2("capflow", "ts272", language$, "Possible through flow - found")
    ts$(273) = gpps2("capflow", "ts273", language$, "Ave. Flow In")
    ts$(274) = gpps2("capflow", "ts274", language$, "P Change")
    ts$(275) = gpps2("capflow", "ts275", language$, "Factor")
    ts$(276) = gpps2("capflow", "ts276", language$, "Est. Thru Flow")
    ts$(277) = gpps2("capflow", "ts277", language$, "diam.")
    ts$(278) = gpps2("capflow", "ts278", language$, "microns")
    ts$(279) = gpps2("capflow", "ts279", language$, "Test aborting because safety cover has been opened")
    ts$(280) = gpps2("capflow", "ts280", language$, "Compressing")
    ts$(281) = gpps2("capflow", "ts281", language$, "Seconds Left")
    ts$(282) = gpps2("capflow", "ts282", language$, "Decompressing")
    ts$(283) = gpps2("capflow", "ts283", language$, "Test aborted")
    ts$(284) = gpps2("capflow", "ts284", language$, "Compression Cycles Completed")
    ts$(285) = gpps2("capflow", "ts285", language$, "PTarget")
    ts$(286) = gpps2("capflow", "ts286", language$, "Initializing Auto Test")
    ts$(287) = gpps2("capflow", "ts287", language$, "Auto Test Failed - delta_p must be > 0")
    ts$(288) = gpps2("capflow", "ts288", language$, "Auto Test Failed - max_p must be > 0")
    ts$(289) = gpps2("capflow", "ts289", language$, "Auto Test Failed - min_p must be > 0")
    ts$(290) = gpps2("capflow", "ts290", language$, "Auto Test Failed - delta_t must be > 0")
    ts$(291) = gpps2("capflow", "ts291", language$, "Auto Test Failed - p_mult must be >= 1")
    ts$(292) = gpps2("capflow", "ts292", language$, "Auto Test Failed - min_deltap must be > 0")
    ts$(293) = gpps2("capflow", "ts293", language$, "Auto Test Failed - start_p must be >= 0")
    ts$(294) = gpps2("capflow", "ts294", language$, "Auto Test Failed - output file can not be opened")
    ts$(295) = gpps2("capflow", "ts295", language$, "Initializing Valves")
    ts$(296) = gpps2("capflow", "ts296", language$, "Evacuating - time left")
    ts$(297) = gpps2("capflow", "ts297", language$, "Evacuation finished")
    ts$(298) = gpps2("capflow", "ts298", language$, "Reaching starting pressure")
    ts$(299) = gpps2("capflow", "ts299", language$, "Reaching next pressure")
    ts$(300) = gpps2("capflow", "ts300", language$, "Waiting for pressure to stabilize")
    ts$(301) = gpps2("capflow", "ts301", language$, "Retrying to reach next pressure")
    ts$(302) = gpps2("capflow", "ts302", language$, "Pressure Reached - allowing gas to flow through sample")
    ts$(303) = gpps2("capflow", "ts303", language$, "Flow Recorded - equalizing pressure")
    ts$(304) = gpps2("capflow", "ts304", language$, "Auto Test Completed Normally")
    ts$(305) = gpps2("capflow", "ts305", language$, "Flow Rate")
    ts$(306) = gpps2("capflow", "ts306", language$, "Integrity Flow Rate")
    ts$(307) = gpps2("capflow", "ts307", language$, "Low")
    ts$(308) = gpps2("capflow", "ts308", language$, "High")
    ts$(309) = gpps2("capflow", "ts309", language$, "Penetrometer")
    ts$(310) = gpps2("capflow", "ts310", language$, "cm of H2O")
    ts$(311) = gpps2("capflow", "ts311", language$, "Diff. Press.")
    ts$(312) = gpps2("capflow", "ts312", language$, "Fluid Sensor")
    ts$(313) = gpps2("capflow", "ts313", language$, "Temperature")
    ts$(314) = gpps2("capflow", "ts314", language$, "Auxiliary Input")
    ts$(315) = gpps2("capflow", "ts315", language$, "Regulator")
    ts$(316) = gpps2("capflow", "ts316", language$, "Regulator zeroed due to overpressure error")
    ts$(317) = gpps2("capflow", "ts317", language$, "Current test was aborted.  Do you want to continue with the next chamber?")
    ts$(318) = gpps2("capflow", "ts318", language$, "The program has detected flows during this test that are within 75% of the machine's full flow potential.")
    ts$(319) = gpps2("capflow", "ts319", language$, "You may wish to lessen the sample cross section to reduce the flow and rerun.")
    ts$(320) = gpps2("capflow", "ts320", language$, "Flow Limit Warning")
    ts$(321) = gpps2("capflow", "ts321", language$, "Current Test Status")
    ts$(322) = gpps2("capflow", "ts322", language$, "Error: Can't find dry parameter file - using defaults")
    ts$(323) = gpps2("capflow", "ts323", language$, "Error: Can't find wet parameter file - using defaults")
    ts$(324) = gpps2("capflow", "ts324", language$, "Enter testing temperature")
    ts$(325) = gpps2("capflow", "ts325", language$, "Wet Curve")
    ts$(326) = gpps2("capflow", "ts326", language$, "Dry Curve")
    ts$(327) = gpps2("capflow", "ts327", language$, "Pressure Hold Test")
    ts$(328) = gpps2("capflow", "ts328", language$, "Liq. Vapor Permeability")
    ts$(329) = gpps2("capflow", "ts329", language$, "Microflow Analysis")
    ts$(330) = gpps2("capflow", "ts330", language$, "Minimum pressure greater than maximum calibrated pressure for regulator.")
    ts$(331) = gpps2("capflow", "ts331", language$, "Compression pressure greater than maximum calibrated pressure for regulator.")
    ts$(332) = gpps2("capflow", "ts332", language$, "The compression regulator will be left at its current position")
    ts$(333) = gpps2("capflow", "ts333", language$, "Rate of pressure increase")
    ts$(334) = gpps2("capflow", "ts334", language$, "Error in RS232 system.  Return code was")
    ts$(335) = gpps2("capflow", "ts335", language$, "Control RS232 System")
    ts$(336) = gpps2("capflow", "ts336", language$, "Initializing low flow calibration")
    ts$(337) = gpps2("capflow", "ts337", language$, "Initializing Valve 2")
    ts$(338) = gpps2("capflow", "ts338", language$, "Finding proper regulator setting")
    ts$(339) = gpps2("capflow", "ts339", language$, "Waiting for lowest flow")
    ts$(340) = gpps2("capflow", "ts340", language$, "Calibrating flow meters")
    ts$(341) = gpps2("capflow", "ts341", language$, "Controller")
    ts$(342) = gpps2("capflow", "ts342", language$, "Preparing for calibration with regulator 2 - zeroing regulator 1")
    ts$(343) = gpps2("capflow", "ts343", language$, "Setting first flow")
    ts$(344) = gpps2("capflow", "ts344", language$, "Waiting for system to settle")
    ts$(345) = gpps2("capflow", "ts345", language$, "Setting regulator to high pressure")
    ts$(346) = gpps2("capflow", "ts346", language$, "The air compressor seems to be disconnected.")
    ts$(347) = gpps2("capflow", "ts347", language$, "Please connect it.")
    ts$(348) = gpps2("capflow", "ts348", language$, "Calibration")
    ts$(349) = gpps2("capflow", "ts349", language$, "Position")
    ts$(350) = gpps2("capflow", "ts350", language$, "Finished")
    ts$(351) = gpps2("capflow", "ts351", language$, "Problem renaming calibration file - your new calibration is in the capcal.tmp file.  Rename this to capcal.d8a to set it to the active calibration.")
    ts$(352) = gpps2("capflow", "ts352", language$, "Still working")
    ts$(353) = gpps2("capflow", "ts353", language$, "Disconnect the penetrometer from the sample chamber and prepare for release of the compression piston")
    ts$(354) = gpps2("capflow", "ts354", language$, "Open the sample chamber and allow all the liquid to drain out")
    ts$(355) = gpps2("capflow", "ts355", language$, "Disconnect the penetrometer from the sample chamber and open the sample chamber to allow the fluid to drain out.")
    ts$(356) = gpps2("capflow", "ts356", language$, "DO NOT CONTINUE unless the penetrometer has been disconnected, the sample has been removed from the chamber, and the water drained out!")
    ts$(357) = gpps2("capflow", "ts357", language$, "Warning!")
    ts$(358) = gpps2("capflow", "ts358", language$, "When you press 'OK', there may be a burst of air through the sample chamber!  Cover the chamber with a cloth BEFORE pressing 'OK'!")
    ts$(359) = gpps2("capflow", "ts359", language$, "All done. Remove sample.")
    ts$(360) = gpps2("capflow", "ts360", language$, "Something was wrong with the test.  Data is invalid.")
    ts$(361) = gpps2("capflow", "ts361", language$, "Test Error")
    ts$(362) = gpps2("capflow", "ts362", language$, "The program automatically turned the test because it was calculated that")
    ts$(363) = gpps2("capflow", "ts363", language$, "the pressure drop across the sample was within")
    ts$(364) = gpps2("capflow", "ts364", language$, "The pressure drop across an empty sample chamber")
    ts$(365) = gpps2("capflow", "ts365", language$, "You must reduce the sample area to reduce flow and rerun for more accurate results.")
    ts$(366) = gpps2("capflow", "ts366", language$, "Lohm Correction Limit Warning")
    ts$(367) = gpps2("capflow", "ts367", language$, "The program has detected that the pressure drop across the sample was within 80% of")
    ts$(368) = gpps2("capflow", "ts368", language$, "You may wish to lessen the sample area to reduce the flow and rerun if possible.")
    ts$(369) = gpps2("capflow", "ts369", language$, "Wet Up")
    ts$(370) = gpps2("capflow", "ts370", language$, "Dry Up")
    ts$(371) = gpps2("capflow", "ts371", language$, "Dry Down")
    ts$(372) = gpps2("capflow", "ts372", language$, "Calc. Dry")
    ts$(373) = gpps2("capflow", "ts373", language$, "Linear")
    ts$(374) = gpps2("capflow", "ts374", language$, "Stop Dry at Bubble Point")
    ts$(375) = gpps2("capflow", "ts375", language$, "with fluid sensing")
    ts$(376) = gpps2("capflow", "ts376", language$, "No wait at dry")
    ts$(377) = gpps2("capflow", "ts377", language$, "Darcy")
    ts$(378) = gpps2("capflow", "ts378", language$, "Square Root")
    ts$(379) = gpps2("capflow", "ts379", language$, "microflow")
    ts$(380) = gpps2("capflow", "ts380", language$, "Capillary Flow Porometry")
    ts$(381) = gpps2("capflow", "ts381", language$, "Standard Mode")
    ts$(382) = gpps2("capflow", "ts382", language$, "Manual Mode")
    ts$(383) = gpps2("capflow", "ts383", language$, "Integrity Test on Saturated Sample")
    ts$(384) = gpps2("capflow", "ts384", language$, "Gas Permeability")
    ts$(385) = gpps2("capflow", "ts385", language$, "Envelope Surface Area Analysis")
    ts$(386) = gpps2("capflow", "ts386", language$, "Liquid Permeability")
    ts$(387) = gpps2("capflow", "ts387", language$, "Ambient Pressure")
    ts$(388) = gpps2("capflow", "ts388", language$, "Elevated Pressure")
    ts$(389) = gpps2("capflow", "ts389", language$, "Liq. Vapor Permeability")
    ts$(390) = gpps2("capflow", "ts390", language$, "Microflow Pressure vs. Time Analysis")
    ts$(391) = gpps2("capflow", "ts391", language$, "&Resume")
    ts$(392) = gpps2("capflow", "ts392", language$, "&Pause")
    ts$(393) = gpps2("capflow", "ts393", language$, "Enter number of iterations for Valve 2 test")
    ts$(394) = gpps2("capflow", "ts394", language$, "Valve 2 testing cancelled")
    ts$(395) = gpps2("capflow", "ts395", language$, "Valve 2 will open and close")
    ts$(396) = gpps2("capflow", "ts396", language$, "times")
    ts$(397) = gpps2("capflow", "ts397", language$, "Press 'A' to abort test.")
    ts$(398) = gpps2("capflow", "ts398", language$, "Valve 2 Test")
    ts$(399) = gpps2("capflow", "ts399", language$, "Valve 2 failed to open completely and timed-out.")
    ts$(400) = gpps2("capflow", "ts400", language$, "Please check.")
    ts$(401) = gpps2("capflow", "ts401", language$, "Valve 2 failed to close completely and timed-out.")
    ts$(402) = gpps2("capflow", "ts402", language$, "The compression regulator may have a problem with the low limit setting")
    ts$(403) = gpps2("capflow", "ts403", language$, "The motorized regulator may have a problem with the low limit setting")
    ts$(404) = gpps2("capflow", "ts404", language$, "Couldn't calculate final result due to incorrect data file type")
    ts$(405) = gpps2("capflow", "ts405", language$, "Couldn't calculate final result due to invalid diameter")
    ts$(406) = gpps2("capflow", "ts406", language$, "Couldn't calculate final result due to 0 atmospheric pressure")
    ts$(407) = gpps2("capflow", "ts407", language$, "Couldn't calculate final result due to invalid viscosity value")
    ts$(408) = gpps2("capflow", "ts408", language$, "Couldn't calculate final result because there are no valid data points")
    ts$(409) = gpps2("capflow", "ts409", language$, "Average Darcy Permeability Constant")
    ts$(410) = gpps2("capflow", "ts410", language$, "Couldn't calculate Mean Flow Pressure due to incorrect data file type")
    ts$(411) = gpps2("capflow", "ts411", language$, "Couldn't calculate Mean Flow Pressure because there are not enough dry points")
    ts$(412) = gpps2("capflow", "ts412", language$, "Couldn't calculate Mean Flow Pressure because there are not enough wet points")
    ts$(413) = gpps2("capflow", "ts413", language$, "Couldn't calculate Mean Flow Pressure because there are not enough wet points after removing duplicates and backwards-going points")
    ts$(414) = gpps2("capflow", "ts414", language$, "Couldn't calculate Mean Flow Pressure because there are not enough dry points after removing duplicates and backwards going points")
    ts$(415) = gpps2("capflow", "ts415", language$, "Couldn't calculate Mean Flow Pressure because there is not enough wet flow to reach 1/2 dry flow")
    ts$(416) = gpps2("capflow", "ts416", language$, "Couldn't calculate Mean Flow Pressure because the first wet point is too high flow")
    ts$(417) = gpps2("capflow", "ts417", language$, "Couldn't calculate Mean Flow Pressure due to an intersection calculation problem")
    ts$(418) = gpps2("capflow", "ts418", language$, "Warning: The MFP calculation had a problem finding the proper wet curve pair - retrying")
    ts$(419) = gpps2("capflow", "ts419", language$, "Couldn't calculate Mean Flow Pressure due to a dry pressure problem")
    ts$(420) = gpps2("capflow", "ts420", language$, "Mean Flow Pressure")
    ts$(421) = gpps2("capflow", "ts421", language$, "Couldn't calculate Mean Flow Pressure due to wet pressure problem")
    ts$(422) = gpps2("capflow", "ts422", language$, "There was an error saving your data file to the location you specified.  Please choose a valid destination for your data file.")
    ts$(423) = gpps2("capflow", "ts423", language$, "Output Data File")
    ts$(424) = gpps2("capflow", "ts424", language$, "You have not selected an output file location.  The data from the last test is located in the same directory as the CAPWIN.EXE program, with the name LASTDATA.CFT.  This file will only be valid until the next test is run.")
    ts$(425) = gpps2("capflow", "ts425", language$, "Error Log File")
    ts$(426) = gpps2("capflow", "ts426", language$, "Error in renaming file. Try another.")
    'ts$(427) = gpps2("capflow", "ts427", language$, "in.")
    'ts$(428) = gpps2("capflow", "ts428", language$, "mm")
    'ts$(429) = gpps2("capflow", "ts429", language$, "g")
    'ts$(430) = gpps2("capflow", "ts430", language$, "lb")
    'ts$(431) = gpps2("capflow", "ts431", language$, "\c\m")
    ts$(432) = gpps2("capflow", "ts432", language$, "\c\o\u\n\t\s")
    'ts$(433) = gpps2("capflow", "ts433", language$, "\c\c")
    ts$(434) = gpps2("capflow", "ts434", language$, "Warning: The Low Pressure")
    ts$(435) = gpps2("capflow", "ts435", language$, "Looping CFP Demo")
    ts$(436) = gpps2("capflow", "ts436", language$, "Looping BP Demo")
    ts$(437) = gpps2("capflow", "ts437", language$, "Looping GP Demo")
    ' Following strings added in v6.71.26
    ts$(438) = gpps2("capflow", "ts438", language$, "Pick a place to save this new lohm table.")
    ts$(439) = gpps2("capflow", "ts439", language$, "Save New Lohm Table")
    ts$(440) = gpps2("capflow", "ts440", language$, "WARNING:  New lohm table will be overwritten when a new group is selected")
    ts$(441) = gpps2("capflow", "ts441", language$, "or the user closes the program. Backup the file manually to prevent this.")
    ts$(442) = gpps2("capflow", "ts442", language$, "Do you really want to abort?")
    ts$(443) = gpps2("capflow", "ts443", language$, "Waiting for microflow pressure to settle")
    ts$(444) = gpps2("capflow", "ts444", language$, "Venting and retrying - failure after")
    ts$(445) = gpps2("capflow", "ts445", language$, "seconds")
    ts$(446) = gpps2("capflow", "ts446", language$, "Pressure settled after")
    ts$(447) = gpps2("capflow", "ts447", language$, "Venting Slowly - please wait")
    ts$(448) = gpps2("capflow", "ts448", language$, "The starting pressure is too high for the current compression pressure setting")
    ts$(449) = gpps2("capflow", "ts449", language$, "Venting system - please wait")
    ts$(450) = gpps2("capflow", "ts450", language$, "Test failed. Bubble point was outside the specified range.")
    ts$(451) = gpps2("capflow", "ts451", language$, "Test will now abort.")
    ts$(452) = gpps2("capflow", "ts452", language$, "Fluid at sample")
    ts$(453) = gpps2("capflow", "ts453", language$, "Recirculating fluid")
    ts$(454) = gpps2("capflow", "ts454", language$, "Average Flow Rate")
    ts$(455) = gpps2("capflow", "ts455", language$, "Chamber Status: Open")
    ts$(456) = gpps2("capflow", "ts456", language$, "Chamber Status: Closed")
    ts$(457) = gpps2("capflow", "ts457", language$, "Close door and try again")
    ts$(458) = gpps2("capflow", "ts458", language$, "Flow Status: All Stopped")
    ts$(459) = gpps2("capflow", "ts459", language$, "Flow Status: Partial Recirculation")
    ts$(460) = gpps2("capflow", "ts460", language$, "Flow Status: Full Recirculation")
    ts$(461) = gpps2("capflow", "ts461", language$, "Penetrometer Status")
    ts$(462) = gpps2("capflow", "ts462", language$, "Error: No communication with the external temperature controller.  No temperature data will be stored for this test.")
    ts$(463) = gpps2("capflow", "ts463", language$, "Do you want to open the door now?")
    ts$(464) = gpps2("capflow", "ts464", language$, "Install sample, close chamber, and connect vacuum tubing with valve turned off in preparation for purge")
    ts$(465) = gpps2("capflow", "ts465", language$, "Enter number of purge cycles")
    ts$(466) = gpps2("capflow", "ts466", language$, "Status of Purge System")
    ts$(467) = gpps2("capflow", "ts467", language$, "Compressing sample chamber")
    ts$(468) = gpps2("capflow", "ts468", language$, "Venting")
    ts$(469) = gpps2("capflow", "ts469", language$, "Waiting for Valve 2 to close")
    ts$(470) = gpps2("capflow", "ts470", language$, "Remove vacuum tubing")
    ts$(471) = gpps2("capflow", "ts471", language$, "Flow gas")
    ts$(472) = gpps2("capflow", "ts472", language$, "Flowing for 10 seconds")
    ts$(473) = gpps2("capflow", "ts473", language$, "Evacuating system")
    ts$(474) = gpps2("capflow", "ts474", language$, "Setup")
    ts$(475) = gpps2("capflow", "ts475", language$, "Open vacuum valve")
    ts$(476) = gpps2("capflow", "ts476", language$, "Evacuating for 30 seconds")
    ts$(477) = gpps2("capflow", "ts477", language$, "Close vacuum valve")
    ts$(478) = gpps2("capflow", "ts478", language$, "Open Door Now")
    ts$(479) = gpps2("capflow", "ts479", language$, "Warning message at 75%")

'    language$ = tempname$ directly follows inserted code
' **********
' BEGIN ts$ line inserted by search for TIM RICHARDS Thursday 6/3/04
' refer to ts$(310) = gpps2("capflow", "ts310", language$, "cm of H2O")
'
ts$(480) = gpps2("BalanceNotPenet", "ts480", language$, "gm of H2O")
ts$(481) = gpps2("BalanceNotPenet", "ts481", language$, "Mettler Balance")
ts$(482) = gpps2("BalanceNotPenet", "ts482", language$, "Mettler Balance")
'ts$(483) = ' "Tare" removed ---TAR 040728
ts$(484) = gpps2("BalanceNotPenet", "ts484", language$, "gm") 'TAR 040615
ts$(485) = gpps2("BalanceNotPenet", "ts485", language$, "cm") 'TAR 040615
ts$(486) = gpps2("BalanceNotPenet", "ts486", language$, "Mass") 'TAR 040615
'
' END ts$ code inserted by Tim Richards 6/3/04
' **********
ts$(487) = gpps2("capflow", "ts487", language$, "Hydrohead Tester.")
ts$(488) = gpps2("capflow", "ts488", language$, "Microflow Porometer.")
ts$(489) = gpps2("capflow", "ts489", language$, "Hydrohead Tester Data File")
ts$(490) = gpps2("capflow", "ts490", language$, "Start Test")
ts$(491) = gpps2("capflow", "ts491", language$, "Cancel Test")

ts$(492) = gpps2("BalanceNotPenet", "ts492", language$, "Reached maximum flow set point. Stopping Test.")
ts$(493) = gpps2("BalanceNotPenet", "ts493", language$, "Liquid Permeametry")
ts$(483) = gpps2("BalanceNotPenet", "ts483", language$, "Enter settling time once target pressure is attained") 'TAR 040804
ts$(494) = gpps2("capflow", "ts494", language$, "Permeability results for sample ID")
ts$(495) = gpps2("capflow", "ts495", language$, "Test")
ts$(496) = gpps2("capflow", "ts496", language$, "Average")
ts$(497) = gpps2("capflow", "ts497", language$, "Choose pressure list")
ts$(498) = gpps2("capflow", "ts498", language$, "Thickness") '6.71.123.07
ts$(499) = gpps2("capflow", "ts499", language$, "Target Thickness is") '6.71.123.07
ts$(500) = gpps2("capflow", "ts500", language$, "Driving Piston to Target Thickness") '6.71.123.07
ts$(501) = gpps2("capflow", "ts501", language$, "Slurry Tube Level: ") '6.71.123.07
ts$(502) = gpps2("capflow", "ts502", language$, "Slurry Tube Pressure (P6): ") '6.71.123.07
ts$(503) = gpps2("capflow", "ts503", language$, "Build Cake By Pressure") '6.71.123.12
ts$(504) = gpps2("capflow", "ts504", language$, "Build Cake By Flow") '6.71.123.12
ts$(505) = gpps2("capflow", "ts505", language$, "Slurry Tube Wash Cycle") '6.71.123.12
ts$(506) = gpps2("capflow", "ts506", language$, ": Endpoint = ") '6.71.123.20
ts$(507) = gpps2("capflow", "ts507", language$, "Slurry Tube Pressure = ") '6.71.123.20
ts$(508) = gpps2("capflow", "ts508", language$, "Estimated Total ") '6.71.123.20
ts$(509) = gpps2("capflow", "ts509", language$, " cc of ") '6.71.123.20
ts$(510) = gpps2("capflow", "ts510", language$, " cc tank") '6.71.123.20
ts$(511) = gpps2("capflow", "ts511", language$, "Filling Slurry Tube: Level = ") '6.71.123.20
ts$(512) = gpps2("capflow", "ts512", language$, "Draining Slurry Tube through sample") '6.71.123.20
ts$(513) = gpps2("capflow", "ts513", language$, "Ensuring system is not under pressure.") '7.73.012.02

ts$(516) = gpps2("capflow", "ts516", language$, "Gurley Method") '6.71.123.30
ts$(517) = gpps2("capflow", "ts517", language$, "High Pressure Gurley") '6.71.123.30
ts$(518) = gpps2("capflow", "ts518", language$, "Sheffield Method") '6.71.123.30
ts$(519) = gpps2("capflow", "ts519", language$, "Resin Test") '6.72.018

ts$(520) = gpps2("capflow", "ts520", language$, "MV1")
ts$(521) = gpps2("capflow", "ts521", language$, "MV2")
ts$(522) = gpps2("capflow", "ts522", language$, "MV3")

ts$(523) = gpps2("capflow", "ts523", language$, "Mullen")
ts$(524) = gpps2("capflow", "ts524", language$, "3 Stage Test")

ts$(525) = gpps2("capflow", "ts525", language$, "Eject Press.")

ts$(526) = gpps2("capflow", "ts526", language$, "Burst")
ts$(527) = gpps2("capflow", "ts527", language$, "Burst Tester.")
ts$(528) = gpps2("capflow", "ts528", language$, "Burst Tester Data File")



    language$ = tempname$           ' Restore old name
    
End Sub
Function get_piston_valve_number() As Integer
' return best piston valve number possible
' if only one possible piston valve, return normal value
If (chambers <= 1) Or (number_of_pistons <= 1) Or (current_unit% > 3) Then
    get_piston_valve_number = 15
    Exit Function
End If
If (current_unit% = 2) And (number_of_pistons >= 2) Then
    get_piston_valve_number = piston_valve(2)
    Exit Function
End If
If (current_unit% = 3) And (number_of_pistons >= 3) Then
    get_piston_valve_number = piston_valve(3)
    Exit Function
End If
' if current_unit%=1 we may actually be on a different piston if 1 is not selected
If (selchamber(1)) Then
    get_piston_valve_number = 15
    Exit Function
End If
If (chambers > 1) And (selchamber(2)) And (number_of_pistons >= 2) Then
    get_piston_valve_number = piston_valve(2)
    Exit Function
End If
If (chambers > 2) And (selchamber(3)) And (number_of_pistons >= 3) Then
    get_piston_valve_number = piston_valve(3)
    Exit Function
End If
get_piston_valve_number = 15
End Function

Sub move_piston_valve(oorc$)
' move the best piston valve we can
Move_Valve get_piston_valve_number() - 1, oorc$
End Sub

Function piston_vpos() As Integer
' return best piston valve position possible
piston_vpos = Vpos(get_piston_valve_number())
End Function

Function shortHandIfelse(truth As Boolean, value1, value2)

If truth Then
    shortHandIfelse = value1
Else
    shortHandIfelse = value2
End If

End Function

' Gets the count value for a pressure from the regulator calibration file.
' May extrapolate the value linearly for values unspecified in the file.
' Returns -1 if extrapolation is not allowed and the value is unrepresented.
' There is already "regpos_from_p" but this is simplier
' - Mix
Function GetRegulatorCalValue(Pressure As Single, allowExtrapolate As Boolean) As Single

    Dim i As Integer
    Dim p1, p2, c1, c2, temp As Single

    ' First, check to see if we have the value explicity
    For i = 1 To reg_table_size%(0)
        If reg_table_pres!(i) = Pressure Then
            GetRegulatorCalValue = reg_table_pres!(i)
            Exit Function
        End If
    Next i
    
    ' Failed to find an exact value and we're not allowed to extrapolate
    If Not allowExtrapolate Then
        GetRegulatorCalValue = -1
        Exit Function
    End If
    
    ' Extrapolate the value linearly
    p1 = reg_table_pres!(reg_table_size%(0) / 2)
    c1 = reg_table_pos(reg_table_size%(0) / 2)
    p2 = reg_table_pres!(reg_table_size%(0))
    c2 = reg_table_pos(reg_table_size%(0))
    
    temp = Pressure - p1
    temp = temp * ((c2 - c1) / (p2 - p1))
    temp = temp + c1
    
    GetRegulatorCalValue = temp

End Function

' Sets the regulator counts to the specified value - Mix
Sub Set_Regulator(ByVal channel As Integer, ByVal counts As Integer)
    ' Zero counts first
    Send_RS232 ("Z" + CStr(channel))
    
    ' Add counts in chunks of 255
    Do While counts > 255
        Send_RS232b "U" + CStr(channel), 255
        counts = counts - 255
    Loop
    
    ' Add remaining counts
    If counts > 0 Then
        Send_RS232b "U" + CStr(channel), CByte(counts)
    End If
End Sub

' Takes a reading from an Athena - Mix
Function Read_Athena(ByVal channel As Integer) As Single

    Read_Athena = RSEcho("AT" + CStr(channel), 3) / 10#

End Function

' Sets an Athena to a target temperature - Mix
Sub Set_Athena(ByVal channel As Integer, ByVal temperature As Single)
    
    Dim value As Integer
    value = temperature * 10#
    
    Send_RS232i "AS" + CStr(channel), value
    
    ' Keep track of our current target temperature
    If channel = Athena1Channel And Not temperature = Athena1Target Then
        Athena1Target = temperature
        WPPS "Capstuff", "Athena1Target", CStr(temperature), CSFile$
    End If
    If channel = Athena2Channel And Not temperature = Athena2Target Then
        Athena2Target = temperature
        WPPS "Capstuff", "Athena2Target", CStr(temperature), CSFile$
    End If
    
End Sub

' Waits for the athena to reach temperature.
' Should only be executed during a test.
' Does not set the temperature target itself.
' - Mix
Sub WaitForAthenaTemp(ByVal channel As Integer, ByVal temperature As Single)

    Dim currentTemp As Single
    Dim tempPasses As Integer
    Dim units As String
    Dim athenaNumber As String
    Dim timeout As String
    
    ' Initialize some strings
    If channel = Athena1Channel Then
        units = Athena1Units
        athenaNumber = " 1"
    ElseIf channel = Athena2Channel Then
        units = Athena2Units
        athenaNumber = " 2"
    Else
        units = "F"
        athenaNumber = ""
    End If

    ' Report what we're up to
    progress.Line25.Caption = "Waiting for temp. of " + CStr(temperature) + " " + units + " on Athena" + athenaNumber

WaitForTemp:
    ' Get temperature first time
    currentTemp = Read_Athena(channel)
    If currentTemp >= temperature Then Exit Sub
    
    ' Wait a number of times proportional to the temperature gap
    tempPasses = (temperature - currentTemp) * 60
    
    While currentTemp < temperature And Not Aborted And tempPasses > 0
        ' Update what we're up to
        progress.Line25.Caption = "Waiting for temperature of " + CStr(temperature) + " " + units
        progress.Line26.Caption = " on Athena" + athenaNumber + ", low by " + CStr(temperature - currentTemp) + " " + units
        
        ' Wait
        waitseconds 1
        tryhold
        DoEvents
        
        ' Read the next temperature
        currentTemp = Read_Athena(channel)
        tempPasses = tempPasses - 1
    Wend
    
    ' Handle timeout
    If tempPasses <= 0 And currentTemp < temperature Then
        timeout = MsgBox("The temperature could not reach target. Try again?", vbYesNo, "Temperature Timeout")
        
        If timeout = vbYes Then GoTo WaitForTemp
    End If
    
    progress.Line25.Caption = ""
    progress.Line26.Caption = ""

End Sub

' Maths the counts into a reading - Mix
Function CountsToReading(ByVal counts As Long, _
    ByVal MinRead As Single, ByVal MaxRead As Single, _
    Optional ByVal MinCounts As Long = 2000, Optional ByVal MaxCounts As Long = 62000) As Single
    
    CountsToReading = ((CSng(counts - MinCounts) / CSng(MaxCounts - MinCounts)) * (MaxRead - MinRead)) + MinRead
End Function

' Maths the counts into a reading according to a ReadingMath thing - Mix
Function CountsToReadingByRM(ByVal counts As Long, rm As ReadingMath)
    CountsToReadingByRM = CountsToReading(counts, rm.MinRead, rm.MaxRead, rm.MinCounts, rm.MaxCounts)
End Function

Sub ParseReadingMath()

    Dim Ret$
    Dim ReadingMathInput() As String
    Dim i, POS As Integer
    Dim minC, maxC As Long
    Dim minR, maxR As Single
    Dim position As String
    Dim rm As ReadingMath

    ' Get all of the P postions
    For i = 1 To 21
    
        On Error GoTo NextReadMathVal
        Ret$ = String$(255, " ")
    
        ' Create the position reference
        ' First 8 are P positions
        If i < 9 Then position = "P" + CStr(i)
        ' Next 8 are F positions
        If i > 8 And i < 17 Then position = "F" + CStr(i - 8)
        ' Next 4 are MV positions
        If i > 16 And i < 21 Then position = "POS" + CStr(i - 16)
        ' Last is penetrometer
        If i > 20 Then position = "PEN"
    
        GPPS "Capstuff", "Range" + position, "", Ret$, 255, CSFile$
        Ret$ = Trim$(Ret$)
        ReadingMathInput() = split(Ret$, ",")
        POS = GetPosByName(position)
        
        ' For two values
        If UBound(ReadingMathInput) = 1 Then
            ' Parse the reading values
            minR = val(ReadingMathInput(0))
            maxR = val(ReadingMathInput(1))
            
            ' Make the ReadingMath thing
            With ReadingMaths(POS)
                .OverrideActive = True
                .MaxRead = maxR
                .MinRead = minR
                .MinCounts = 2000
                .MaxCounts = 62000
            End With
        
        ' For four values
        ElseIf UBound(ReadingMathInput) = 3 Then
            ' Parse the reading values
            minR = val(ReadingMathInput(0))
            maxR = val(ReadingMathInput(1))
            
            ' Parse the count values
            minC = val(ReadingMathInput(2))
            maxC = val(ReadingMathInput(3))
            
            ' Make the ReadingMath thing
            With ReadingMaths(POS)
                .OverrideActive = True
                .MinRead = minR
                .MaxRead = maxR
                .MinCounts = minC
                .MaxCounts = maxC
            End With
            
        ' Empty or invalid values
        'Else
        '    ReadingMaths(POS) = MakeInactiveRM
        End If
        
        ' We also have to alter high readings for that board position
        If POS = 1 Or POS = 13 Or POS = 29 Or POS = 35 Or POS = 37 _
           Or POS = 41 Or POS = 3 Or POS = 11 Or POS = 5 Or POS = 9 _
           Or POS = 39 Then _
           ReadingMaths(POS - 1) = ReadingMaths(POS)
        
NextReadMathVal:
    Next i
    
End Sub

' Re-ranges P2 so that the P2 range agrees with the current P1 range.
' All it does is shift the P2 range so that the current reading matches the P1 reading.
' - Mix
Sub ReRangeP2(P1Reading As Single)

    Dim diff As Single
    Dim lastPres%
    
    ' Store the current Pres% for gauge reading
    lastPres% = Pres%

    '''''''''''''''''''''''''''''''''''''''''''''''''

    ' Set to read P2 high range
    Pres% = 2
    ' Read P2 high range
    ReadXReturnX4 2
    
    ' Shift P2 high range
    diff = x5 - P1Reading
    PY1(2) = PY1(2) - diff
    PY2(2) = PY2(2) - diff
    WPPS "Capstuff", "PY1_2", str$(PY1(2)), CSFile$
    WPPS "Capstuff", "PY2_2", str$(PY2(2)), CSFile$
    atm_x4(2) = x4
    
    '''''''''''''''''''''''''''''''''''''''''''''''''
    
    ' Set to read P2 low range
    Pres% = 3
    ' Read P2 low range
    ReadXReturnX4 2
    
    ' Shift P2 low range
    diff = x5 - P1Reading
    PY1(3) = PY1(3) - diff
    PY2(3) = PY2(3) - diff
    WPPS "Capstuff", "PY1_3", str$(PY1(3)), CSFile$
    WPPS "Capstuff", "PY2_3", str$(PY2(3)), CSFile$
    atm_x4(3) = x4
    
    '''''''''''''''''''''''''''''''''''''''''''''''''
    
    ' Restore Pres%
    Pres% = lastPres%

End Sub
